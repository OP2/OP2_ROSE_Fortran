/*
 * Written by Adam Betts
 *
 * The parallel loop class used to recognise and manipulate 'op_par_loop' calls
 * in Fortran code.
 *
 * This class extends AstSimpleProcessing since that class provides
 * utilities to traverse the Abstract Syntax Tree (AST).
 */

#ifndef OPPARLOOP_H
#define OPPARLOOP_H

#include <rose.h>

class OpParLoop: public AstSimpleProcessing
{
  private:
    /*
     * ====================================================================================================
     * Private data
     * ====================================================================================================
     */

    /*
     * The project which the source-to-source translator operates upon
     */
    SgProject *project;

    /*
     * The kernel output files
     */
    std::vector <SgSourceFile *> kernelOutputFiles;

    /*
     * Each 'op_par_loop' in Fortran takes 2+4n arguments.
     * We need the number n to declare a certain number of variables
     * in the host function
     */
    int numberOfArgumentGroups;

    /*
     * The statements to append to the file and their associated
     * scope stack
     */
    std::vector <SgStatement*> statements;
    std::vector <SgScopeStatement*> scopes;

    /*
     * ====================================================================================================
     * Private functions
     * ====================================================================================================
     */

    void
    setSourcePosition (SgLocatedNode* locatedNode);

    /*
     * used to tell Rose that the generated node is actually generated by ourselves, and not as some transformation of the
     * parser result (i.e. from input source files)
     */
    void
    setSourcePositionCompilerGenerated (SgLocatedNode * locatedNode);

    SgModuleStatement *
    buildModuleStatementAndDefinition (std::string name,
        SgScopeStatement * scope);

    SgContainsStatement *
    buildContainsStatement (Sg_File_Info * fileInfo, SgScopeStatement * scope);

    void
    addUseStatements (SgSourceFile& sourceFile,
        SgDeclarationStatement* definingDeclaration, SgScopeStatement* scope);

    void
    addImplicitStatement (SgSourceFile& sourceFile,
        SgDeclarationStatement* definingDeclaration, SgScopeStatement* scope);

    void
    generateKernelSubroutine (SgSourceFile &sourceFile,
        std::string subroutineName, SgExpressionPtrList& args);

    void
    createHostDeviceLocals (SgScopeStatement* scope);

    /*
     * Creates an integer declaration, representing the indirection of the data
     * set to be iterated, and attaches it to the formal parameter list
     */
    void
    createIndirectionDeclaration (SgFunctionParameterList* parameters,
        SgScopeStatement* scope);

    /*
     * Creates an OP_ACCESS declaration and attaches it to the
     * formal parameter list
     */
    void
    createOpAccessDeclaration (SgFunctionParameterList* parameters,
        SgScopeStatement* scope);

    /*
     * Creates an OP_DAT declaration and attaches it to the
     * formal parameter list
     */
    void
    createOpDatDeclaration (SgFunctionParameterList* parameters,
        SgScopeStatement* scope, SgType* opDatType);

    /*
     * Creates an OP_Map declaration and attaches it to the
     * formal parameter list
     */
    void
    createOpMapDeclaration (SgFunctionParameterList* parameters,
        SgScopeStatement* scope, SgType* opMapType);

    /*
     * Creates an OP_SET declaration and attaches it to the
     * formal parameter list
     */
    void
    createOpSetDeclaration (SgFunctionParameterList* parameters,
        SgScopeStatement* scope, SgType* opSetType);

    /*
     * Creates a char array declaration, which is the kernel name,
     * and attaches it to the formal parameter list
     */
    void
    createSubroutineName (SgFunctionParameterList* parameters,
        SgScopeStatement* scope);

    /*
     * Creates a host subroutine for the kernel
     */
    void
    createHostSubroutine (std::string kernelName, SgExpressionPtrList& args,
        SgSourceFile& sourceFile, SgModuleStatement& moduleStatement);

    /*
     * Creates a Fortran module to which the Fortran subroutines will
     * be inserted
     */
    SgModuleStatement*
    createModule (std::string kernelName, SgSourceFile& sourceFile);

    /*
     * Creates the source file to be unparsed
     */
    SgSourceFile*
    createSourceFile (std::string kernelName);

  public:
    /*
     * ====================================================================================================
     * Public functions
     * ====================================================================================================
     */

    /*
     * Constructor requires the source files contained in the
     * project to detect 'op_par_loops'
     */
    OpParLoop (SgProject *project);

    /*
     * Visit each vertex in the AST
     */
    virtual void
    visit (SgNode *n);

    /*
     * Generate output files for each kernel
     */
    void
    unparse ();
};

#endif /* OPPARLOOP_H_ */
