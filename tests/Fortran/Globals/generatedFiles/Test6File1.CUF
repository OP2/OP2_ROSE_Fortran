MODULE GENERATED_MODULE
  USE ISO_C_BINDING
  USE OP2_C
  USE cudaConfigurationParams
  USE CUDAFOR
  TYPE  :: integer4Scalar_integer4Scalar_max_opDatDimensions
  INTEGER(kind=4) :: opDat1Dimension
  END TYPE integer4Scalar_integer4Scalar_max_opDatDimensions

  TYPE  :: integer4Scalar_integer4Scalar_max_opDatCardinalities
  INTEGER(kind=4) :: opDat1Cardinality
  END TYPE integer4Scalar_integer4Scalar_max_opDatCardinalities

  LOGICAL :: isFirstTime_integer4Scalar_integer4Scalar_max = .TRUE.
  TYPE ( integer4Scalar_integer4Scalar_max_opDatCardinalities ) , DEVICE :: sizes_integer4Scalar_integer4Scalar_max
  TYPE ( integer4Scalar_integer4Scalar_max_opDatDimensions ) , DEVICE :: dimensions_integer4Scalar_integer4Scalar_max
  INTEGER(kind=4), ALLOCATABLE :: reductionArrayHost12885098247(:)
  INTEGER(kind=4), DEVICE, ALLOCATABLE :: reductionArrayDevice12885098247(:)
  CONTAINS

  attributes(device) SUBROUTINE ReductionInteger4(reductionResult,inputValue,warpSize,reductionOperation)
    INTEGER(kind=4), DEVICE :: reductionResult(:)
    INTEGER(kind=4), VALUE :: inputValue
    INTEGER(kind=4), VALUE :: warpSize
    INTEGER(kind=4), VALUE :: reductionOperation
    INTEGER(kind=4), SHARED :: sharedInteger4(0:*)
    INTEGER(kind=4) :: i1
    INTEGER(kind=4) :: threadID
    threadID = threadidx%x - 1
    i1 = ishft(blockdim%x,-1)
    CALL syncthreads()
    sharedInteger4(threadID) = inputValue

    DO WHILE (i1 > 0)
      CALL syncthreads()

      IF (threadID < i1) THEN

        SELECT CASE(reductionOperation)
          CASE (0)
          sharedInteger4(threadID) = sharedInteger4(threadID) + sharedInteger4(threadID + i1)
          CASE (1)

          IF (sharedInteger4(threadID + i1) < sharedInteger4(threadID)) THEN
            sharedInteger4(threadID) = sharedInteger4(threadID + i1)
          END IF

          CASE (2)

          IF (sharedInteger4(threadID + i1) > sharedInteger4(threadID)) THEN
            sharedInteger4(threadID) = sharedInteger4(threadID + i1)
          END IF

        END SELECT

      END IF

      i1 = ishft(i1,-1)
    END DO

    CALL syncthreads()

    IF (threadID .EQ. 0) THEN

      SELECT CASE(reductionOperation)
        CASE (0)
        reductionResult(1) = reductionResult(1) + sharedInteger4(0)
        CASE (1)

        IF (sharedInteger4(0) < reductionResult(1)) THEN
          reductionResult(1) = sharedInteger4(0)
        END IF

        CASE (2)

        IF (sharedInteger4(0) > reductionResult(1)) THEN
          reductionResult(1) = sharedInteger4(0)
        END IF

      END SELECT

    END IF

    CALL syncthreads()
  END SUBROUTINE

  attributes (device) SUBROUTINE s1020563346(x,y)
    IMPLICIT NONE
    INTEGER(kind=4), DEVICE :: x
    INTEGER(kind=4), DEVICE :: y
    x = max(x * y,x + y)
  END SUBROUTINE

  attributes (global) SUBROUTINE s1747559351(dimensions_s1020563346,sizes_s1020563346,opDat2,setSize,warpSize,sharedMem&
  &oryOffset)
    IMPLICIT NONE
    TYPE ( integer4Scalar_integer4Scalar_max_opDatDimensions ) , DEVICE :: dimensions_s1020563346
    TYPE ( integer4Scalar_integer4Scalar_max_opDatCardinalities ) , DEVICE :: sizes_s1020563346
    INTEGER(kind=4), VALUE :: opDat2
    INTEGER(kind=4), VALUE :: setSize
    INTEGER(kind=4), VALUE :: warpSize
    INTEGER(kind=4), VALUE :: sharedMemoryOffset
    INTEGER(kind=4) :: opDat1Local
    INTEGER(kind=4) :: i1
    INTEGER(kind=4) :: i2
    INTEGER(kind=4) :: localOffset
    INTEGER(kind=4) :: nelems
    INTEGER(kind=4) :: threadID
    threadID = mod(threadidx%x - 1,warpSize)

    DO i1 = threadidx%x - 1 + (blockidx%x - 1) * blockdim%x, setSize - 1, blockdim%x * griddim%x
      localOffset = i1 - threadID
      nelems = min(warpSize,setSize - localOffset)
      CALL s1020563346(opDat1Local,opDat2)
    END DO

    CALL ReductionInteger4(reductionArrayDevice12885098247(blockidx%x - 1:blockidx%x - 1),opDat1Local,warpSize,2)
  END SUBROUTINE

  attributes (host) SUBROUTINE s1514303263(userSubroutine,set,opDat1,opIndirection1,opMap1,opAccess1,opDat2,opIndirecti&
  &on2,opMap2,opAccess2)
    IMPLICIT NONE
    CHARACTER, INTENT(IN) :: userSubroutine*(33)
    TYPE ( op_set ) , INTENT(IN) :: set
    TYPE ( op_dat ) , INTENT(IN) :: opDat1
    INTEGER(kind=4), INTENT(IN) :: opIndirection1
    TYPE ( op_map ) , INTENT(IN) :: opMap1
    INTEGER(kind=4), INTENT(IN) :: opAccess1
    TYPE ( op_dat ) , INTENT(IN) :: opDat2
    INTEGER(kind=4), INTENT(IN) :: opIndirection2
    TYPE ( op_map ) , INTENT(IN) :: opMap2
    INTEGER(kind=4), INTENT(IN) :: opAccess2
    INTEGER(kind=4) :: opDat1Cardinality
    INTEGER(kind=4), POINTER :: opDat1Host
    INTEGER(kind=4), POINTER :: opDat2Host
    INTEGER(kind=4) :: nblocks
    INTEGER(kind=4) :: nthreads
    INTEGER(kind=4) :: nshared
    INTEGER(kind=4) :: threadSynchRet
    INTEGER(kind=4) :: sharedMemoryOffset
    INTEGER(kind=4) :: warpSize
    INTEGER(kind=4) :: i1
    INTEGER(kind=4) :: i2
    INTEGER(kind=4) :: reductionCardinality

    IF (isFirstTime_integer4Scalar_integer4Scalar_max .EQV. .TRUE.) THEN
      dimensions_integer4Scalar_integer4Scalar_max%opDat1Dimension = opDat1%dim
      sizes_integer4Scalar_integer4Scalar_max%opDat1Cardinality = set%size
      isFirstTime_integer4Scalar_integer4Scalar_max = .FALSE.
    END IF

    nblocks = 200
    nthreads = 128
    warpSize = OP_WARP_SIZE
    nshared = 4
    sharedMemoryOffset = nshared * OP_WARP_SIZE
    nshared = nshared * nthreads
    opDat1Cardinality = set%size
    CALL c_f_pointer(opDat1%dat,opDat1Host)
    CALL c_f_pointer(opDat2%dat,opDat2Host)
    reductionCardinality = nblocks * 1

    DO i1 = 0, reductionCardinality, 1
      reductionArrayHost12885098247(i1) = 0
    END DO

    reductionArrayDevice12885098247 = reductionArrayHost12885098247
    CALL s1747559351<<<nblocks, nthreads, nshared>>>(dimensions_integer4Scalar_integer4Scalar_max,sizes_integer4Scalar_&
    &integer4Scalar_max,opDat2Host,set%size,warpSize,sharedMemoryOffset)
    threadSynchRet = cudaThreadSynchronize()
    reductionArrayHost12885098247 = reductionArrayDevice12885098247

    DO i1 = 0, reductionCardinality, 1
      opDat1Host = max(reductionArrayHost12885098247(i1),opDat1Host)
    END DO

  END SUBROUTINE

END MODULE GENERATED_MODULE

