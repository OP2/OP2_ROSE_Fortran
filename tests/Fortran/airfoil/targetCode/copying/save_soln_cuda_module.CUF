
! TO DO: automatically generated

module save_soln_cuda_module

use OP2_C
use cudaConfigurationParams
use constantVarsCuda


contains

! subroutine called by the kernel (modified by eliminating c void pointers)
attributes(device) subroutine save_soln ( q, qold )

	implicit none

	! declaration of formal parameters
	real(8), device :: q(*)
	real(8), device :: qold(*)
	
	! iteration variable
	integer(4) :: i

	! size_q and size_qold are the same value
	do i = 1, 4
		qold(i) = q(i)
	end do

end subroutine save_soln

! kernel function
attributes(global) subroutine op_cuda_save_soln ( q, qold, setsize )

	use cudafor

	implicit none
	
	! declaration of formal parameters
	integer(4), value :: size_q, size_qold, setsize

	! Compiler: 4 is generated by looking at the calls op_decl_dat ( q .. ) and op_decl_dat ( qold .. )
	real(8), device :: q(0:setsize * 4 -1)
	real(8) , device :: qold(0:setsize * 4 -1)

	! local variable
	integer(4) :: setIter

	setIter = (threadidx%x - 1) + (blockidx%x -1)  * blockdim%x

	! warning: in this implementation this loop is called only one time for each thread
	do while ( setIter < setsize )
	
		! calling user function (TODO: check that indexes are properly computed for FORTRAN)
		call save_soln ( q(setIter * 4:setIter * 4 + 4 - 1), qold(setIter * 4:setIter*4 + 4 - 1) )
		
		! incrementing the iterator
		setIter = setIter + blockdim%x * griddim%x
	enddo


end subroutine op_cuda_save_soln

! caller of the kernel
attributes(host) subroutine op_par_loop_save_soln ( subroutineName, set, &
																 & arg0, idx0, ptr0, access0, &
																 & arg1, idx1, ptr1, access1 &
															 & )

	! use directives	
	use, intrinsic :: ISO_C_BINDING
	use cudafor

	! mandatory	
	implicit none

	! declaration of intrinsic functions	
	intrinsic int
	
	! formal arguments
	character, dimension(*), intent(in) :: subroutineName
	
  ! data set on which we loop
  type(op_set), intent(in) :: set

	! data ids used in the function
	type(op_dat) :: arg0, arg1
	
	! index to be used in first and second pointers
	integer(4), intent(in) :: idx0, idx1
	
	! ptr ids for indirect access to data
	type(op_map) :: ptr0, ptr1
	
	! access values for arguments
	integer(4), intent(in) :: access0, access1


	! local variables
	
	! used for mallocs and memcpys
	integer(4) :: data0Size, data1Size, CRet
	type(op_set) :: tmpSet
	
	! used to pass correct argument type to kernel..
	real(8), device, allocatable :: fortranArg0(:), fortranArg1(:)
	
	
	! define and compute grid and block sizes and other variables (unused in this case)
	integer(4) :: bsize = BSIZE_DEFAULT
	integer(4) :: gsize
	integer(4) :: reduct_bytes = 0
	integer(4) :: reduct_size = 0
	real(8) :: reduct_shared
	integer(4) :: const_bytes = 0


	real(8), dimension(:), allocatable, device :: argument0
	real(8), dimension(:), allocatable, device :: argument1

	real(8), dimension(:), pointer :: c2fPtr0
	real(8), dimension(:), pointer :: c2fPtr1

	! COMMANDS
	
	! TODO: modify cast for fortran syntax 
	gsize = int ((set%size - 1) / bsize + 1)
	reduct_shared = reduct_size * (BSIZE_DEFAULT / 2)
	
	
	tmpSet = arg0%set	
	data0Size = ( arg0%dim * tmpSet%size)

	tmpSet = arg1%set
	data1Size = ( arg1%dim * tmpSet%size)

	allocate ( argument0 ( data0Size ) )
	allocate ( argument1 ( data1Size ) )
		
	call c_f_pointer ( arg0%dat, c2fPtr0, (/data0Size/) )
	call c_f_pointer ( arg1%dat, c2fPtr1, (/data1Size/) )
	
	
	argument0 = c2fPtr0
	argument1 = c2fPtr1

	
	! apply kernel to all set elements
	call op_cuda_save_soln<<<gsize,bsize,reduct_shared>>> ( argument0, argument1, set%size )


	 c2fPtr0 = argument0
	 c2fPtr1 = argument1

	deallocate ( argument0 )
	deallocate ( argument1 )
	
	! profiling - stop (TODO: need to be stored somewhere or returned)
	!	cudaEventRecord(stop,0);
	!  cudaThreadSynchronize();
	!  cudaEventElapsedTime(&elapsed_time_ms,start,stop);
	!  cudaEventDestroy(start);
	!  cudaEventDestroy(stop);
	
end subroutine op_par_loop_save_soln




end module save_soln_cuda_module