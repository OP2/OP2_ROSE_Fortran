// #########################################################
// #########################################################
//                      HEADER CODE
// #########################################################
// #########################################################

HEADER_START
     public:
       // DQ (8/19/2004): Remove old attribute mechanism
       // void output_pragma(ostream& os);
       // void set_pragma();

       // DQ (11/17/2004): Make this a virtual function since we have several different implementations 
       // (e.g. where the scope is stored explicitly) Effected declarations:
       //     class declarations (and derived classes (e.g. template instantiation declarations)
       //     template declarations (which covers all forms of template declarations for classes, functions, and member functions)
       //     function declarations (including member functions, template functions and template member functions)
       //     variable declarations
          virtual SgScopeStatement *get_scope(void) const;

          virtual void setExtern() ROSE_DEPRECATED_FUNCTION;
          virtual void setStatic() ROSE_DEPRECATED_FUNCTION;

      protected:
          virtual bool replace_child(SgStatement *target,SgStatement * newStmt, 
                                         bool extractListFromBasicBlock = false);
          virtual bool insert_child(SgStatement*, SgStatement*, bool inFront = true, 
                                         bool extractListFromBasicBlock = false);
       public:
          
      /* 
          name Low-Level Rewrite Support
          \brief Support for mutation of the AST.

          This is the lowest level of support for the mutation of the AST.  From these 
          primitives we have built more sophisticated mechanisms which are simpler to 
          use and which automate many details (not handled within these functions):
             -# Preservation of attached comments
             -# Marking new IR nodes with correct file info position objects
                (often just the specification of the new code as a transformation).
             -# ...\n

          Higher level mechanism for the manipulation of the AST are available in the
          \ref ASTRewriteMechanism. These higher-level interfaces simplify the 
          manipulation of the AST.

          \internal Need to document this section more fully.
       */

          /*!
             \brief This function inserts a single statement at the position indicated by target.

             This function handles the insertion of the specified statement at the target location.
             The boolean variable specifies if the new statement is inserted before or after the target 
             statement.

             \param target - location in the AST where new statement is to be inserted.
             \param newstmt - New statement to be placed into the AST.
             \param inFront - if true the new statement is inserted before the target statement, else
                              the new statement is inserted after the target statement (default = true).
             \return Function returns void.
          */
          void insert_statement(SgStatement* target, SgStatement* newstmt, bool inFront = true);
          /*!
             \brief This function inserts a list of statements at the position indicated by target.

             This function handles the insertion of a list of statements at the target location.
             The boolean variable specifies if the new statements are inserted before or after the target 
             statement.

             \param target - location in the AST where new statements are to be inserted.
             \param newstmt - List of new statements to be placed into the AST.
             \param inFront - if true the new statements are inserted before the target statement, else
                              the new statements are inserted after the target statement (default = true).
             \return Function returns void.
          */
          void insert_statement(SgStatement* target, const SgStatementPtrList& newstmtList, bool inFront = true);
         /*!
             \brief This function replaces the target statement with a single statement.

             This function handles the replacement of the specified target statement with a new statement.

             \param target - location of the statement to be replaced.
             \param newstmt - New statement to replace target statement in the AST.
             \return Function returns void.
          */
           void replace_statement(SgStatement* target, SgStatement* newstmt);
          /*!
             \brief This function replaces the target statement with a list of statements.

             This function handles the replacement of the specified target statement with 
             a list of statements at the target location.

             \param target - location of the statement to be replaced.
             \param newstmt - List of new statements to replace the target statement in the AST.
             \return Function returns void.
          */
           void replace_statement(SgStatement* target, const SgStatementPtrList& newstmtList);
         /*!
             \brief This function removes the target statement from the AST.

             This function handles the removal of the target statement from the AST.
             Any comments or C preprocessor directives associated with the statement
             are also removed.  This is a low level primitive for higher level functions
             (in the higher level interfaces) which take care to preserve such attributes.

             \param target - location of the statement to be removed.
             \return Function returns void.
          */
           void remove_statement(SgStatement *);
 
          /*!
             \brief This function inserts a statement at the position indicated by target.
             If newstmt is a basicBlock, statements inside newstmt are extracted and then inserted.

             This function handles the insertion of the specified statement at the target location.
             The boolean variable specifies if the new statement is inserted before or after the target 
             statement.  This function has somewhat unusual semantics.

             \internal This function is low level support (only used by Qing)

             \param target - location in the AST where new statement is to be inserted.
             \param newstmt - New statement to be placed into the AST.
             \param inFront - if true the new statement is inserted before the target statement, else
                              the new statement is inserted after the target statement (default = true).
             \return Function returns void.

             \deprecated This function is used only in Qing's code and not clearly a part of the preferred interface.
          */
          void insert_statement_from_basicBlock(SgStatement* target, SgStatement* newstmt, bool inFront = true);

          /*!
             \brief This function replaces the target statement with a new statement.
             If newstmt is a basicBlock, statements inside newstmt are extracted and then inserted.

             This function handles the replacement of the target statement with the new statement.
             This function has somewhat unusual semantics.

             \internal This function is low level support (only used by Qing)

             \param target - statement in AST to be replaced..
             \param newstmt - New statement to be placed into the AST.
             \return Function returns void.

             \deprecated This function is used only in Qing's code and not clearly a part of the preferred interface.
          */
          void replace_statement_from_basicBlock(SgStatement* target, SgStatement* newstmt);

       // DQ (12/6/2006): Added to support general replace functions (used in statements that
       // directly contain SgExpression IR nodes, e.g. SgForStatement's increment expression).
          /*!
             \brief support general replace functions, used in statements that directly contain SgExpression IR nodes.
          */
          virtual int replace_expression(SgExpression *,SgExpression *);

       /* */

      // DQ (12/5/2004): Support for setting explicit scopes (where stored explicitly).
      //! Support for setting scopes (only meaningful on IR statements that store the scope explicitly).
          virtual void set_scope ( SgScopeStatement* newScope );

      //! Support for where the scope is explicitly required
          virtual bool hasExplicitScope() const;

      // DQ (2/6/2007): Added support for getting the symbol from the declaration (I think that Beata ask for this at some point).
      //! Get the associated symbol from the symbol table in the stored scope
          virtual SgSymbol* get_symbol_from_symbol_table() const;

#if 0
       // Commented out by Dan Quinlan (while we worry about other main-line features)
          void set_purecc();
          void unset_purecc();
          int get_is_purecc() const;
          void add_pragma(int cnt, SgPragma** plist);
          SgPragma* add_pragma(char *nm) ;
          SgPragma* get_pragma(char *nm) const;
          int remove_pragma(char *nm) ;

       // get attribute,
          SgAttribute* get_user_attribute(char *nm) const;
          SgAttribute* add_user_attribute(char *nm,SgAttribute *attr);
          int remove_user_attribute(char *nm);
#endif

	  // Overriding SgNode versions of these
          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int index) const;
          virtual unsigned int cfgFindChildIndex(SgNode* n);
          virtual unsigned int cfgFindNextChildIndex(SgNode* n);
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

       // get lvalue
		  virtual bool isChildUsedAsLValue(const SgExpression* child) const; // INTERNAL

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (12/16/2007): Added virtual function so that we could set the end_numeric_label on all relevant Fortran constructs
       // virtual void set_end_numeric_label(SgLabelSymbol* end_numeric_label);
          virtual void set_end_numeric_label(SgLabelRefExp* end_numeric_label);

       // Report if a construct has a concept of end_numeric_label
          virtual bool has_end_numeric_label() const;

HEADER_END


HEADER_X_STATEMENT_START
       // void post_construction_initialization();
HEADER_X_STATEMENT_END


HEADER_NON_X_STATEMENT_START
       // void post_construction_initialization();
HEADER_NON_X_STATEMENT_END


HEADER_SCOPE_STATEMENT_START

     public:

       // Since we suppress the generation of the constructors we have to declare them explicitly
       // SgScopeStatement ();
          $CLASSNAME ( Sg_File_Info* file_info = NULL );

       // DQ (9/8/2004): Added to support qualified name generation
          virtual SgName get_qualified_name() const;

       // DQ (2/22/2007): Added mangled name support for scopes so that the 
       // mangled names for declarations could have better support!
          virtual SgName get_mangled_name() const;

       // DQ (2/10/2007): Added member function.
      //! return number of entries in symbol table for the specified name
      //! (note that it is sometime OK for there to be more than 1).
          size_t count_symbol(const SgName& n);

       // Single interface for inserting symbol into symbol table
          void insert_symbol(const SgName& n, SgSymbol* s);

       // DQ (2/10/2007): I would like to deprecate this since it returns and integer and is not named well for such a return type!
       // see if this is in symbol table already
          int lookup_symbol( const SgName& n, SgSymbol* s) const ROSE_DEPRECATED_FUNCTION;

       // DQ (2/10/2007): Do we want an interface like this?
       // Note that these are relatively expensive functions since they do an exhaustive search of the symbol table.
          bool symbol_exists ( const SgName &, SgSymbol *sp ) const;
          bool symbol_exists ( const SgName & name ) const;
          bool symbol_exists ( const SgSymbol *sp ) const;

       // remove an existing symbol from the symbol table (does not call delete on the symbol)
          void remove_symbol ( SgSymbol* s );

       // DQ (1/30/2007): Many of these have been added back into ROSE, now we have examples showing they are 
       // required to find the different types of symbols that can be placed into the same 
       // scope using the same name.

       //! get the first symbol with name (note that "" is a valid name and is used for unnamed declarations)
       //! the input name is stored as internal state to support the use of next_XXX_symbol() member function.
          SgSymbol*          lookup_symbol            (const SgName& n) const;
          SgVariableSymbol*  lookup_var_symbol        (const SgName& n) const ROSE_DEPRECATED_FUNCTION;
          SgVariableSymbol*  lookup_variable_symbol   (const SgName& n) const;
          SgClassSymbol*     lookup_class_symbol      (const SgName& n) const;
          SgFunctionSymbol*  lookup_function_symbol   (const SgName& n) const;
          SgFunctionSymbol*  lookup_function_symbol   (const SgName& n, const SgType* t) const;
          SgTypedefSymbol*   lookup_typedef_symbol    (const SgName& n) const;
          SgEnumSymbol*      lookup_enum_symbol       (const SgName& n) const;
       // SgEnumFieldSymbol* lookup_enumfield_symbol  (const SgName& n) const ROSE_DEPRECATED_FUNCTION;
          SgEnumFieldSymbol* lookup_enum_field_symbol (const SgName& n) const;
          SgLabelSymbol*     lookup_label_symbol      (const SgName& n) const;
          SgNamespaceSymbol* lookup_namespace_symbol  (const SgName& n) const;
          SgTemplateSymbol*  lookup_template_symbol   (const SgName& n) const;

       //! get the first symbol independent of name (lack of name is stored as internal state)
          SgSymbol*          first_any_symbol        () const;
       // SgVariableSymbol*  first_var_symbol        () const ROSE_DEPRECATED_FUNCTION;
          SgVariableSymbol*  first_variable_symbol   () const;
          SgClassSymbol*     first_class_symbol      () const;
          SgFunctionSymbol*  first_function_symbol   () const;
          SgTypedefSymbol*   first_typedef_symbol    () const;
          SgEnumSymbol*      first_enum_symbol       () const;
       // SgEnumFieldSymbol* first_enumfield_symbol  () const ROSE_DEPRECATED_FUNCTION;
          SgEnumFieldSymbol* first_enum_field_symbol () const;
          SgLabelSymbol*     first_label_symbol      () const;
          SgNamespaceSymbol* first_namespace_symbol  () const;
          SgTemplateSymbol*  first_template_symbol   () const;

       // Should we have a member function like this!
       // SgFunctionSymbol*  first_function_symbol  (const SgType* t) const;

       //! Only use after lookup_XXX_symbol(const SgName&) or after first_XXX_symbol()
       //! These functions use the stored state of the name or lack of name (from the 
       //! lookup_XXX_symbol(const SgName&) or after first_XXX_symbol() member function) 
       //! and return the next symbol.
          SgSymbol*          next_any_symbol        () const;
       // SgVariableSymbol*  next_var_symbol        () const ROSE_DEPRECATED_FUNCTION;
          SgVariableSymbol*  next_variable_symbol   () const;
          SgClassSymbol*     next_class_symbol      () const;
          SgFunctionSymbol*  next_function_symbol   () const;
          SgTypedefSymbol*   next_typedef_symbol    () const;
          SgEnumSymbol*      next_enum_symbol       () const;
       // SgEnumFieldSymbol* next_enumfield_symbol  () const ROSE_DEPRECATED_FUNCTION;
          SgEnumFieldSymbol* next_enum_field_symbol () const;
          SgLabelSymbol*     next_label_symbol      () const;
          SgNamespaceSymbol* next_namespace_symbol  () const;
          SgTemplateSymbol*  next_template_symbol   () const;

       // Should we have a member function like this!
       // SgFunctionSymbol*  next_function_symbol  (const SgType* t) const;

       /* additional symbol table insertion utility routines */
          void print_symboltable(const std::string& str, std::ostream& os = std::cout);

#if 0
       // DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
       // The next for functions have been placed back into the Sage III interface.
          SgSymbol *first_any_symbol();
          SgVariableSymbol *first_variable_symbol();
          SgSymbol *next_any_symbol();
          SgVariableSymbol *next_variable_symbol();
#endif

#if 0
       // Not clear if we need more insert functions to support the X version terminals/nonterminals
          SgVariableSymbol *insert_symbol(const SgInitializedNamePtrList::iterator&);
          SgVariableSymbol *insert_symbol(SgVariableDeclaration *);
          SgFunctionSymbol *insert_symbol(SgFunctionDeclaration *);
          SgMemberFunctionSymbol *insert_symbol(SgMemberFunctionDeclaration *);
          SgClassSymbol *insert_symbol(SgClassDeclaration *cdecl);
          SgEnumSymbol *insert_symbol(SgEnumDeclaration *cdecl);
          SgTypedefSymbol *insert_symbol(SgTypedefDeclaration *);
          SgLabelSymbol *insert_symbol(SgLabelStatement *);

          SgEnumFieldSymbol *insert_enum_symbol(const SgInitializedNamePtrList::iterator&);
#endif

       // DQ (7/17/2002) Added to support rewrite mechanism some scopes can only contain
       // SgDeclarationStmt while others can contain any kind of SgStatement
      //! This function is used to indicate if either the getDeclarationList() or 
      //! getStatementList() can be called to return a reference to the list of IR nodes 
      //! (manipulation of the list is then possible).
          bool containsOnlyDeclarations() const;
          void insertStatementInScope ( SgStatement* newTransformationStatement, bool atTop );
          SgDeclarationStatementPtrList & getDeclarationList();
          SgStatementPtrList & getStatementList();

       // DQ (10/6/2007): Added to support const version of generateStatementList()
          const SgDeclarationStatementPtrList & getDeclarationList() const;
          const SgStatementPtrList & getStatementList() const;

       // DQ (2/1/2007): Made the return type const to reflect that the list is read-only.
      //! Generate s list of statements from either the existing list of statements or
      //! the list of declarations.  This permits access via a common type (SgStatement).
      //! (this list is constructed and manipulation of it will not effect the scope's 
      //! SgStatementPtrList or SgDeclarationStatementPtrList. So this should be considered
      //! to be a read only list.
          const SgStatementPtrList generateStatementList() const;

       // DQ (5/22/2006): Added function here so that it could be defined for all scopes (instead of just a few)
       // virtual SgName get_mangled_name (void) const;

       // DQ (10/18/2006): Not all scopes permit function declarations.
       /*! \brief Reports if scope can support defining function declarations.
       // Not all scopes permit function declarations. Any function prototype in a 
       // scope appropriate for a function definition triggers requirements for name qualification.
       // This function returns true if the scope is appropriate for the definition of a function
       // or member function (i.e. is a SgGlobal, SgClassDefinition, or SgNamespaceDefinitionStatement).
       */
          bool supportsDefiningFunctionDeclaration();

       // DQ (2/20/2007): Added support for AST merge (which requires unique names for even un-named 
       // constructs (we use the position in scope as part of the unique name generation).  This has to
       // be non-const since it calls the non-const list functions.  This could all be fixed, I think.
      //! Generate a unique number for the statement in the scope. 
          unsigned int generateUniqueStatementNumberForScope( SgStatement* statement );

      //! Helper for generateUniqueStatementNumberForScope: return true if the
      //! element is found, incrementing the counter once for each element of
      //! tree up to either the element of the end of the sub-statements in the
      //! current statement
          bool generateUniqueStatementNumberForScopeHelper( unsigned int& counter, SgStatement* statement );

       // DQ (6/5/2007): Build special operator to return by reference
      /*! \brief This list of symbols represent types that will require type elaboration when source code is generated.
       */
          std::set<SgSymbol*> & get_type_elaboration_list ();

      /*! \brief This list of symbols represent types that will require name qualification when the type name is output.
       */
          std::set<SgSymbol*> & get_hidden_type_list ();

      /*! \brief This list of symbols represent declarations that will require name qualification when the identifier name is output.
       */
          std::set<SgSymbol*> & get_hidden_declaration_list ();

       // DQ (6/5/2007): Build special operators set the hidden lists (not clear if these are used or required)
          void set_type_elaboration_list ( const std::set<SgSymbol*> & type_elaboration_list );
          void set_hidden_type_list ( const std::set<SgSymbol*> & hidden_type_list );
          void set_hidden_declaration_list ( const std::set<SgSymbol*> & hidden_declaration_list );

       // DQ (6/14/2007): Added to support simpler handling of general scopes (used in EDG/Sage translation).
      //! Higher level function to handle statements and declarations is scopes.
          void append_statement ( SgStatement* stmt );
          void prepend_statement ( SgStatement* stmt );

          SgStatement* firstStatement() const;
          SgStatement* lastStatement() const;

  // protected:

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (11/28/2010): Added case sensitive/insensitive option to symbol table behavior.
      //! Query of scope symbol table behavior (is symbol table behavior case sensitive (C/C++) or case insensitive (Fortran).
          bool isCaseInsensitive() const;
          void setCaseInsensitive(bool b);

     public:


HEADER_SCOPE_STATEMENT_END


HEADER_STATEMENT_POSTDECLARATION_START

// DQ (12/30/2009): This has been moved from SOURCE_MAIN_STATEMENT to
// here so that ic can be referenced from the separate source files 
// now optionally generated within ROSE to support smaller ROSETTA 
// generated files.

#if 1
// DQ (12/30/2009): This does not appear to be required to be a template function (base class will work just fine).

// Replace target with newstmt if target matches 'cur'
template <class Elemtype> 
inline bool
StatementReplace (SgStatement *parent, Elemtype *& cur, SgStatement *target, SgStatement *newstmt)
   {
     if (cur == target)
        {
       // newstmt can be NULL or it must be compatible with cur's type
       // assert( newstmt == 0 || newstmt->variantT() == cur->variantT());
          ROSE_ASSERT (newstmt == 0 || dynamic_cast<Elemtype*>(newstmt));
#ifndef REMOVE_SET_PARENT_FUNCTION
       // DQ (9/24/2004): Parent will be set in the AST fixup (in post-processing of the AST in AST Fixup)
       // Should not be set within EDG/Sage III connection code!
          printf ("Warning: Temporarily skipping set_parent in StatementReplace \n");
       // if (newstmt != 0)
       //    newstmt->set_parent( parent);
#endif

          cur = static_cast<Elemtype *>(newstmt);
          parent->set_isModified(true);
          return true;
        }
     return false;
   }
#else
// DQ (12/30/2009): This is an attempt to build a more portable function to support new smaller ROSETTA generated files.
// If we want to build this as a non-template function then we will have to reference "SgLocatedNode *& cur" as 
// "SgLocatedNode ** cur" (or perhaps using SgStatement), else the types prevent the function from working.
inline bool
StatementReplace (SgStatement *parent, SgStatement *& cur, SgStatement *target, SgStatement *newstmt)
// StatementReplace (SgStatement *parent, SgLocatedNode *& cur, SgStatement *target, SgStatement *newstmt)
   {
     if (cur == target)
        {
       // newstmt can be NULL or it must be compatible with cur's type
          ROSE_ASSERT (newstmt == NULL || newstmt->variantT() == cur->variantT());

       // cur = static_cast<Elemtype *>(newstmt);
       // cur = static_cast<SgStatement*>(newstmt);
          cur = static_cast<SgLocatedNode*>(newstmt);

          parent->set_isModified(true);
          return true;
        }
     return false;
   }
#endif

#if 0
// DQ (12/30/2009): This has been moved to the header file since it was a used in
// several places and could not be supported in the source file now that we 
// support the generation of smaller and more numerous files by ROSETTA.
inline Sg_File_Info* New_File_Info( SgLocatedNode *p)
   {
  // DQ (11/20/2004): Modified to provide more accurate information, use the 
  // copy constructor instead of the constructor that takes a file name.
  // return new Sg_File_Info( p->get_file_info()->get_filename());

  // DQ (11/6/2006): startOfConstruct is the one Sg_File_Info that will always exist and must exist.
  // ROSE_ASSERT(p->get_file_info() != NULL);
  // Sg_File_Info* returnFileInfo = new Sg_File_Info( *( p->get_file_info() ) );
  // ROSE_ASSERT(returnFileInfo != NULL);
     ROSE_ASSERT(p->get_startOfConstruct() != NULL);
     Sg_File_Info* returnFileInfo = new Sg_File_Info( *( p->get_startOfConstruct() ) );
     ROSE_ASSERT(returnFileInfo != NULL);

  // printf ("In New_File_Info: returnFileInfo = %p \n",returnFileInfo);

     return returnFileInfo;
   }
#else
// Temporary while we move code to use generateMatchingFileInfo directly.
inline Sg_File_Info* New_File_Info( SgLocatedNode *p)
   {
     ROSE_ASSERT(p != NULL);
     return p->generateMatchingFileInfo();
   }
#endif

HEADER_STATEMENT_POSTDECLARATION_END


HEADER_POST_CONSTRUCTION_INITIALIZATION_START
          void post_construction_initialization();
HEADER_POST_CONSTRUCTION_INITIALIZATION_END


HEADER_FUNCTION_TYPE_TABLE_START

      //! Constructor
       // $CLASSNAME ();
       // SgFunctionTypeTable( bool case_insensitive = false );
          SgFunctionTypeTable();

          void insert_function_type(const SgName&, SgType *);
       // void insert_function_type(const SgFunctionDeclaration *);

          SgType* lookup_function_type (const SgName&);

       // DQ (1/31/2007): Added to support AST merge.
          void remove_function_type(const SgName&);

          void print_functypetable(std::ostream& os = std::cout);

HEADER_FUNCTION_TYPE_TABLE_END

          void prepend_statement(const SgStatementPtrList::iterator& where, SgStatement *what);
          void append_statement(const SgStatementPtrList::iterator& where, SgStatement *what);


HEADER_DECLARATION_STATEMENT_START

       // DQ (5/9/2005): Added support for template specialization!
       /*! \brief Template Specialization Support

           different forms of template specialization for - classes, functions, and variable declarations
        */
          enum template_specialization_enum
             {
               e_unknown                      = 0, /*!< unknown value (error value) */
               e_no_specialization            = 1, /*!< not a specialization (default value) */
               e_partial_specialization       = 2, /*!< partial specialization */
               e_specialization               = 3, /*!< specialization */
               e_template_specialization_last = 4  /*!< last value (unused) */
             };

      /*! \brief GNU extension for visibility modifier (only one value can be specified)

          Visibility modifier information about (unspecified, hidden, protected, internal).

          \internal Only one value can be specified.
       */
          enum gnu_extension_visability_attribute_enum
             {
            // Bit values can support multiple values in a single enum type
               e_gnu_attribute_visability_unknown     = 0, /*!< Unknown value (error) */
               e_gnu_attribute_visability_unspecified = 1, /*!< Default value */
               e_gnu_attribute_visability_hidden      = 2, /*!< hidden visibility attribute */
               e_gnu_attribute_visability_protected   = 3, /*!< protected visibility attribute */
               e_gnu_attribute_visability_internal    = 4, /*!< internal visibility attribute */
               e_last_gnu_visability_attribute   /*!< last visibility attribute value (upper bound on range of values, used in error checking) */
             };

       // DQ (4/25/2004): Part of new interface to declaration modifiers (refactoring).
       // The following access functions are not technically modifiers as defined
       // in the language. They act like modifiers to the unparser and to the 
       // representation of the original source structure within the AST.

       // this is to distinguish a forward declaration (class or function)
       // class X;
       // class X { };

       // DQ (11/28/2009): Changed return type from "int" to "bool"
          bool  isForward() const;
          void setForward();
          void unsetForward();

       // this is to distinguish cases like this
       // class-P pvar;            -- isNameOnly=1
       // class-P { int a; } pvar; -- isNameOnly=0

       // DQ (11/28/2009): Changed return type from "int" to "bool"
          bool  isNameOnly() const;
          void setNameOnly();
          void unsetNameOnly();

       // DQ (11/28/2009): Changed return type from "int" to "bool"
          bool  isExternBrace() const;
          void setExternBrace();
          void unsetExternBrace();

       // this is to distinguish cases like this
       // class P var;
       // P var;

       // DQ (11/28/2009): Changed return type from "int" to "bool"
          bool  skipElaborateType() const;
          void setSkipElaborateType();
          void unsetSkipElaborateType();

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const;

     protected:
       // Protected support for templates used within SgTemplateInstantiationDeclaration
       // SgTemplateInstantiationFunctionDecl and SgTemplateInstantiationMemberFunctionDecl
          void resetTemplateNameSupport ( bool & nameResetFromMangledForm, SgName & name );

       // Tests names generated specific to templates (such names should exclude 
       // "<<" and ">>" since that will cause generated code to not compile).
          void testForBadGenerateTemplateName( const std::string & name );

       // Support for skipping the "<" and ">" when the output of the template argument list would be empty.
          bool skipEmptyTemplateArgumentListTest ( SgFunctionDeclaration* functionDeclaration );

       // DQ (12/30/2009): Uncomment this so that it can be placed into a class and not be a global scope (or file scope function).
       // DQ (4/28/2005): names of template functions are setup with a name of the form "foo<int>" 
       // and must be converted to a name that can be more easily mangled (with out "<" and ">").
       // SgName fixupTemplateNameForMangledNameSupport( const SgName & s) const;
          SgName fixupTemplateNameForMangledNameSupport( const SgName & s) const;

       // DQ (6/2/2006): Support for name mangling of unnamed classes embedded in 
       // SgVariableDeclaration and SgTypedefDeclaration.
          SgName generate_alternative_name_for_unnamed_declaration ( SgNode* parent ) const;

       // DQ (6/3/2006): Support for unnamed declaration is scopes.
          SgName generate_alternative_name_for_unnamed_declaration_in_scope ( SgScopeStatement* scope ) const;

     public:

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (10/10/2006): Handle qualified name list at the declarations directly, instead of at the types.
       // At present these are useful for SgVariableDeclaration and SgTypedefDeclaration, but likely others
       // at some point.
          SgQualifiedNamePtrList & get_qualifiedNameList();
          const SgQualifiedNamePtrList & get_qualifiedNameList() const;
          void set_qualifiedNameList( const SgQualifiedNamePtrList & x );

       // DQ (2/10/2007): Added virtual function to make it easier to use this on 
       // the specific declarations where it is meaningful (ones associated with symbols).
       // This appears to have already been done a few days ago!
       // virtual SgSymbol* get_symbol_from_symbol_table();

       // DQ (2/11/2007): Added to support the virtual function in derived classes
          virtual SgSymbol* get_symbol_from_symbol_table() const;

       // DQ (7/4/2007): Get the declaration for which get_symbol_from_symbol_table() returns a valid pointer.
          SgDeclarationStatement* get_declaration_associated_with_symbol() const;

       // DQ (7/4/2007): Search for a symbol from either the first non-defining 
       // declaration or the defining declaration (this should always return a valid symbol). 
          SgSymbol* search_for_symbol_from_symbol_table() const;

       // DQ (7/26/2007): report which declarations can be expected to have an associated symbol, 
       // since not all declarations are associated with a symbol.  This is mostly used for internal 
       // testing so that we can know when to verify rules about associated symbols.
          bool hasAssociatedSymbol() const;

HEADER_DECLARATION_STATEMENT_END

HEADER_TEMPLATE_SPECIALIZATION_SUPPORT_START

     public:
          bool isSpecialization() const;
          bool isPartialSpecialization() const;

HEADER_TEMPLATE_SPECIALIZATION_SUPPORT_END


HEADER_LIST_DECLARATIONS_START
     public:
          void append_LIST_FUNCTION_NAME  ( LIST_ELEMENT_DATA_TYPE element );
          void prepend_LIST_FUNCTION_NAME ( LIST_ELEMENT_DATA_TYPE element );

     public:
       // New functions added
       // LIST_FUNCTION_RETURN_TYPE append_LIST_FUNCTION_NAME  ( const LIST_DATA_TYPE::iterator & list, LIST_ELEMENT_DATA_TYPE element );
       // LIST_FUNCTION_RETURN_TYPE prepend_LIST_FUNCTION_NAME ( const LIST_DATA_TYPE::iterator & list, LIST_ELEMENT_DATA_TYPE element );

       // LIST_FUNCTION_RETURN_TYPE insert_LIST_FUNCTION_NAME  ( const LIST_DATA_TYPE::iterator & list, LIST_ELEMENT_DATA_TYPE element );


     public:

HEADER_LIST_DECLARATIONS_END


HEADER_GLOBAL_START

       // DQ (9/8/2004): Added to support general name qualification
          virtual SgName get_qualified_name() const;

       // DQ (2/22/2007): Added support for mangled name of SgGlobal to better support generation of 
       // mangled names which include the scope! Previously the mangled name of some declarations used
       // the qualified name of the scope which put "::" substrings into the mangled names!  This is
       // inappropriate because the mangled names have to be able to be variable names and must follow 
       // C/C++ standards for construction of variable names.
          virtual SgName get_mangled_name() const;

       // DQ (10/6/2006): Support for mangle name caching (for better performance)
       // std::map<SgNode*,std::string> & get_mangledNameCache();
       // std::map<std::string, int> & get_shortMangledNameCache();

          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
          virtual bool cfgIsIndexInteresting(unsigned int idx) const;
          virtual unsigned int cfgIndexForEnd() const;

#if 1
       // DQ (10/1/2009): Adding support for new name qualification.
          void buildStatementNumbering();
#endif

HEADER_LIST_DECLARATIONS

     protected:
          virtual bool insert_child(SgStatement*, SgStatement*, bool inFront = true,
                                         bool extractListFromBasicBlock = false);
          virtual bool replace_child(SgStatement *,SgStatement *,
                                         bool extractListFromBasicBlock = false);

     public:

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_GLOBAL_END


HEADER_BASIC_BLOCK_START

       // DQ (9/8/2004): Added to support general name qualification
          virtual SgName get_qualified_name() const;

       // DQ (2/22/2007): Added for uniform support of mangled names
          virtual SgName get_mangled_name() const;

       // Special case constructor
          SgBasicBlock ( Sg_File_Info* info = NULL, SgStatement* stmt = NULL );
       // SgBasicBlock ( Sg_File_Info* info);
          SgBasicBlock ( SgStatement* stmt );

HEADER_LIST_DECLARATIONS

       // DQ (6/18/2007): Added these required function declarations explicitly so that we could test 
       // removing them from the template where they are generated excessively (and definitions are not
       // implemented).
       // void append_statement (const SgStatementPtrList::iterator& where, SgStatement* what);
       // void prepend_statement(const SgStatementPtrList::iterator& where, SgStatement* what);

       protected:
          virtual bool replace_child(SgStatement *,SgStatement *,
                                         bool extractListFromBasicBlock = false);

          virtual bool insert_child(SgStatement*, SgStatement*, bool inFront = true,
                                         bool extractListFromBasicBlock = false);
      public:

          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int) const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

       // void prepend_statement(const SgStatementPtrList::iterator& where, SgStatement *what);
       // void append_statement(const SgStatementPtrList::iterator& where, SgStatement *what);

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_BASIC_BLOCK_END


HEADER_BASIC_BLOCK_POSTDECLARATION_START
// The following template function requires the definition of SgBasicBlock, so 
// we put it in the POSTDECLARATION.

#if 1
// DQ (12/30/2009): This has been moved to the header file since it was a used in
// several places and could not be supported in the source file now that we 
// support the generation of smaller and more numerous files by ROSETTA.
template <class Elemtype> 
inline bool
StatementListInsertChild( SgStatement *parent, Rose_STL_Container<Elemtype*>& l,  SgStatement *target, 
                          SgStatement *n, bool inFront, bool extractFromBasicBlock, bool removeCurrent)
   {
#if 0
     printf ("In StatementListInsertChild: l.size() = %zu \n",l.size());
     printf ("In StatementListInsertChild: inFront  = %s \n",inFront ? "true" : "false");
     printf ("In StatementListInsertChild: parent   = %p \n",parent);
     printf ("In StatementListInsertChild: target   = %p \n",target);
     printf ("In StatementListInsertChild: n        = %p \n",n);
#endif

     ROSE_ASSERT(parent != NULL);
     ROSE_ASSERT(target != NULL);

  // DQ (7/19/2005): Milind says that we can comment this out (because the remove function 
  // calls the replace function which calls this insert function with n == NULL)
  // This function's name is misleading and could be more clear.
  // ROSE_ASSERT(n != NULL);

     bool targetLocated = find(l.begin(),l.end(),target) != l.end();
     if (targetLocated == false)
        {
          printf ("Error: target statement = %p not found in list of statements provided. \n",target);
          ROSE_ASSERT(false);
        }
  // ROSE_ASSERT (find(l.begin(),l.end(),target) != l.end());

     unsigned int size = l.size();
     for (unsigned int p = 0; p < size; ++p)
        {
       // printf ("Looping through the list of statements! p = %p \n",l[p]);
          if ( l[p] == target )
             {
               if (removeCurrent)
                  {
                 // DQ (9/27/2007): Reported as an error by STL debugging mode, fixed as part of move from std::list to std::vector uniformly in ROSE.
                    l.erase(l.begin() + p);

                    parent->set_isModified(true);
                  }

               if (!inFront)
                    ++p;
#if 0
            // DQ (12/6/2004): This interfers with the execution of the EDG/Sage III translation!
            // DQ (12/5/2004): There should be a valid scope (set before passing the statement to this function!)
               ROSE_ASSERT(n == NULL || n->get_scope() != NULL);
#endif

               SgBasicBlock *bn = extractFromBasicBlock? isSgBasicBlock(n) : NULL; 
               if (bn == NULL)
                  {
                    assert(n == 0 || dynamic_cast<Elemtype*>(n) != 0);
                    if (n != 0)
                       {
                      // DQ (10/17/2004): We MUST set the parent here, the string based AST rewrite mechanism 
                      // requires this semantics. Previously it was removed as part of the movement toward an 
                      // initialization of the parent pointers within a post processing phase.  This post-processing
                      // phase was a result of an attempt (successful) to remove side-effects from the set_xxx 
                      // access functions generated by ROSETTA.  At some point parents will be be initialized within 
                      // the EDG/Sage interface, but we will be more careful how it is done and not reintroduce the 
                      // previous side-effects back into the access functions.
                         n->set_parent(parent);

                      // DQ (12/5/2004): Later in the day I discovered that this allows member functions to be defined 
                      // as have a scope which is not a class definition (which is an error caught in the unparser!).
                      // So it would be good to make the scope correctly (this could be a start at marking all other 
                      // pointers within a new node added by the rewrite system correctly!).  I think the solution is 
                      // to set the scope before it gets to this function since this is a general mechanism for inserting 
                      // statements and not one which should have such a side-effect as setting or resetting the scope 
                      // of statements containing explicit scope pointers.

                      // DQ (6/24/2006): The scope is not explicitly represented and this is not required 
                      // ("n->set_scope(parentScope);" was already commented out so this is unused code).

                      // DQ (12/5/2004): If the scope is stored explicitly then we must also set the scope of the new 
                      // statement.  But we will not know the scope, so for now derive it structurally (using the parent).
                      // But not all statements have a set_scope function, so see if this one does.
                         SgScopeStatement* parentScope = isSgScopeStatement(parent);

                         if (parentScope == NULL)
                              parentScope = parent->get_scope();

                      // This is simple error checking
                         ROSE_ASSERT(parentScope != NULL);
                      // n->set_scope(parentScope);

                         l.insert(l.begin() + p, static_cast<Elemtype*>(n));
                         parent->set_isModified(true);
                       }
                  }
                 else
                  {
                    SgStatementPtrList& nl = bn->get_statements();
                    for (SgStatementPtrList::iterator pp = nl.begin(); pp != nl.end(); ++pp)
                       {
                         SgStatement* stmt = *pp;
                         assert(dynamic_cast<Elemtype*>(stmt) != NULL);

                      // DQ (10/17/2004): We MUST set the parent here, see note in true part of conditional (above).
                         stmt->set_parent(parent);

                      // DQ (12/5/2004): We MUST set the scope here, see note in true part of conditional (above).
                         SgScopeStatement* parentScope = isSgScopeStatement(parent);
                         if (parentScope == NULL)
                              parentScope = parent->get_scope();
                      // This is simple error checking
                         ROSE_ASSERT(parentScope != NULL);
                      // n->set_scope(parentScope);

                         l.insert(l.begin() + p, static_cast<Elemtype*>(stmt));
                         parent->set_isModified(true);
                       }
                  }

               return true;
             }
        }

     return false;
   }
#endif

HEADER_BASIC_BLOCK_POSTDECLARATION_END


HEADER_IF_STATEMENT_START

      protected:
          virtual bool replace_child(SgStatement *,SgStatement *,
                                         bool extractListFromBasicBlock = false);
      public:

          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int) const;
          virtual unsigned int cfgFindChildIndex(SgNode* n);
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

       // DQ (2/22/2007): Added for uniform support of mangled names
          virtual SgName get_mangled_name() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_IF_STATEMENT_END


HEADER_FOR_STATEMENT_START

HEADER_LIST_DECLARATIONS

       // DQ (2/18/2006): This is now computed at runtime
       // void set_mangled_name();

          SgStatementPtrList & get_init_stmt();
          const SgStatementPtrList & get_init_stmt() const;

       protected:
          virtual bool replace_child(SgStatement *,SgStatement *,
                                         bool extractListFromBasicBlock = false);
       public:

       // DQ (11/25/2005): Support for previous interface function.
          SgExpression*     get_test_expr () const                                 ROSE_DEPRECATED_FUNCTION;
          void              set_test_expr (SgExpression* expression )              ROSE_DEPRECATED_FUNCTION;
       // SgExpressionRoot* get_test_expr_root () const                            ROSE_DEPRECATED_FUNCTION;
       // void              set_test_expr_root (SgExpressionRoot* expressionRoot ) ROSE_DEPRECATED_FUNCTION;

          int replace_expression(SgExpression * original_expression, SgExpression * new_expression );

          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int) const;
          virtual unsigned int cfgFindChildIndex(SgNode* n);
          virtual unsigned int cfgFindNextChildIndex(SgNode* n);
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

       // DQ (2/22/2007): Added for uniform support of mangled names
          virtual SgName get_mangled_name() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_FOR_STATEMENT_END


HEADER_FOR_INIT_STATEMENT_START
        protected:
          virtual bool replace_child(SgStatement *,SgStatement *,
                                         bool extractListFromBasicBlock = false);
          virtual bool insert_child(SgStatement*, SgStatement*, bool inFront = true,
                                         bool extractListFromBasicBlock = false);
        public:

          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_LIST_DECLARATIONS
HEADER_FOR_INIT_STATEMENT_END

HEADER_FORALL_STATEMENT_START
          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int) const;
          virtual unsigned int cfgFindChildIndex(SgNode* n);
          virtual unsigned int cfgFindNextChildIndex(SgNode* n);
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
HEADER_FORALL_STATEMENT_END


HEADER_CATCH_STATEMENT_SEQ_START
HEADER_LIST_DECLARATIONS
          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int) const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_CATCH_STATEMENT_SEQ_END


HEADER_FUNCTION_DECLARATION_STATEMENT_START

      //! Support for C++ covariant return types (used in virtual function overloading).
          SgType* get_orig_return_type() const;

       // Empty declaration substitution
       // void set_mangled_name();
       // SgName get_mangled_name() const;

       // RV (1/31/2006): Removed dependence on SgUnparse_Info, and made virtual.
          virtual SgName get_mangled_name(void) const;

       // DQ (4/28/2005): functions that are SgTemplateInstatiationMemberFunctionDecl can be non-template 
       // functions in a class that is a template class or a nested class in a templated class, this function 
       // identifies the SgTemplateInstatiationMemberFunctionDecl as being a template function if it has 
       // template parameters.
          bool isTemplateFunction() const;

          SgInitializedNamePtrList & get_args() ;
          const SgInitializedNamePtrList & get_args() const;

      //! Support for where the scope is explicitly required
          virtual bool hasExplicitScope() const;

          virtual SgSymbol* get_symbol_from_symbol_table() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_LIST_DECLARATIONS

#if 0
       // DQ (10/20/2004): Since constructor names don't require their template arguments this has a far simpler solution!
       // for example: "template <typename T> class X { X(); }; X<int>::X() {}"

       // DQ (10/20/2004): This function should be different from those that are automatically generated 
       // via ROSETTA.  In the case of a constructor or destructor the class name should be used.  This 
       // is particularly important in the case of constructors and destructors of templated classes since 
       // the mangled form or the template class should not be used since it will not allow the generated 
       // code to compile.  Instead of names of the form "ABC____L8" we want names of the form "ABC<int>".
       // These functions are now implemented explicitly instead of being automatically generated via ROSETTA.
          SgName get_name() const;
          void set_name( SgName & functionName );
#endif

          void hasEllipses();

       // DQ (5/3/2005): Added get_qualified_name() function for interface symmetry (and because 
       // it makes sense given that the same function can exist in two different namespaces and 
       // that only the qualified name would distinguish them).
          virtual SgName get_qualified_name() const;

     protected:
          virtual bool replace_child(SgStatement *,SgStatement *,
                                         bool extractListFromBasicBlock = false);
     public:  // (see comment above)

          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

HEADER_FUNCTION_DECLARATION_STATEMENT_END

HEADER_FUNCTION_PARAMETER_LIST_START
HEADER_LIST_DECLARATIONS

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const;

          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_FUNCTION_PARAMETER_LIST_END

HEADER_CTOR_INITIALIZER_LIST_START
HEADER_LIST_DECLARATIONS

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const;

       // MD (7/09/2010): Added virtual CFG methods
          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
          

HEADER_CTOR_INITIALIZER_LIST_END


HEADER_FUNCTION_DEFINITION_STATEMENT_START

          SgFunctionDeclaration* get_declaration() const;
          void set_declaration(SgFunctionDeclaration* new_val);

          SgFunctionDefinition(Sg_File_Info* f, SgFunctionDeclaration* d, SgBasicBlock* body = 0);
          SgFunctionDefinition(SgFunctionDeclaration* d, SgBasicBlock* body);

          void append_statement  ( SgStatement* what );
          void prepend_statement ( SgStatement* what );

        protected:
          virtual bool replace_child(SgStatement *,SgStatement *,
                                         bool extractListFromBasicBlock = false);
        public:

       // RV (2/5/2006): Added name mangling for function definitions
          virtual SgName get_mangled_name (void) const;

       // DQ (10/5/2006): Added support for storing unique block numbering within functions 
       // (cache values in a map instead of recomputing them, this also permits cache invalidation).
          std::map<SgNode*,int> & get_scope_number_list();
          int get_scope_number ( const SgNode* scope ) const;
          void clearScopeNumbers();
          void resetScopeNumbers();

          SgName get_qualified_name() const;

          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int) const;
          virtual unsigned int cfgFindChildIndex(SgNode* n);
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

       // MD (09/20/2010): Accessor for preinitialization lists associated with 
       // this (constructor) definition. NULL if this has no such list.
          virtual SgCtorInitializerList* get_CtorInitializerList() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_FUNCTION_DEFINITION_STATEMENT_END


HEADER_MEMBER_FUNCTION_DECLARATION_STATEMENT_START

          bool isDefinedInClass() const;

HEADER_LIST_DECLARATIONS

          virtual SgName get_qualified_name() const;
          void set_orig_return_type( SgType *);

         SgInitializedNamePtrList & get_ctors();
         const SgInitializedNamePtrList & get_ctors() const;

      protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false);

     public:

       // DQ (11/16/2004): Added local get_class_scope function to support version of get_scope which would 
       // return a SgClassDefinition rather than a SgScopeStatement.  This version is more consistent with 
       // the former get_scope() function which is not defined in the base class and must return a 
       // SgScopeStatement to be sufficiently general.
       /* \brief This function returns the scope if it exists (is defined in the current translation unit).

          This function is different from the get_scope() member function is that it can return a NULL pointer.
          A NULL pointer indicates that the class definition does not exist (was not defined in the current 
          translation unit), this can happen for pointers to member functions only.
        */
          SgClassDefinition* get_class_scope(void) const;

       /* \brief This returns the associated class (even if the class definition is unavailable).

          This is a public function with a special custom implementation that always returns a valid pointer 
          to a class declaration even if the get_class_scope() function returns a NULL pointer. This is the 
          case for a pointer to a member function (see test2007_116.C).

          \implementation This is much more than a simple access function for the p_associatedClassDeclaration data member.
        */
          SgClassDeclaration* get_associatedClassDeclaration () const;

      //! This is an access function for the p_associatedClassDeclaration data member.
          void set_associatedClassDeclaration ( SgClassDeclaration* associatedClassDeclaration );

          virtual SgSymbol* get_symbol_from_symbol_table() const;

          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/19/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_MEMBER_FUNCTION_DECLARATION_STATEMENT_END


HEADER_VARIABLE_DECLARATION_STATEMENT_START

      /*! \brief GNU extension for declaration modifiers (multiple values may be specified)

          GNU specific declaration modifiers.

          \internal Only one value can be specified.
       */
          enum gnu_extension_declaration_attributes_enum
             {
            // Bit values can support multiple values in a single enum type
               e_gnu_attribute_unknown              = 0, /*!< Unknown value (error) */
               e_gnu_attribute_unspecified          = 1, /*!< Default value */
               e_gnu_attribute__weak__              = 2, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__unused__            = 3, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__deprecated__        = 4, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__nocommon__          = 5, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__transparent_union__ = 6, /*!< GNU specific attribute for (GNU extension) */
               e_last_gnu_declaration_attribute /*!< last gnu declaration attribute value (upper bound on range of values, used in error checking) */
             };

       // Special constructor (not generated, I don't know why this is here)
       // SgVariableDeclaration (Sg_File_Info*, const SgName &, SgType*, SgInitializer*);

       // Special constructor
       // SgVariableDeclaration (Sg_File_Info *info, const SgName& var_name, 
       //                     SgType *type, SgInitializer *initializer = NULL );
          $CLASSNAME ( Sg_File_Info *info, const SgName& var_name, SgType *type, SgInitializer *initializer = NULL );
          $CLASSNAME ( const SgName& var_name, SgType *type, SgInitializer *initializer );

       // DQ (11/10/2006): This function is called by the custom written constructors (refactored code to simplify their implementation).
          void initializeData(Sg_File_Info *info, const SgName& var_name, SgType *type, SgInitializer *initializer);

          void setDeclarationOnly() ROSE_DEPRECATED_FUNCTION;
          void setExtern() ROSE_DEPRECATED_FUNCTION;
          void setStatic() ROSE_DEPRECATED_FUNCTION;
          SgVariableDefinition *get_definition( SgInitializedName* ditem = 0 );
          SgInitializedName *get_decl_item(const SgName&);
 //         SgInitializedName *get_defn_item(const SgName&);

       // I think this should be "unsigned long" instead of SgUnsignedLongVal (but I'm not certain!)
          SgUnsignedLongVal *get_bitfield();
          void set_bitfield (SgUnsignedLongVal*);

       // Only on the first variable declaration's
          int reset_initializer(SgInitializer *);

       // void printVariableName(int);
       // void printVariables(SgUnparse_Info&, ostream& os=cout);

          SgStatement *get_next(int &) const;

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const;

       // DQ (6/1/2006): Get the type (base type if more than one variable) used for all variables in this variable declaration.
       // SgType *get_type();

       // DQ (7/19/2005): SgVariableDeclaration should have a structural definition of its scope (based on position in 
       // source code) while the variables declared should (and do) have a possibly different scope (via name qualification).
       // DQ (7/4/2005): implement get_scope to query the initialized names in the initialized name list (SgInitializedNamePtrList)
       // without this function we evaluate the scope using a traversal of the parents!
       // SgScopeStatement* get_scope(void) const;

// HEADER_LIST_DECLARATIONS
     public:
#if 0
          SgInitializedNamePtrList::iterator append_variable  ( const SgInitializedName & what, SgInitializer* init );
          SgInitializedNamePtrList::iterator prepend_variable ( const SgInitializedName & what, SgInitializer* init );
          SgInitializedNamePtrList::iterator insert_variable  ( const SgInitializedNamePtrList::iterator & where, const SgInitializedName & what );
#else
       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
          void append_variable  ( SgInitializedName* what, SgInitializer* init );
          void prepend_variable ( SgInitializedName* what, SgInitializer* init );
          // void insert_variable  ( const SgInitializedNamePtrList::iterator & where, SgInitializedName* what );
#endif

          virtual unsigned int cfgIndexForEnd() const;
          virtual unsigned int cfgFindChildIndex(SgNode* n);
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

      //! Returns the defining declaration if get_variableDeclarationContainsBaseTypeDefiningDeclaration() is true, otherwise NULL.
          SgDeclarationStatement* get_baseTypeDefiningDeclaration() const;
          void set_baseTypeDefiningDeclaration(SgDeclarationStatement* d);

#if 0
       // This is now stored in the type modifier (I think this is a better implementation)

       // DQ (11/18/2007): Support for Fortran declaration attributes
       /* Fortran Specific Declaration Attributes
               e_unknown_attribute_spec,
               e_accessStatement,
               e_allocatableStatement,
               e_asynchronousStatement,
               e_bindStatement,
               e_dataStatement,
               e_dimensionStatement,
               e_externalStatement,
               e_intentStatement,
               e_intrinsicStatement,
               e_optionalStatement,
               e_parameterStatement,
               e_pointerStatement,
               e_protectedStatement,
               e_saveStatement,
               e_targetStatement,
               e_valueStatement,
               e_volatileStatement,
               e_last_attribute_spec
        */

       // Notes:
       //      access_x_Statement could be mapped to C++ access specifiers
       //      bind is more complex than just using a flag here
       //      dimension details are specified within the SgArrayType, the flag here indicates that it was used in the variable declaration explicitly.

          bool testAccess_private_Attribute() const;
          void setAccess_private_Attribute();
          void unsetAccess_private_Attribute();

          bool testAccess_protected_Attribute() const;
          void setAccess_protected_Attribute();
          void unsetAccess_protected_Attribute();

          bool testAccess_public_Attribute() const;
          void setAccess_public_Attribute();
          void unsetAccess_public_Attribute();

          bool testAllocatableAttribute() const;
          void setAllocatableAttribute();
          void unsetAllocatableAttribute();

          bool testAsynchronousAttribute() const;
          void setAsynchronousAttribute();
          void unsetAsynchronousAttribute();

          bool testBindAttribute() const;
          void setBindAttribute();
          void unsetBindAttribute();

          bool testDataAttribute() const;
          void setDataAttribute();
          void unsetDataAttribute();

          bool testDimensionAttribute() const;
          void setDimensionAttribute();
          void unsetDimensionAttribute();

          bool testExternalAttribute() const;
          void setExternalAttribute();
          void unsetExternalAttribute();

          bool testIntent_in_Attribute() const;
          void setIntent_in_Attribute();
          void unsetIntent_in_Attribute();

          bool testIntent_out_Attribute() const;
          void setIntent_out_Attribute();
          void unsetIntent_out_Attribute();

          bool testIntent_inout_Attribute() const;
          void setIntent_inout_Attribute();
          void unsetIntent_inout_Attribute();

          bool testIntrinsicAttribute() const;
          void setIntrinsicAttribute();
          void unsetIntrinsicAttribute();

          bool testOptionalAttribute() const;
          void setOptionalAttribute();
          void unsetOptionalAttribute();

          bool testParameterAttribute() const;
          void setParameterAttribute();
          void unsetParameterAttribute();

          bool testPointerAttribute() const;
          void setPointerAttribute();
          void unsetPointerAttribute();

          bool testProtectedAttribute() const;
          void setProtectedAttribute();
          void unsetProtectedAttribute();

          bool testSaveAttribute() const;
          void setSaveAttribute();
          void unsetSaveAttribute();

          bool testTargetAttribute() const;
          void setTargetAttribute();
          void unsetTargetAttribute();

          bool testValueAttribute() const;
          void setValueAttribute();
          void unsetValueAttribute();

          bool testVolatileAttribute() const;
          void setVolatileAttribute();
          void unsetVolatileAttribute();
#endif

     private:
       // GB (09/25/2007): Added this function as part of the traversal island fix.
          SgDeclarationStatement *compute_baseTypeDefiningDeclaration() const;

HEADER_VARIABLE_DECLARATION_STATEMENT_END


HEADER_VARIABLE_DEFINITION_STATEMENT_START
       // SgInitializedName *get_defn_item(); 
       // SgInitializedName *get_decl_item(); 
      //  void set_initializer(SgInitializer *);

       // I think this should be "unsigned long" instead of SgUnsignedLongVal (but I'm not certain!)
       // SgUnsignedLongVal *get_bitfield();
       // void set_bitfield (SgUnsignedLongVal*);

          SgVariableDeclaration *get_declaration();

          SgType *get_type();

       // Special constructor used by SgVariableDefinition
          SgVariableDefinition( Sg_File_Info *info, SgInitializedName *decl_item, SgInitializer *initializer);
          SgVariableDefinition( SgInitializedName *decl_item, SgInitializer *initializer);

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const;

HEADER_VARIABLE_DEFINITION_STATEMENT_END


HEADER_CLASS_DECLARATION_STATEMENT_START

       // enum class_types { e_class, e_struct, e_union };

      /*! A declaration can be of either class, struct, or union */
          enum class_types
             {
               e_class,             /*!< class declaration (default) */
               e_struct,            /*!< struct declaration */
               e_union,             /*!< union declaration */
               e_template_parameter /*!< type parameter in a template declaration */
             };

          virtual SgName get_qualified_name() const;

       // RV (1/31/2006): Added this mangler to replace 'get_mangled_qualified_name'
          virtual SgName get_mangled_name (void) const;

      //! \deprecated by RV (1/31/2006)
          SgName get_mangled_qualified_name(int & cnt );

        protected:
          virtual bool replace_child(SgStatement *,SgStatement *,
                                         bool extractListFromBasicBlock = false);
        public:

      //! Support for where the scope is explicitly required
          virtual bool hasExplicitScope() const;

          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

       // DQ (2/10/2007): I think this should have been marked virtual
          virtual SgSymbol* get_symbol_from_symbol_table() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

     protected:
       // GB (09/26/2007): Added this function as part of the move to index-based traversals.
          SgClassDefinition *compute_classDefinition() const;

HEADER_CLASS_DECLARATION_STATEMENT_END


HEADER_CLASS_DEFINITION_STATEMENT_START

HEADER_LIST_DECLARATIONS_1

HEADER_LIST_DECLARATIONS_2

          virtual SgName get_qualified_name() const;

       // RV (1/31/2006): Added this mangler to replace 'get_mangled_qualified_name'
          virtual SgName get_mangled_name (void) const;

      //! \deprecated
          SgName get_mangled_qualified_name(int& i);

          protected:
          virtual bool replace_child(SgStatement *,SgStatement *,
                                     bool extractListFromBasicBlock = false);

          virtual bool insert_child( SgStatement*, SgStatement*, bool inFront = true,
                                     bool extractListFromBasicBlock = false);

        public:

          SgClassDeclaration* get_declaration() const;
          void set_declaration(SgClassDeclaration* new_val);

          SgClassDefinition( Sg_File_Info *f, SgClassDeclaration* d);
          SgClassDefinition( SgClassDeclaration* d);

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/19/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_CLASS_DEFINITION_STATEMENT_END

HEADER_TEMPLATE_INSTANTIATION_DEFINITION_STATEMENT_START

       // DQ (3/18/2004): Generate template name with arguments
       //                 overrides base class implementation.
       // SgName get_name () const;

       // DQ (9/8/2004): overrides base class implementation
          virtual SgName get_qualified_name() const;

          SgTemplateInstantiationDefn( Sg_File_Info *f, SgTemplateInstantiationDecl* d);
          SgTemplateInstantiationDefn( SgTemplateInstantiationDecl* d);

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/19/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_TEMPLATE_INSTANTIATION_DEFINITION_STATEMENT_END


HEADER_ENUM_DECLARATION_STATEMENT_START
HEADER_LIST_DECLARATIONS

     public:
       // DQ (10/15/2004): added support for qualified names
          virtual SgName get_qualified_name() const;

       // RV (1/31/2006): Implemented mangler for enum declarations.
          virtual SgName get_mangled_name (void) const;

      //! Support for where the scope is explicitly required
          virtual bool hasExplicitScope() const;

       // DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
          virtual SgSymbol* get_symbol_from_symbol_table() const;

          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/18/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_ENUM_DECLARATION_STATEMENT_END


HEADER_EXPRESSION_STATEMENT_START

          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

       // DQ (12/6/2006): Added to support general replace functions.
          int replace_expression(SgExpression *,SgExpression *);

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_EXPRESSION_STATEMENT_END


HEADER_LABEL_STATEMENT_START
       // DQ (10/20/2004): This is not part of a uniform interface for all statements 
       // so it is not a particularly useful interface within a minimalist design.
       // Thus I have deprecated this function, users should use the get_label() 
       // function instead.
          SgName get_name() const ROSE_DEPRECATED_FUNCTION;

          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

       // DQ (2/10/2007): Marked as virtual to be consistent
          virtual SgSymbol* get_symbol_from_symbol_table() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

      //! Support for where the scope is explicitly required
          virtual bool hasExplicitScope() const;

HEADER_LABEL_STATEMENT_END


HEADER_WHILE_STATEMENT_START
       // void post_construction_initialization();
#if 0
          SgStatement* get_next(int&) const;
#endif

        protected:
          virtual bool replace_child(SgStatement *,SgStatement *,
                                         bool extractListFromBasicBlock = false);
        public:

          virtual bool cfgIsIndexInteresting(unsigned int) const;
          virtual unsigned int cfgIndexForEnd() const;
          virtual unsigned int cfgFindNextChildIndex(SgNode* n);
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

       // DQ (2/22/2007): Added for uniform support of mangled names
          virtual SgName get_mangled_name() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_WHILE_STATEMENT_END


HEADER_DO_WHILE_STATEMENT_START
        protected:
          virtual bool replace_child(SgStatement *,SgStatement *,
                                         bool extractListFromBasicBlock = false);
         public:

          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int) const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

       // DQ (2/22/2007): Added for uniform support of mangled names
          virtual SgName get_mangled_name() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_DO_WHILE_STATEMENT_END


HEADER_SWITCH_STATEMENT_START

// HEADER_LIST_DECLARATIONS

          void append_case(SgCaseOptionStmt *&);
          void prepend_case(SgCaseOptionStmt *&);
          void append_default(SgDefaultOptionStmt *&);

        protected:
          virtual bool replace_child(SgStatement *,SgStatement *,
                                         bool extractListFromBasicBlock = false);
        public:

          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int) const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

       // DQ (2/22/2007): Added for uniform support of mangled names
          virtual SgName get_mangled_name() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_SWITCH_STATEMENT_END


HEADER_CASE_OPTION_STATEMENT_START
        protected:
          virtual bool replace_child(SgStatement *,SgStatement *,
                                         bool extractListFromBasicBlock = false);

          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int) const;
          virtual unsigned int cfgFindChildIndex(SgNode* n);
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_CASE_OPTION_STATEMENT_END


HEADER_TRY_STATEMENT_START

          SgStatementPtrList & get_catch_statement_seq(); 
          const SgStatementPtrList & get_catch_statement_seq() const; 

HEADER_LIST_DECLARATIONS

#if 0
          SgStatement *get_next (int&) const;
#endif

        protected:
          virtual bool replace_child(SgStatement *,SgStatement *,
                                         bool extractListFromBasicBlock = false);
         public:
          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int) const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_TRY_STATEMENT_END


HEADER_CATCH_OPTION_STATEMENT_START
       // void post_construction_initialization();
#if 0
          SgStatement* get_next(int&) const;
#endif

       // DQ (2/22/2007): Added mangled name support for scopes so that the 
       // mangled names for declarations could have better support!
          virtual SgName get_mangled_name() const;

     protected:
          virtual bool replace_child(SgStatement *,SgStatement *,
                                         bool extractListFromBasicBlock = false);

         public:
          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_CATCH_OPTION_STATEMENT_END


HEADER_DEFAULT_OPTION_STATEMENT_START
       // void post_construction_initialization();
#if 0
          SgStatement* get_next(int&) const;
#endif

        protected:
          virtual bool replace_child(SgStatement *,SgStatement *,
                                         bool extractListFromBasicBlock = false);
        public:

          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int) const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_DEFAULT_OPTION_STATEMENT_END


HEADER_BREAK_STATEMENT_START
          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int) const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

HEADER_BREAK_STATEMENT_END


HEADER_CONTINUE_STATEMENT_START
          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int) const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

HEADER_CONTINUE_STATEMENT_END


HEADER_RETURN_STATEMENT_START

          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

          int replace_expression(SgExpression * original_expression, SgExpression * new_expression );

       // get lvalue
		  virtual bool isChildUsedAsLValue(const SgExpression* child) const; // INTERNAL
HEADER_RETURN_STATEMENT_END


HEADER_GOTO_STATEMENT_START
       // void post_construction_initialization();

        protected:
          virtual bool replace_child(SgStatement *,SgStatement *,
                                         bool extractListFromBasicBlock = false);
        public:

          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int) const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_GOTO_STATEMENT_END


HEADER_ASM_STATEMENT_START

          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

       // DQ (7/26/2006): Need a type for the list of registers used in the clobber list
          typedef std::vector<SgInitializedName::asm_register_name_enum> AsmRegisterNameList;

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const;

       // DQ (7/22/2006): We need these to be explicit since we can't support reference parameter passing within ROSETTA.
          SgExpressionPtrList& get_operands();
          const SgExpressionPtrList& get_operands() const;

       // DQ (7/27/2006): We need these to be explicit since we can't support reference parameter passing within ROSETTA.
          AsmRegisterNameList& get_clobberRegisterList();
          const AsmRegisterNameList& get_clobberRegisterList() const;

HEADER_ASM_STATEMENT_END


HEADER_SPAWN_STATEMENT_START

HEADER_SPAWN_STATEMENT_END


HEADER_NULL_STATEMENT_START

          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

HEADER_NULL_STATEMENT_END


HEADER_VARIANT_STATEMENT_START

HEADER_VARIANT_STATEMENT_END


HEADER_TYPEDEF_DECLARATION_STATEMENT_START
       // void post_construction_initialization();
#if 0
          SgStatement *get_next(int&) const;
#endif

     protected:
          virtual bool replace_child(SgStatement *,SgStatement *,bool extractListFromBasicBlock = false);
          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);


     public:
       // DQ (10/15/2004): added support for qualified names
          virtual SgName get_qualified_name() const;

       // RV (1/31/2006): Added this mangler for typedef declarations.
          virtual SgName get_mangled_name (void) const;

      //! Support for where the scope is explicitly required
          virtual bool hasExplicitScope() const;

       // DQ (2/10/2007): Marked as virtual to be consistent
          virtual SgSymbol* get_symbol_from_symbol_table() const;

      //! Returns the defining declaration if get_typedefBaseTypeContainsDefiningDeclaration() is true, otherwise NULL. Also same as get_declaration().
          SgDeclarationStatement* get_baseTypeDefiningDeclaration() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/14/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

     private:
       // GB (09/25/2007): Added this function as part of the traversal island fix.
      //! Internal support for the traversal mechanism.
          SgDeclarationStatement *compute_baseTypeDefiningDeclaration() const;

HEADER_TYPEDEF_DECLARATION_STATEMENT_END



HEADER_TEMPLATE_DECLARATION_STATEMENT_START
       // void post_construction_initialization();

      /*! Type of template declaration */
          enum template_type_enum 
             {
               e_template_none       = 0, /*!< error value */
               e_template_class      = 1, /*!< class template */
               e_template_m_class    = 2, /*!< nested class template */
               e_template_function   = 3, /*!< function template */
               e_template_m_function = 4, /*!< member function template */
               e_template_m_data     = 5  /*!< member data template (typically static member data) */
             };

       // DQ (9/8/2004): added support for qualified names
          virtual SgName get_qualified_name() const;

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const;

       // This is generated by ROSETTA, though we might want to implement
       // it differently if we want to get the name from the declaration!
       // SgName get_name() const;

      //! Support for where the scope is explicitly required
          virtual bool hasExplicitScope() const;

       // DQ (2/10/2007): Marked as virtual to be consistent
          virtual SgSymbol* get_symbol_from_symbol_table() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/19/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_TEMPLATE_DECLARATION_STATEMENT_END

HEADER_TEMPLATE_INSTANTIATION_DECLARATION_STATEMENT_START

#if 0
       // DQ (8/27/2005): This is not used!

       // DQ (3/11/2004): Use the base classes' version of this template_type_enum.
       // Actually we need this here since a template instantiation is derived from 
       // a class declaration.

       // The instantiated template is either a class or a function or member
       // data but can't be represented in the program tree by a string as the 
       // non-instantiated template (stuff) can be! So the only members that
       // make sense here are the ones specific to the class and member class
       // (nested class?) enum values.
      /*! Type of template declaration (borrowed values from SgTemplateDeclaration) */
          enum template_type_enum
             {
               e_template_none       = SgTemplateDeclaration::e_template_none,       /*!< error value */
               e_template_class      = SgTemplateDeclaration::e_template_class,      /*!< class template */
               e_template_m_class    = SgTemplateDeclaration::e_template_m_class,    /*!< nested class template */
               e_template_function   = SgTemplateDeclaration::e_template_function,   /*!< function template */
               e_template_m_function = SgTemplateDeclaration::e_template_m_function, /*!< member function template */
               e_template_m_data     = SgTemplateDeclaration::e_template_m_data      /*!< member data template (typically static member data) */
             };
#endif

       // DQ (3/21/2004): get_name assembles the full template name with arguments (e.g. "ABC<int>")
          void resetTemplateName();
       // SgName get_name () const;
       // void set_name (SgName name);

          virtual SgName get_qualified_name () const;

       // RV (1/31/2006): Added mangler for template instantiation declarations.
          virtual SgName get_mangled_name (void) const;

       // DQ (9/23/2004): Added function to hide base class interface so that we would only set the 
       // definition for a template instantiation declaration using a template instantiation definition.
       // At a later point the template instantiation definition will contain more information specific 
       // to it being a part of a template.
          void set_definition( SgTemplateInstantiationDefn* definition );

       // DQ (2/11/2007): Add this to the derived class so that the SgSymbolTable::find() function will work properly
          virtual SgSymbol* get_symbol_from_symbol_table() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (11/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_TEMPLATE_INSTANTIATION_DECLARATION_STATEMENT_END


HEADER_TEMPLATE_FUNCTION_INSTANTIATION_DECLARATION_STATEMENT_START

#if 0
       // DQ (8/27/2005): This is not used!

       // DQ (3/11/2004): Use the base classes' version of this template_type_enum.
       // Actually we need this here since a template instantiation is derived from 
       // a class declaration.

       // The instantiated template is either a class or a function or member
       // data but can't be represented in the program tree by a string as the 
       // non-instantiated template (stuff) can be! So the only members that
       // make sense here are the ones specific to the class and member class
       // (nested class?) enum values.
      /*! Type of template declaration (borrowed values from SgTemplateDeclaration) */
          enum template_type_enum
             {
               e_template_none       = SgTemplateDeclaration::e_template_none,       /*!< error value */
               e_template_class      = SgTemplateDeclaration::e_template_class,      /*!< class template */
               e_template_m_class    = SgTemplateDeclaration::e_template_m_class,    /*!< nested class template */
               e_template_function   = SgTemplateDeclaration::e_template_function,   /*!< function template */
               e_template_m_function = SgTemplateDeclaration::e_template_m_function, /*!< member function template */
               e_template_m_data     = SgTemplateDeclaration::e_template_m_data      /*!< member data template (typically static member data) */
             };
#endif

       // DQ (2/15/2005): Added resetTemplateName function to handle templated functions
       // DQ (5/8/2004): Not clear that this is useful for function name which  
       //                don't include the Template parameters in the name.
       // DQ (3/21/2004): get_name assembles the full template name with arguments (e.g. "ABC<int>")
          void resetTemplateName();
       // SgName get_name () const;
       // void set_name (SgName name);

       // RV (1/31/2006): Added mangler for template function instantiations.
          virtual SgName get_mangled_name (void) const;

       // DQ (2/11/2007): Add this to the derived class so that the SgSymbolTable::find() function will work properly
          virtual SgSymbol* get_symbol_from_symbol_table() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/19/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_TEMPLATE_FUNCTION_INSTANTIATION_DECLARATION_STATEMENT_END

HEADER_TEMPLATE_MEMBER_FUNCTION_INSTANTIATION_DECLARATION_STATEMENT_START
#if 0
       // DQ (8/27/2005): This is not used!

       // DQ (3/11/2004): Use the base classes' version of this template_type_enum.
       // Actually we need this here since a template instantiation is derived from 
       // a class declaration.

       // The instantiated template is either a class or a function or member
       // data but can't be represented in the program tree by a string as the 
       // non-instantiated template (stuff) can be! So the only members that
       // make sense here are the ones specific to the class and member class
       // (nested class?) enum values.
      /*! Type of template declaration (borrowed values from SgTemplateDeclaration) */
          enum template_type_enum
             {
               e_template_none       = SgTemplateDeclaration::e_template_none,       /*!< error value */
               e_template_class      = SgTemplateDeclaration::e_template_class,      /*!< class template */
               e_template_m_class    = SgTemplateDeclaration::e_template_m_class,    /*!< nested class template */
               e_template_function   = SgTemplateDeclaration::e_template_function,   /*!< function template */
               e_template_m_function = SgTemplateDeclaration::e_template_m_function, /*!< member function template */
               e_template_m_data     = SgTemplateDeclaration::e_template_m_data      /*!< member data template (typically static member data) */
             };
#endif

       // DQ (2/15/2005): Added resetTemplateName function to handle templated member functions
       // DQ (5/8/2004): Not clear that this is useful for function name which  
       //                don't include the Template parameters in the name.
       // DQ (3/21/2004): get_name assembles the full template name with arguments (e.g. "ABC<int>")
          void resetTemplateName();
       // SgName get_name () const;
       // void set_name (SgName name);

       // RV (1/31/2006): Added mangler for template member function instantiations.
      //! Returns a mangled name.
          virtual SgName get_mangled_name (void) const;

       // DQ (2/11/2007): Add this to the derived class so that the SgSymbolTable::find() function will work properly
          virtual SgSymbol* get_symbol_from_symbol_table() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (11/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_TEMPLATE_MEMBER_FUNCTION_INSTANTIATION_DECLARATION_STATEMENT_END



HEADER_PRAGMA_STATEMENT_START

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const;

          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

HEADER_PRAGMA_STATEMENT_END


HEADER_NAMESPACE_DECLARATION_STATEMENT_START

       // DQ (9/8/2004): Added to support qualified name generation
          virtual SgName get_qualified_name() const;

       // RV (1/31/2006): Added mangler for namespace declarations.
          virtual SgName get_mangled_name (void) const;

#if 0
       // Wrong, this should be structural and not explicitly stored
       // DQ (2/19/2006): The scope needs to be stored explicitly so that we can reference a single scope 
       // (that of the first declaration, referenced from the firstNondefiningDeclaration()  member function, 
       // instead of all the possible different scopes that could be referenced.  Ths allows simple rules 
       // to be applied to all IR SgDeclaration IR nodes and makes for better testing.  The parent pointer 
       // maintains the source code structural relationships, which the scope represents the semantic 
       // relationships.
      //! Support for where the scope is explicitly required
          virtual bool hasExplicitScope() const;
#endif

       // DQ (2/10/2007): Marked as virtual to be consistent
          virtual SgSymbol* get_symbol_from_symbol_table() const;

       // DQ (6/5/2007): Since namespaces are re-entrant we define a simple function to test if two namespaces 
       // are the same (not the same SgNamespaceDeclarationStatement, but the same namespace).
      //! Check if two namespaces are the same
          bool isSameNamespace( const SgNamespaceDeclarationStatement* n ) const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_NAMESPACE_DECLARATION_STATEMENT_END

HEADER_NAMESPACE_DEFINITION_STATEMENT_START

       // DQ (9/8/2004): Added to support qualified name generation
          virtual SgName get_qualified_name() const;

       // RV (1/31/2006): Added mangler for namespace definitions.
          virtual SgName get_mangled_name (void) const;

      //! Compare if to namespaces are the same namespace (may be different scopes).
          bool isSameNamespace(const SgNamespaceDefinitionStatement* n ) const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/19/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

     protected:
          virtual bool replace_child ( SgStatement *,SgStatement *, 
                                       bool extractListFromBasicBlock = false );
          virtual bool insert_child ( SgStatement*, SgStatement*, bool inFront = true, 
                                      bool extractListFromBasicBlock = false );

HEADER_LIST_DECLARATIONS

HEADER_NAMESPACE_DEFINITION_STATEMENT_END

HEADER_NAMESPACE_ALIAS_DECLARATION_STATEMENT_START

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const;

       // DQ (8/30/2009): Added namespace alias support.
          virtual SgSymbol* get_symbol_from_symbol_table() const;

HEADER_NAMESPACE_ALIAS_DECLARATION_STATEMENT_END

HEADER_USING_DIRECTIVE_STATEMENT_START

          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const;

HEADER_USING_DIRECTIVE_STATEMENT_END

HEADER_USING_DECLARATION_STATEMENT_START

          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

// DQ (7/21/2005): The using declaration can reference either a SgDeclarationStatement or a SgInitializedName
// object thus we need a single more general function to return whatever it is.  Maybe not!

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const;

HEADER_USING_DECLARATION_STATEMENT_END

HEADER_TEMPLATE_INSTANTIATION_DIRECTIVE_STATEMENT_START

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/15/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_TEMPLATE_INSTANTIATION_DIRECTIVE_STATEMENT_END

HEADER_PROGRAM_HEADER_STATEMENT_START
  /* HEADER_LIST_DECLARATIONS */
  // DQ (3/20/2007): These are automatically generated access functions from p_name (also added as a data member)
  // SgName get_name() const;
  // void set_name(SgName);

  // DQ (3/20/2007): These are no longer explicitly stored in the AST (they can be looked up in the symbol table)
  // SgFunctionType* get_type () const;
  // void set_type ( SgFunctionType* type );

  // DQ (3/20/2007): This is not required for a Fortran Program Header, I think. If it is it should be the 
  // return_type and should be added as a data member with the access functions automatically generated.
  // SgType* get_orig_return_type() const;

  // DQ (3/20/2007): I think we need this
     SgName get_mangled_name() const;

  // DQ (3/20/2007): This should be added as a data member with automatically generated access functions.
  // void set_parameterList ( SgFunctionParameterList* );

  // DQ (3/20/2007): Fortran Program's can't use arguments in this situation (rule 1102, Fortran 2003 Standard 04-007).
  // SgInitializedNamePtrList & get_args() ;
  // const SgInitializedNamePtrList & get_args() const;

     protected:
          virtual bool replace_child($GRAMMAR_PREFIX_Statement *,$GRAMMAR_PREFIX_Statement *,
                                         bool extractListFromBasicBlock = false);
     public:
       // DQ (3/20/2007): Fortran Program does not have this concept.
       // void hasEllipses();

HEADER_PROGRAM_HEADER_STATEMENT_END

HEADER_PROCEDURE_HEADER_STATEMENT_START

       // DQ (3/20/2007): These should be generated automatically from ROSETTA.
       // SgName get_name() const;
       // void set_name(SgName);
       // SgFunctionType* get_type () const;
       // void set_type ( SgFunctionType* type );
       // SgType* get_orig_return_type() const;
       // void set_parameterList ( SgFunctionParameterList* );

      /*! \brief Classification for different types of Fortran subprograms.
       */
          enum subprogram_kind_enum
             {
               e_unknown_kind,               /*!< error value */
               e_function_subprogram_kind,   /*!< Fortran function value */
               e_subroutine_subprogram_kind, /*!< Fortran subroutine value */
               e_block_data_subprogram_kind, /*!< Fortran data block value */
               e_last_subprogram_kind        /*!< last value (upper bound on range of values, used in error checking) */
             };

          SgName get_mangled_name() const;

       /* HEADER_LIST_DECLARATIONS */

       // $GRAMMAR_PREFIX_InitializedNamePtrList & get_args() ;
       // const $GRAMMAR_PREFIX_InitializedNamePtrList & get_args() const;

     protected:
       // DQ (3/20/2007): Unclear if we need this, it references p_definition, which does not appear to be defined!
       // virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false);

     public:
          bool isFunction()   const;
          bool isSubroutine() const;
          bool isBlockData()  const;

       // DQ (3/20/2007): Fortran does not have this concept (I think)
       // void hasEllipses();
HEADER_PROCEDURE_HEADER_STATEMENT_END

HEADER_ENTRY_STATEMENT_START

          SgName get_mangled_name() const;

HEADER_ENTRY_STATEMENT_END

HEADER_FORTRAN_DO_START
          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int) const;
          virtual unsigned int cfgFindChildIndex(SgNode* n);
          virtual unsigned int cfgFindNextChildIndex(SgNode* n);
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
          // Added for uniform support of mangled names, Liao, 3/11/2009
          virtual SgName get_mangled_name() const;
HEADER_FORTRAN_DO_END

HEADER_FORTRAN_NONBLOCKED_DO_START
HEADER_FORTRAN_NONBLOCKED_DO_END

HEADER_INTERFACE_STATEMENT_START

          enum generic_spec_enum
             {
               e_error_interface_type      = 0, /*!< error value */
               e_default_interface_type    = 1, /*!< default value */
               e_unnamed_interface_type    = 2, /*!< default value */
               e_named_interface_type      = 3, /*!< named interface value */
               e_operator_interface_type   = 4, /*!< operator value */
               e_assignment_interface_type = 5, /*!< assignement operator value */
               e_last_interface_type       = 6  /*!< last value (upper bound on range of values, used in error checking) */
             };

          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

          virtual SgName get_mangled_name() const;
HEADER_INTERFACE_STATEMENT_END

HEADER_PARAMETER_STATEMENT_START
HEADER_PARAMETER_STATEMENT_END

HEADER_COMMON_BLOCK_STATEMENT_START
          SgName get_mangled_name() const;
          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);


          const SgCommonBlockObjectPtrList & get_block_list() const;
          SgCommonBlockObjectPtrList & get_block_list();
HEADER_COMMON_BLOCK_STATEMENT_END

HEADER_MODULE_STATEMENT_START
          virtual SgName get_mangled_name() const;
          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

          std::vector<SgInterfaceStatement*> get_interfaces() const;

       // const SgDeclarationStatementPtrList & get_members() const;
       // SgDeclarationStatementPtrList & get_members();

  // protected:
       // virtual bool replace_child ( SgStatement *,SgStatement *, bool extractListFromBasicBlock = false );
       // virtual bool insert_child  ( SgStatement*, SgStatement*, bool inFront = true, bool extractListFromBasicBlock = false );

HEADER_MODULE_STATEMENT_END

HEADER_CONTAINS_STATEMENT_START
          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

          virtual SgName get_mangled_name() const;
HEADER_CONTAINS_STATEMENT_END

HEADER_USE_STATEMENT_START
          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

          virtual SgName get_mangled_name() const;
HEADER_USE_STATEMENT_END

HEADER_STOP_OR_PAUSE_STATEMENT_START
     public:
          enum stop_or_pause_enum
             {
               e_unknown,
               e_stop,
               e_pause
             };

          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

HEADER_STOP_OR_PAUSE_STATEMENT_END

HEADER_IO_STATEMENT_START
  // This is a base class for all the I/O statements: read, write, open, close, inquire
  // In addition it fully represents the statements: backspace, endfile, rewind

     public:
      //! Fortran specific classification
          enum io_statement_enum
             {
               e_unknown,
               e_read,
               e_print,
               e_write,
               e_open,
               e_close,
               e_inquire,
               e_backspace,
               e_endfile,
               e_rewind,
               e_last_io_statment_kind
             };

HEADER_IO_STATEMENT_END

HEADER_PRINT_STATEMENT_START
     virtual unsigned int cfgIndexForEnd() const;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
HEADER_PRINT_STATEMENT_END

HEADER_READ_STATEMENT_START
     virtual unsigned int cfgIndexForEnd() const;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
HEADER_READ_STATEMENT_END

HEADER_WRITE_STATEMENT_START
     virtual unsigned int cfgIndexForEnd() const;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
HEADER_WRITE_STATEMENT_END

HEADER_OPEN_STATEMENT_START
     virtual unsigned int cfgIndexForEnd() const;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
HEADER_OPEN_STATEMENT_END

HEADER_CLOSE_STATEMENT_START
     virtual unsigned int cfgIndexForEnd() const;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
HEADER_CLOSE_STATEMENT_END

HEADER_INQUIRE_STATEMENT_START
     virtual unsigned int cfgIndexForEnd() const;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
HEADER_INQUIRE_STATEMENT_END

HEADER_FLUSH_STATEMENT_START
     virtual unsigned int cfgIndexForEnd() const;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
HEADER_FLUSH_STATEMENT_END

HEADER_REWIND_STATEMENT_START
     virtual unsigned int cfgIndexForEnd() const;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
HEADER_REWIND_STATEMENT_END

HEADER_BACKSPACE_STATEMENT_START
     virtual unsigned int cfgIndexForEnd() const;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
HEADER_BACKSPACE_STATEMENT_END

HEADER_ENDFILE_STATEMENT_START
     virtual unsigned int cfgIndexForEnd() const;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
HEADER_ENDFILE_STATEMENT_END

HEADER_WAIT_STATEMENT_START
     virtual unsigned int cfgIndexForEnd() const;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
HEADER_WAIT_STATEMENT_END



HEADER_BLOCK_DATA_STATEMENT_START
HEADER_BLOCK_DATA_STATEMENT_END

HEADER_IMPLICIT_STATEMENT_START
     SgName get_mangled_name() const;
     virtual unsigned int cfgIndexForEnd() const;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

HEADER_IMPLICIT_STATEMENT_END

HEADER_STATEMENT_FUNCTION_STATEMENT_START
     SgName get_mangled_name() const;
HEADER_STATEMENT_FUNCTION_STATEMENT_END

HEADER_WHERE_STATEMENT_START
     virtual unsigned int cfgIndexForEnd() const;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

HEADER_WHERE_STATEMENT_END

HEADER_ELSE_WHERE_STATEMENT_START
     virtual unsigned int cfgIndexForEnd() const;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

HEADER_ELSE_WHERE_STATEMENT_END

HEADER_NULLIFY_STATEMENT_START
HEADER_NULLIFY_STATEMENT_END

HEADER_EQUIVALENCE_STATEMENT_START
     SgName get_mangled_name() const;
     virtual unsigned int cfgIndexForEnd() const;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

HEADER_EQUIVALENCE_STATEMENT_END

HEADER_DERIVED_TYPE_STATEMENT_START
     SgName get_mangled_name() const;
HEADER_DERIVED_TYPE_STATEMENT_END

HEADER_ATTRIBUTE_SPECIFICATION_STATEMENT_START
     virtual unsigned int cfgIndexForEnd() const;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

     public:
      //! Fortran specific classification of attribute statements (each corresponds to a declaration attribute).
          enum attribute_spec_enum
             {
               e_unknown_attribute_spec,
               e_accessStatement_private,
               e_accessStatement_public,
               e_allocatableStatement,
               e_asynchronousStatement,
               e_bindStatement,
               e_dataStatement,
               e_dimensionStatement,
               e_externalStatement,
               e_intentStatement,
               e_intrinsicStatement,
               e_optionalStatement,
               e_parameterStatement,
               e_pointerStatement,
               e_protectedStatement,
               e_saveStatement,
               e_targetStatement,
               e_valueStatement,
               e_volatileStatement,
               e_last_attribute_spec
             };

          virtual SgName get_mangled_name() const;

          const SgStringList & get_name_list() const;
          SgStringList & get_name_list();

      //! Support for Fortran data statement
          const SgDataStatementGroupPtrList & get_data_statement_group_list() const;
          SgDataStatementGroupPtrList & get_data_statement_group_list();

      //! Support for Fortran data statement
          const SgDimensionObjectPtrList & get_dimension_object_list() const;
          SgDimensionObjectPtrList & get_dimension_object_list();

       // DQ (12/9/2007): Added special support for this case.
          SgSymbol* search_for_symbol_from_symbol_table() const;

HEADER_ATTRIBUTE_SPECIFICATION_STATEMENT_END


HEADER_ALLOCATE_STATEMENT_START
HEADER_ALLOCATE_STATEMENT_END


HEADER_DEALLOCATE_STATEMENT_START
HEADER_DEALLOCATE_STATEMENT_END


HEADER_CONTAINS_STATEMENT_START
HEADER_CONTAINS_STATEMENT_END


HEADER_SEQUENCE_STATEMENT_START
HEADER_SEQUENCE_STATEMENT_END


HEADER_ARITHMETIC_IF_STATEMENT_START
          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

HEADER_ARITHMETIC_IF_STATEMENT_END


HEADER_ASSIGN_STATEMENT_START
HEADER_ASSIGN_STATEMENT_END


HEADER_COMPUTED_GOTO_STATEMENT_START

          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int) const;
          virtual unsigned int cfgFindChildIndex(SgNode* n);
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

#if 0
       // DQ (12/30/2007): This list is no longer requires since we ave build the IR node for a SgLabelRefExp
       // and we can hold this information using an more common ExprListExp instead.
          const SgLabelSymbolPtrList & get_labelList() const;
          SgLabelSymbolPtrList & get_labelList();
          void set_labelList(const SgLabelSymbolPtrList & labelList);
#endif

HEADER_COMPUTED_GOTO_STATEMENT_END


HEADER_ASSIGNED_GOTO_STATEMENT_START
HEADER_ASSIGNED_GOTO_STATEMENT_END


HEADER_NAMELIST_STATEMENT_START
          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

          virtual SgName get_mangled_name() const;

          const SgNameGroupPtrList & get_group_list() const;
          SgNameGroupPtrList & get_group_list();
HEADER_NAMELIST_STATEMENT_END


HEADER_IMPORT_STATEMENT_START
          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

          virtual SgName get_mangled_name() const;

          const SgExpressionPtrList & get_import_list() const;
          SgExpressionPtrList & get_import_list();
HEADER_IMPORT_STATEMENT_END


HEADER_ASSOCIATE_STATEMENT_START
          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

          virtual SgName get_mangled_name() const;
HEADER_ASSOCIATE_STATEMENT_END


HEADER_FORMAT_STATEMENT_START
          virtual unsigned int cfgIndexForEnd() const;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

          virtual SgName get_mangled_name() const;

       // const SgFormatItemPtrList & get_format_item_list() const;
       // SgFormatItemPtrList & get_format_item_list();
       // void set_format_item_list(const SgFormatItemPtrList & format_item_list);

HEADER_FORMAT_STATEMENT_END

HEADER_FORTRAN_INCLUDE_LINE_START
       // Not sure if we need these...
       // virtual unsigned int cfgIndexForEnd() const;
       // virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
       // virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

          virtual SgName get_mangled_name() const;
HEADER_FORTRAN_INCLUDE_LINE_END


HEADER_UPC_NOTIFY_STATEMENT_START
HEADER_UPC_NOTIFY_STATEMENT_END

HEADER_UPC_WAIT_STATEMENT_START
HEADER_UPC_WAIT_STATEMENT_END

HEADER_UPC_BARRIER_STATEMENT_START
HEADER_UPC_BARRIER_STATEMENT_END

HEADER_UPC_FENCE_STATEMENT_START
HEADER_UPC_FENCE_STATEMENT_END

HEADER_UPC_FORALL_STATEMENT_START
HEADER_LIST_DECLARATIONS
       // Liao, 6/17/2008 Copied from HEADER_FOR_STATEMENT_START
         SgStatementPtrList & get_init_stmt();
          const SgStatementPtrList & get_init_stmt() const;
       protected:
          virtual bool replace_child(SgStatement *,SgStatement *,
                                         bool extractListFromBasicBlock = false);
       public:

       // DQ (11/25/2005): Support for previous interface function.
          SgExpression*     get_test_expr () const                                 ROSE_DEPRECATED_FUNCTION;
          void              set_test_expr (SgExpression* expression )              ROSE_DEPRECATED_FUNCTION;

          int replace_expression(SgExpression * original_expression, SgExpression * new_expression );

          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int) const;
          virtual unsigned int cfgFindChildIndex(SgNode* n);
          virtual unsigned int cfgFindNextChildIndex(SgNode* n);
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

         // DQ (2/22/2007): Added for uniform support of mangled names
          virtual SgName get_mangled_name() const;

HEADER_UPC_FORALL_STATEMENT_END

HEADER_PREPROCESSOR_DIRECTIVE_STATEMENT_START

       // DQ (11/23/2008): I think this is defined in the base class so we can't redefine it here.
       // void post_construction_initialization();

          static SgC_PreprocessorDirectiveStatement* createDirective ( PreprocessingInfo* currentPreprocessingInfo );

       // DQ (11/29/2008): Added for uniform support of mangled names
          virtual SgName get_mangled_name() const;

HEADER_PREPROCESSOR_DIRECTIVE_STATEMENT_END

HEADER_LINEMARKER_PREPROCESSOR_DIRECTIVE_STATEMENT_START

HEADER_LINEMARKER_PREPROCESSOR_DIRECTIVE_STATEMENT_END


// #########################################################
// #########################################################
//                      SOURCE CODE
// #########################################################
// #########################################################


SOURCE_MAIN_STATEMENT_START

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgStatement::get_symbol_from_symbol_table() const
   {
     printf ("Error: virtual function SgStatement::get_symbol_from_symbol_table() called on base class SgStatement = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);
	// tps (12/9/2009) : MSC requires a return value
     return NULL;
   }

void
SgStatement::remove_statement(SgStatement *target)
   {
     bool r = replace_child(target, 0);
     assert(r);
   }

void
SgStatement::insert_statement(SgStatement* target, SgStatement* newstmt, bool inFront)
   {
     bool r = insert_child( target, newstmt, inFront, false);
     assert(r);
   }

void
SgStatement::insert_statement(SgStatement* target, const SgStatementPtrList& newstmtList, bool inFront)
   {  
     SgBasicBlock* tmp = new SgBasicBlock();
     tmp->get_statements() = newstmtList;
     bool r = insert_child( target, tmp, inFront, true);
     assert(r);
   }

void
SgStatement::replace_statement(SgStatement* target, SgStatement* newstmt)
   {
  // DQ (6/24/2006): Allow structurally oriented operations to set the parent (now that we store the scope explicitly this is OK).
     ROSE_ASSERT(newstmt != NULL);
     ROSE_ASSERT(target != NULL);
     ROSE_ASSERT(target->get_parent() != NULL);
  // ROSE_ASSERT(target->get_parent() != newstmt);
     if (newstmt->get_parent() == NULL)
          newstmt->set_parent(target->get_parent());

     bool r = replace_child(target, newstmt, false);
     assert(r);
   }

void
SgStatement::replace_statement(SgStatement* target, const SgStatementPtrList& newstmtList)
   {
     SgBasicBlock* tmp = new SgBasicBlock();
     tmp->get_statements() = newstmtList;
     bool r = replace_child( target, tmp, true);
     assert(r);
   }

 // if newstmt is a basicBlock, statements inside newstmt are extracted and then inserted
void
SgStatement::insert_statement_from_basicBlock(SgStatement* target, SgStatement* newstmt, bool inFront)
   {
     bool r = insert_child( target, newstmt, inFront, true);
     assert(r);
   }

void
SgStatement::replace_statement_from_basicBlock(SgStatement* target, SgStatement* newstmt)
   {
     bool r = replace_child( target, newstmt, true);
     assert(r);
   }

void
SgStatement::post_construction_initialization()
   {
   }

// DQ (12/5/2004): Support for setting scopes (only meaningful on IR statements that store the scope explicitly)
void
SgStatement::set_scope ( SgScopeStatement* newScope )
   {
     ROSE_ASSERT(this != NULL);
     printf ("Warning: It is meaningless to set the scope in this %s IR node, the scope is not explicitly stored on this IR node! \n",class_name().c_str());
     ROSE_ASSERT(false);
   }

bool
SgStatement::hasExplicitScope() const
   {
  // This function reports that this IR node (by default) does NOT store its scope explicitly.

     return false;
   }

void
SgStatement::setExtern()
   {
     ROSE_ASSERT(this != NULL);
     printf ("Error: SgStatement::setExtern() is deprecated (it is now an error to call this) \n");
     ROSE_ASSERT(false);
   }

void
SgStatement::setStatic()
   {
     ROSE_ASSERT(this != NULL);
     printf ("Error: SgStatement::setStatic() is deprecated (it is now an error to call this) \n");
     ROSE_ASSERT(false);
   }

#if 0
void
SgStatement::set_pragma()
   {
  // if(found_pragma_cnt)
  //    {
  //      add_pragma(found_pragma_cnt,found_pragma_list);
  //      found_pragma_cnt=0;
  //    }
   }
#endif

bool 
SgStatement::replace_child(SgStatement *target,SgStatement *newstmt, bool extractListFromBasicBlock)
   {
     printf ("$CLASSNAME::replace_child(): ERROR: virtual function called in base class by mistake in %s (exiting at ...) \n",sage_class_name());
     ROSE_ASSERT(newstmt->get_file_info() != NULL);
     newstmt->get_file_info()->display("called from $CLASSNAME::insert_child()");
     ROSE_ABORT();

     return false;
   }
 
bool
SgStatement::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractListFromBasicBlock)
   {
     printf ("$CLASSNAME::insert_child(): ERROR: virtual function called in base class by mistake in %s (exiting at ...) \n",sage_class_name());
     ROSE_ASSERT(newstmt->get_file_info() != NULL);
     newstmt->get_file_info()->display("called from $CLASSNAME::insert_child()");
     ROSE_ABORT();

     return false;
   }


// DQ (12/6/2006): We need this sort of function now that we have removed the expression root node!
// The requirement of not being able to do operations uniformly on expressions may be the disadvantage
// of not having used the SgExpressionRoot IR node as a concept.
int
SgStatement::replace_expression(SgExpression * original_expression, SgExpression * new_expression )
   {
     printf ("Error: base class of virtual SgStatement::replace_expression called by mistake for statement: %s \n",class_name().c_str());
     ROSE_ASSERT(false);
     return 0;
   }

SgScopeStatement*
SgStatement::get_scope(void) const
   {
     ROSE_ASSERT(this != NULL);

  // This is a function called after the parents have been set.  It is not called by the
  // EDG/SAGE interface and is only called after the SAGE AST has been built and the parent
  // pointers set within a separate phase.

  // Important exception: The SgFunctionParameterList should have as it's scope the
  // SgFunctionDefinition, but it is a sibling of the SgFunctionDefinition (both the
  // SgFunctionParameterList and the SgFunctionDefinition have the SgFunctionDeclaration
  // as a parent.  Thus the scope of the SgFunctionParameterList is computed to be the 
  // SgGlobal (global scope) most often; which is an error).  So we handle this case 
  // explicitly.

     SgStatement *stmt = const_cast<SgStatement*>(this);
     ROSE_ASSERT (stmt != NULL);

  // Make sure that parents have been set already (assume this means that all parents have been set)
     if (get_parent() == NULL)
        {
       // printf ("Error: found IR node where parent was not set = %p = %s \n",this,sage_class_name());
          printf ("Note: found IR node where parent was not set = %p = %s (may not be required) \n",this,sage_class_name());
          ROSE_ASSERT(get_file_info() != NULL);
          get_file_info()->display("Location of problematic IR node");
        }
  // ROSE_ASSERT (get_parent() != NULL);

#if 0
     printf ("In SgStatement::get_scope(): this = %s \n",class_name().c_str());
#endif

     SgScopeStatement *returnScope = NULL;
     switch (variantT())
        {
       // DQ (11/7/03) : If we are a SgGlobal then return NULL (is this the best return value???)
       // DQ (11/25/03): If we are a SgGlobal then return "this" (I think it's more useful)
       // So the scope of global scope is now the global scope (hope this does not cause
       // any loops to never terminate!).

          case V_SgGlobal:
             {
            // returnScope = NULL;
               returnScope = isSgScopeStatement(stmt);
               ROSE_ASSERT (returnScope != NULL);
               break;
             }

       // DQ (9/24/2005): This should be handled the same as SgFunctionParameterList
          case V_SgCtorInitializerList:

       // DQ (11/21/2003): Handle special case of SgFunctionParameterList (attached to the 
       //                  SgFunctionDeclaration instead of the SgFunctionDefinition)
          case V_SgFunctionParameterList:
             {
            // Handle case of SgFunctionDeclaration or SgMemberFunctionDeclaration
               ROSE_ASSERT (stmt->get_parent() != NULL);
               SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(stmt->get_parent());
               ROSE_ASSERT (functionDeclaration != NULL);
#if 0
               SgFunctionDefinition* functionDefinition = functionDeclaration->get_definition();
               if (functionDefinition != NULL)
                  {
                    returnScope = functionDefinition;
                  }
                 else
                  {
                 // scope of a SgFunctionParameterList in a forward function declaration 
                 // (without a pointer to a SgFunctionDefinition)
                 // returnScope = NULL;

                 // DQ (11/27/2003): Force SgFunctionParameterList case to use scope of function
                 //                  declaration (most often global scope of class definition scope).
                    returnScope = functionDeclaration->get_scope();
                  }
#else
            // DQ (2/12/2006): provide a consistent definition of the scope for SgFunctionParameterList
            // instead of a definition that depends on if it is a defining or non-defining declaration.
               returnScope = functionDeclaration->get_scope();
#endif
               ROSE_ASSERT (returnScope != NULL);
               break;
             }
#if 0
       // DQ (2/19/2006): If commented out test2004_78.C fails, if left in place then test2004_71.C fails.
       // I have concluded from this that the SgNamespaceDeclarationStatement shold have an explicitly 
       // stored scope.
       // DQ (2/10/2006): Added case that is a current problem in test2005_08.C
       // There can be many instances of a single name space but get_scope()
       // should return the scope of the first instance of each namespace.
          case V_SgNamespaceDeclarationStatement:
             {
            // Handle case of SgNamespaceDeclarationStatement
               ROSE_ASSERT (stmt != NULL);
               SgNamespaceDeclarationStatement* namespaceDeclaration = isSgNamespaceDeclarationStatement(stmt);
               ROSE_ASSERT (namespaceDeclaration != NULL);
            // printf ("namespaceDeclaration->get_firstNondefiningDeclaration() = %p namespaceDeclaration->get_definingDeclaration() = %p \n",
            //      namespaceDeclaration->get_firstNondefiningDeclaration(),namespaceDeclaration->get_definingDeclaration());
            // SgDeclarationStatement* firstDeclaration = namespaceDeclaration->get_definingDeclaration();
               SgDeclarationStatement* firstDeclaration = namespaceDeclaration->get_firstNondefiningDeclaration();
               ROSE_ASSERT(firstDeclaration != NULL);
               SgNamespaceDeclarationStatement* firstNamespaceDeclaration = isSgNamespaceDeclarationStatement(firstDeclaration);
               ROSE_ASSERT(firstNamespaceDeclaration != NULL);
               ROSE_ASSERT(firstNamespaceDeclaration->get_parent() != NULL);
               SgStatement* parentStatement = isSgStatement(firstNamespaceDeclaration->get_parent());
               ROSE_ASSERT(parentStatement != NULL);

               returnScope = parentStatement->get_scope();

               ROSE_ASSERT (returnScope != NULL);
               break;
             }
#endif
#if 0
       // DQ (2/9/2006): Added case that is a current problem in test2004_02.C
       // This is not needed now that we have set the parent directly (hope that works!)
          case V_SgBasicBlock:
             {
            // Handle case of SgBasicBlock
               ROSE_ASSERT (stmt != NULL);
               SgBasicBlock* block = isSgBasicBlock(stmt);

            // This fails
               printf ("SgBasicBlock = %p \n",stmt);
               ROSE_ASSERT (stmt->get_parent() != NULL);

               ROSE_ASSERT (returnScope != NULL);
               break;
             }
#endif
       // DQ (11/7/03): If we are a ScopeStatment then reset the starting point for the search
       //               for the scopeStatement to the parent of the current node.
          default:
             {
               ROSE_ASSERT(stmt != NULL);
#if 0
               printf ("In SgScopeStatement::get_scope() default case: stmt = %s \n",stmt->sage_class_name());
               ROSE_ASSERT(stmt->get_parent() != NULL);
               printf ("In SgScopeStatement::get_scope() default case: stmt->get_parent() = %s \n",stmt->get_parent()->sage_class_name());
#endif

#if 0
            // DQ (11/3/2007): Put old code back in as part of debugging case of calling get_scope from a SgClassDefinition.
            // However this code does not appear to be relevant.  We just need an additional detail to the code below!
               if (isSgScopeStatement(stmt) != NULL)
                  {
                    if (stmt->get_parent() == NULL)
                       {
                         printf ("Error: SgStatement has NULL parent at node = %p = %s \n",stmt,stmt->class_name().c_str());
                         stmt->get_file_info()->display("Error: SgStatement has NULL parent");
                       }
                    ROSE_ASSERT(stmt->get_parent() != NULL);
                    stmt = isSgStatement(stmt->get_parent());
                  }
#else
            // DQ (11/3/2007): Added comment to existing code. If the input node is a scope then move up one using 
            // the parent (since scopes are not explicitly stored in SgScopeStatement objects).
               if (isSgScopeStatement(stmt) != NULL)
                  {
                    if (stmt->get_parent() == NULL)
                       {
                         printf ("Error: SgStatement has NULL parent at node = %p = %s \n",stmt,stmt->class_name().c_str());
                         stmt->get_file_info()->display("Error: SgStatement has NULL parent");
                       }
                    ROSE_ASSERT(stmt->get_parent() != NULL);
                 // JJW (10/10/2007) -- the non-NULL parent of a statement may not be a statement in the case of a statement
                 // expression (test case is tests/CompileTests/Cxx_tests/test2006_148.C), so we need to skip over non-statements
                    SgNode* stmtTemp = stmt;
                    do {
                      // printf ("In SgStatement::get_scope(): (do-while loop) stmtTemp = %p = %s \n",stmtTemp,stmtTemp->class_name().c_str());
                         stmtTemp = stmtTemp->get_parent();
                       }
                    while (stmtTemp && !isSgStatement(stmtTemp));
                    ROSE_ASSERT (stmtTemp);
                    stmt = isSgStatement(stmtTemp);

                 // DQ (11/3/2007): Here is the fix for the case of calling the get_scope from a class definition.
                 // Because the definition of a class could be in an alternative location (structurally) from its 
                 // initial declaration, we have to be careful if the parent of the initial input node to this function 
                 // is a declaration which has an explicitly stored scope (since we will just use the parents and not 
                 // the explicitly stored scope in the code below.  The fix is to check if the value of "stmt" is a 
                 // declaration with an explicitly stored scope (and if so use that value). Note that we can only
                 // return the explicitly stored scope, else we have to use parents to track backwards up the tree.
                 // This problem is demonstrated by test2005_153.C and test2005_172.C (smaller test code).
                    if (stmt->hasExplicitScope() == true)
                       {
                         ROSE_ASSERT(isSgScopeStatement(stmt) == NULL);
                         return stmt->get_scope();
                       }
                  }
#endif
               ROSE_ASSERT(stmt != NULL);

               int counter = 0;
               while(stmt && !(returnScope = isSgScopeStatement(stmt)))
                  {
#if 0
                    printf ("stmt->sage_class_name() = %s \n",stmt->sage_class_name());
#endif
                    if (stmt->get_parent() == NULL)
                       {
                         printf ("Error: NULL parent pointer not allowed for statement = %p = %s = %s \n",stmt,stmt->class_name().c_str(),SageInterface::get_name(stmt).c_str());
                         ROSE_ASSERT(stmt->get_file_info() != NULL);
                         stmt->get_file_info()->display("Error: NULL parent pointer not allowed for statement");
                       }
                    ROSE_ASSERT (stmt->get_parent() != NULL);
#if 0
                    printf ("stmt->get_parent()->sage_class_name() = %s \n",stmt->get_parent()->sage_class_name());
#endif

                 // stmt = isSgStatement(stmt->get_parent());
                    SgInitializedName* initializedName = isSgInitializedName(stmt->get_parent());
                    if (initializedName != NULL)
                       {
#if 0
                         printf ("Get the stmt pointer from the initializedName->get_parent() = %p = %s \n",initializedName->get_parent(),initializedName->get_parent()->class_name().c_str());
#endif
                      // DQ (12/16/2007): Added error handling (reporting)
                         if (isSgStatement(initializedName->get_parent()) == NULL)
                            {
                              printf ("Error: isSgStatement(initializedName->get_parent()) == NULL (initializedName = %p = %s) \n",initializedName,initializedName->get_name().str());
                            }
                         ROSE_ASSERT(initializedName->get_parent() != NULL);
                         stmt = isSgStatement(initializedName->get_parent());
                         ROSE_ASSERT(stmt != NULL);
                       }
                      else
                       {
                      // DQ (12/16/2007): Added error handling (reporting)
                         if (isSgStatement(stmt->get_parent()) == NULL)
                            {
                              printf ("Error: isSgStatement(stmt ->get_parent()) == NULL (statement = %p = %s) (numeric_label = %p) \n",stmt,stmt->class_name().c_str(),stmt->get_numeric_label());
                            }
                         ROSE_ASSERT(stmt->get_parent() != NULL);
                         stmt = isSgStatement(stmt->get_parent());
                         ROSE_ASSERT(stmt != NULL);
                       }
                    ROSE_ASSERT(stmt != NULL);

                 // DQ (9/23/2004): Avoid infinite loops, break out (abort) after some reasonable scope depth!
                    counter++;
                    if (counter > 1000)
                       {
                         printf ("Error max nesting depth exceeded, this is likely an error of some sort for a %s \n",sage_class_name());
                         printf ("\"this\" IR node %p = %s \n",this,sage_class_name());
                         get_file_info()->display("Error max nesting depth exceeded");
                         printf ("         stmt is %p = %s \n",stmt,stmt->sage_class_name());
                         stmt->get_file_info()->display("Error max nesting depth exceeded");
                         printf ("    has a parent %p = %s \n",stmt->get_parent(),stmt->get_parent()->sage_class_name());
                         ROSE_ASSERT(false);
                       }
                  }
               break;
             }
        }

  // DQ (11/25/2003): I think we can now assert this to be true!
  // DQ (11/27/2003): SgFunctionParameterList in a function prototype will cause 
  //                  returnScope == NULL.  So we can't assert this.
  // DQ (11/27/2003): Force SgFunctionParameterList case to use scope of the 
  //                  function declaration
     ROSE_ASSERT (returnScope != NULL);

  // Error checking!
     SgTemplateInstantiationDefn* defn = isSgTemplateInstantiationDefn(returnScope);
     if (defn != NULL)
        {
          SgTemplateInstantiationDecl * decl = isSgTemplateInstantiationDecl(defn->get_declaration());
          ROSE_ASSERT(decl != NULL);
          if (decl->get_nameResetFromMangledForm() == false)
             {
#if PRINT_DEVELOPER_WARNINGS
               printf ("In get_scope(): Found template definition containing template declaration (%s) with nameResetFromMangledForm == false \n",decl->get_name().str());
#endif
#if 0
            // Uncomment this to find out where this construct is located in teh source code
               decl->get_file_info()->display("In $CLASSNAME::get_scope(): debug");
#endif
             }
        }


#if 0
     printf ("In $CLASSNAME::get_scope(): returnScope->sage_class_name() = %s \n",returnScope->sage_class_name());
#endif

     return returnScope;
   }

// DQ (12/16/2007): Added virtual function so that we could set the end_numeric_label on all relevant Fortran constructs
// void SgStatement::set_end_numeric_label(SgLabelSymbol* end_numeric_label)
void
SgStatement::set_end_numeric_label(SgLabelRefExp* end_numeric_label)
   {
     printf ("Error: base class implementation SgStatement::set_end_numeric_label(%p) should not be called \n",end_numeric_label);
     ROSE_ASSERT(false);
   }


// Report if a construct has a concept of end_numeric_label
bool
SgStatement::has_end_numeric_label() const
   {
     bool returnValue = false;

     switch(variantT())
        {
       // List of statements that contain an end_numeric_label concept
          case V_SgIfStmt:
          case V_SgWhileStmt:
          case V_SgSwitchStatement:
          case V_SgProgramHeaderStatement:
          case V_SgProcedureHeaderStatement:
          case V_SgInterfaceStatement:
          case V_SgModuleStatement:
          case V_SgFortranDo:
          case V_SgWhereStatement:
          case V_SgDerivedTypeStatement:
             {
               returnValue = true;
               break;
             }

          default:
             {
            // Nothing to do here
             }
        }

     return returnValue;
   }

SOURCE_MAIN_STATEMENT_END


SOURCE_X_STATEMENT_START
void
$CLASSNAME::post_construction_initialization()
   {
   }

SOURCE_X_STATEMENT_END


SOURCE_X_STATEMENT_UNKNOWN_START
void
$CLASSNAME::post_construction_initialization()
   {
   }

SOURCE_X_STATEMENT_UNKNOWN_END


SOURCE_NON_X_STATEMENT_START
void
$CLASSNAME::post_construction_initialization()
   {
   }

SOURCE_NON_X_STATEMENT_END


SOURCE_SCOPE_STATEMENT_START


// DQ (6/14/2007): Added to support simpler handling of general scopes (used in EDG/Sage translation).
void
SgScopeStatement::prepend_statement ( SgStatement* stmt )
   {
  // Higher level function to handle statements and declarations is scopes.

     ROSE_ASSERT(stmt != NULL);
     if (containsOnlyDeclarations() == true)
        {
          SgDeclarationStatement* declaration = isSgDeclarationStatement(stmt);
          if (declaration == NULL)
             {
               printf ("Error: SgScopeStatement::append in a scope such as %s must provide a SgDeclarationStatement = %s \n",class_name().c_str(),stmt->class_name().c_str());
             }
          ROSE_ASSERT(declaration != NULL);

       // Access the STL list directly
          getDeclarationList().insert(getDeclarationList().begin(),declaration);

       // Set the parent (to have uniform semantics as with the other insert functions defined in SgStatement.
          declaration->set_parent(this);
          ROSE_ASSERT(declaration->get_parent() != NULL);
        }
       else
        {
       // Access the STL list directly
          getStatementList().insert(getStatementList().begin(),stmt);

       // Set the parent (to have uniform semantics as with the other insert functions defined in SgStatement.
          stmt->set_parent(this);
          ROSE_ASSERT(stmt->get_parent() != NULL);
        }
   }

// DQ (6/14/2007): Added to support simpler handling of general scopes (used in EDG/Sage translation).
void
SgScopeStatement::append_statement ( SgStatement* stmt )
   {
  // Higher level function to handle statements and declarations is scopes.

     ROSE_ASSERT(stmt != NULL);
     if (containsOnlyDeclarations() == true)
        {
          SgDeclarationStatement* declaration = isSgDeclarationStatement(stmt);
          if (declaration == NULL)
             {
               printf ("Error: SgScopeStatement::append in a scope such as %s must provide a SgDeclarationStatement = %s \n",class_name().c_str(),stmt->class_name().c_str());
             }
          ROSE_ASSERT(declaration != NULL);

       // Access the STL list directly
          getDeclarationList().insert(getDeclarationList().end(),declaration);

       // Set the parent (to have uniform semantics as with the other insert functions defined in SgStatement.
          declaration->set_parent(this);
          ROSE_ASSERT(declaration->get_parent() != NULL);
        }
       else
        {
       // Access the STL list directly
          getStatementList().insert(getStatementList().end(),stmt);

       // Set the parent (to have uniform semantics as with the other insert functions defined in SgStatement.
          stmt->set_parent(this);
          ROSE_ASSERT(stmt->get_parent() != NULL);
        }
   }

// DQ (6/5/2007): Build special operator to return by reference
std::set<SgSymbol*> &
SgScopeStatement::get_type_elaboration_list ()
   {
     assert (this != NULL);
     return p_type_elaboration_list;
   }

void
SgScopeStatement::set_type_elaboration_list ( const std::set<SgSymbol*> & type_elaboration_list )
   {
     assert (this != NULL);
     set_isModified(true);
     p_type_elaboration_list = type_elaboration_list;
   }

// DQ (6/5/2007): Build special operator to return by reference
std::set<SgSymbol*> &
SgScopeStatement::get_hidden_type_list ()
   {
     assert (this != NULL);
     return p_hidden_type_list;
   }

void
SgScopeStatement::set_hidden_type_list ( const std::set<SgSymbol*> & hidden_type_list )
   {
     assert (this != NULL);
     set_isModified(true);
     p_hidden_type_list = hidden_type_list;
   }

// DQ (6/5/2007): Build special operator to return by reference
std::set<SgSymbol*> &
SgScopeStatement::get_hidden_declaration_list ()
   {
     assert (this != NULL);
     return p_hidden_declaration_list;
   }

void
SgScopeStatement::set_hidden_declaration_list ( const std::set<SgSymbol*> & hidden_declaration_list )
   {
     assert (this != NULL);
     set_isModified(true);
     p_hidden_declaration_list = hidden_declaration_list;
   }


std::ostream & operator<< ( std::ostream & os, const std::set<SgSymbol*> & l )
   {
     os << "output operator for std::set<SgSymbol*> not implemented";
     return os;
   }

SgScopeStatement::SgScopeStatement ( Sg_File_Info* file_info )
   : $BASECLASS(file_info)
   {
  // Make the global scope hash multimap larger since it typically supports more symbols.
  // Use a prime number (better!)
     if (variantT() == V_SgGlobal || variantT() == V_SgNamespaceDefinitionStatement)
        {
          p_symbol_table = new SgSymbolTable(101);
        }
       else
        {
          if (variantT() == V_SgClassDefinition || variantT() == V_SgTemplateInstantiationDefn)
             {
               p_symbol_table = new SgSymbolTable(51);
             }
            else
             {
            // Use the default size of hash_multimap
               p_symbol_table = new SgSymbolTable();
             }
        }

     ROSE_ASSERT(p_symbol_table != NULL);

  // DQ (2/16/2006): Set this parent directly (now tested)
     p_symbol_table->set_parent(this);

  // DQ (7/23/2010): Build the local type table.
     p_type_table = new SgTypeTable();
     p_type_table->set_parent(this);
   }

void
SgScopeStatement::post_construction_initialization()
   {
   }

// DQ (9/8/2004): Added to support qualified name generation
// RV (1/31/2006): Modified to return a fully qualified name by recursion.
SgName
SgScopeStatement::get_qualified_name() const
   {
  // Compute name of this scope -- by default, an unnamed (or empty) string.
     SgName local_qual_name;

  // Compute parent scope's qualified name
     SgName par_qual_name;
     const SgScopeStatement* parent_scope = get_scope();
     if (parent_scope)
          par_qual_name = parent_scope->get_qualified_name();

     return SgName::assembleQualifiedName (par_qual_name, local_qual_name);
   }

SgName
SgScopeStatement::get_mangled_name(void) const
   {
     printf ("Error: this is a virtual function call on a base class implementation! scope = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);

     return SgName ("__error__");
   }

size_t
SgScopeStatement::count_symbol(const SgName& n)
   {
  // DQ (2/10/2007): Added function to count entries in symbol table with same name!
  // This can be more than 1, e.g. "typedef struct X{} X;"
     assert (p_symbol_table != NULL);
     return p_symbol_table->count(n);
   }

// DQ (2/10/2007): Added test function for existence of symbols
bool
SgScopeStatement::symbol_exists ( const SgName & nm , SgSymbol *sp ) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->exists(nm,sp);
   }

// DQ (2/10/2007): Added test function for existence of symbols
bool
SgScopeStatement::symbol_exists ( const SgName & nm ) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->exists(nm);
   }

// DQ (2/10/2007): Added test function for existence of symbols
bool
SgScopeStatement::symbol_exists ( const SgSymbol *sp ) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->exists(sp);
   }


void
SgScopeStatement::insert_symbol ( const SgName& n, SgSymbol* s )
   {
     assert (p_symbol_table != NULL);

#if 0
     ROSE_ASSERT(s != NULL);
     SgNode* symbolBasis = s->get_symbol_basis();
  // printf ("In SgScopeStatement::insert_symbol(%s,%p) into scope = %p = %s parent = %p = %s symbol = %p = %s s->get_symbol_basis() = %p = %s \n",
     printf ("In SgScopeStatement::insert_symbol(%s,%p) into scope = %p = %s symbol = %p = %s s->get_symbol_basis() = %p = %s \n",
          n.str(),s,
          this,this->class_name().c_str(),
       // this->get_parent(),this->get_parent()->class_name().c_str(),
          s,s->class_name().c_str(),
          symbolBasis,symbolBasis != NULL ? symbolBasis->class_name().c_str() : "NULL");
#endif

  // Make sure that this specific symbol and name combination don't already exist in the AST.
     bool symbolAlreadyPresentLookupName = p_symbol_table->exists(n,s);
     if (symbolAlreadyPresentLookupName == true)
        {
          printf ("Error in insert_symbol(n=%s,s=%p): (exists(n,s) == true) symbol = %p = %s = %s already present in symbol table = %p in scope = %p = %s \n",
               n.str(),s,s,s->class_name().c_str(),SageInterface::get_name(s).c_str(),p_symbol_table,this,this->class_name().c_str());
          printf ("     s->get_symbol_basis() = %p = %s \n",s->get_symbol_basis(),s->get_symbol_basis()->class_name().c_str());
          s->get_symbol_basis()->get_file_info()->display("Error in insert_symbol(n,s)");
        }
     ROSE_ASSERT(symbolAlreadyPresentLookupName == false);

#if SYMBOL_TABLE_ERROR_CHECKING
  // Also test the symbol directly (this is an expensive test, linear in complexity)
  // We don't want to do this except for testing!
     bool symbolAlreadyPresent = p_symbol_table->exists(s);
     if (symbolAlreadyPresent == true)
        {
          printf ("Error: (exists(s) == true) symbol = %p = %s = %s already present in symbol table = %p in scope = %p = %s \n",
               s,s->class_name().c_str(),SageInterface::get_name(s).c_str(),p_symbol_table,this,this->class_name().c_str());
        }
     ROSE_ASSERT(symbolAlreadyPresent == false);
#endif

     p_symbol_table->insert(n,s);
   }

void
SgScopeStatement::remove_symbol ( SgSymbol* s )
   {
     assert (p_symbol_table != NULL);

#if SYMBOL_TABLE_ERROR_CHECKING
  // Make sure that the symbol exists before we try to remove it
     ROSE_ASSERT(p_symbol_table->exists(s) == true);
#endif

     p_symbol_table->remove(s);
   }

  // see if this is in symbol table already
int
SgScopeStatement::lookup_symbol(const SgName& n, SgSymbol *s) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find(n,s);
   }

  // first symbol with n
SgSymbol*
$CLASSNAME::lookup_symbol(const SgName& n) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_any(n);
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgTypedefSymbol*
SgScopeStatement::lookup_typedef_symbol(const SgName& n) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_typedef(n);
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgEnumSymbol*
SgScopeStatement::lookup_enum_symbol(const SgName& n) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_enum(n);
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgEnumFieldSymbol*
SgScopeStatement::lookup_enum_field_symbol(const SgName& n) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_enum_field(n);
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgVariableSymbol*
SgScopeStatement::lookup_var_symbol(const SgName& n) const
   {
  // DQ (2/4/2007): This function is part of an older interface which is deprecated.
     return lookup_variable_symbol(n);
   }
SgVariableSymbol*
SgScopeStatement::lookup_variable_symbol(const SgName& n) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_variable(n);
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgClassSymbol*
SgScopeStatement::lookup_class_symbol(const SgName& n) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_class(n);
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgLabelSymbol*
SgScopeStatement::lookup_label_symbol(const SgName& n) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_label(n);
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgFunctionSymbol*
SgScopeStatement::lookup_function_symbol(const SgName& n, const SgType* t) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_function(n,t);
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgFunctionSymbol*
SgScopeStatement::lookup_function_symbol(const SgName& n) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_function(n);
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgNamespaceSymbol*
SgScopeStatement::lookup_namespace_symbol ( const SgName & n ) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_namespace(n);
   }


SgTemplateSymbol*
SgScopeStatement::lookup_template_symbol(const SgName& n) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_template(n);
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgSymbol*
SgScopeStatement::first_any_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_any();
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgVariableSymbol*
SgScopeStatement::first_variable_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_variable();
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgClassSymbol*
SgScopeStatement::first_class_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_class();
   }
// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgFunctionSymbol*
SgScopeStatement::first_function_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_function();
   }

// DQ (2/1/2007): Added to ROSE to make the interface consistent.
SgTypedefSymbol*
SgScopeStatement::first_typedef_symbol() const
   {
     ROSE_ASSERT (p_symbol_table != NULL);
     return p_symbol_table->find_typedef();
   }

// DQ (2/1/2007): Added to ROSE to make the interface consistent.
SgEnumSymbol*
SgScopeStatement::first_enum_symbol() const
   {
     ROSE_ASSERT (p_symbol_table != NULL);
     return p_symbol_table->find_enum();
   }

// DQ (2/1/2007): Added to ROSE to make the interface consistent.
SgEnumFieldSymbol*
SgScopeStatement::first_enum_field_symbol() const
   {
     ROSE_ASSERT (p_symbol_table != NULL);
     return p_symbol_table->find_enum_field();
   }

// DQ (2/1/2007): Added to ROSE to make the interface consistent.
SgLabelSymbol*
SgScopeStatement::first_label_symbol() const
   {
     ROSE_ASSERT (p_symbol_table != NULL);
     return p_symbol_table->find_label();
   }

// DQ (2/1/2007): Added to ROSE to make the interface consistent.
SgNamespaceSymbol*
SgScopeStatement::first_namespace_symbol() const
   {
     ROSE_ASSERT (p_symbol_table != NULL);
     return p_symbol_table->find_namespace();
   }

// DQ (2/4/2007): Added to ROSE to make the interface consistent.
SgTemplateSymbol*
SgScopeStatement::first_template_symbol() const
   {
     ROSE_ASSERT (p_symbol_table != NULL);
     return p_symbol_table->find_template();
   }
















// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgSymbol*
SgScopeStatement::next_any_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_any();
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgVariableSymbol*
SgScopeStatement::next_variable_symbol() const
   {
  // use this function after lookup_XXX_symbol(const SgName&) or after first_XXX_symbol()
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_variable();
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgClassSymbol*
SgScopeStatement::next_class_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_class();
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgFunctionSymbol*
SgScopeStatement::next_function_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_function();
   }

// DQ (2/1/2007): Added new member function to ROSE.
SgTypedefSymbol*
SgScopeStatement::next_typedef_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_typedef();
   }

// DQ (2/1/2007): Added new member function to ROSE.
SgEnumSymbol*
SgScopeStatement::next_enum_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_enum();
   }

// DQ (2/1/2007): Added new member function to ROSE.
SgEnumFieldSymbol*
SgScopeStatement::next_enum_field_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_enum_field();
   }

// DQ (2/1/2007): Added new member function to ROSE.
SgLabelSymbol*
SgScopeStatement::next_label_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_label();
   }

// DQ (2/1/2007): Added new member function to ROSE.
SgNamespaceSymbol*
SgScopeStatement::next_namespace_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_namespace();
   }

// DQ (2/4/2007): Added new member function to ROSE.
SgTemplateSymbol*
SgScopeStatement::next_template_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_template();
   }




void
SgScopeStatement::print_symboltable( const std::string& str, ostream& os ) 
   {
     os << endl << "...SymTbl(" << str << ")... " << endl;
  // printf ("ERROR: not supported in SAGE 3 \n");
  // abort();
  // p_symbol_table->print(os);
     ROSE_ASSERT (p_symbol_table != NULL);
     p_symbol_table->print("Called from $CLASSNAME::print_symboltable");
   }

#if 0
// Not implemented in SAGE3 yet!

/* additional symbol table insertion utitily routines */

SgVariableSymbol *insert_symbol(const SgInitializedNamePtrList::iterator&);
SgVariableSymbol *insert_symbol(SgVariableDeclaration *);
SgFunctionSymbol *insert_symbol(SgFunctionDeclaration *);
SgMemberFunctionSymbol *insert_symbol(SgMemberFunctionDeclaration *);
SgClassSymbol *insert_symbol(SgClassDeclaration *cdecl);
SgEnumSymbol *insert_symbol(SgEnumDeclaration *cdecl);
SgTypedefSymbol *insert_symbol(SgTypedefDeclaration *);
SgLabelSymbol *insert_symbol(SgLabelStatement *);
SgEnumFieldSymbol *insert_enum_symbol(const SgInitializedNamePtrList::iterator&);
#endif

// DQ (7/17/2002) Added to support rewrite mechanism some scopes can only contain
// SgDeclarationStmt while others can contain any kind of SgStatement
bool
SgScopeStatement::containsOnlyDeclarations() const
   {
  // DQ (9/25/2009): This was a problem in an example reported by Keasler.
     ROSE_ASSERT(this != NULL);

  // All but two of the derived classes contain one or more list of SgStatements while two of them
  // contain a list of SgDeclarationStmt which complicates the design of a simple implementation of
  // functions that operate on scopes generally.
     bool returnValue = false;
     switch ( variantT() )
        {
       // DQ (11/30/2007): Added more Fortran support.
          case V_SgAssociateStatement:

          case V_SgBasicBlock:
          case V_SgCatchOptionStmt:
          case V_SgDoWhileStmt:
          case V_SgForStatement:
       // Liao, 6/17/2008, upc_forall           
          case V_SgUpcForAllStatement:
          case V_SgFunctionDefinition:
          case V_SgIfStmt:
          case V_SgSwitchStatement:
          case V_SgWhileStmt:
          case V_SgFortranDo:
          case V_SgForAllStatement:
          case V_SgCAFWithTeamStatement: //FMZ (2/18/2009)
               returnValue = false;
               break;

          case V_SgClassDefinition:
          case V_SgTemplateInstantiationDefn:
          case V_SgNamespaceDefinitionStatement:
          case V_SgGlobal:
          case V_SgModuleStatement:
               returnValue = true;
               break;

          default:
               printf ("ERROR: default reached in switch ($CLASSNAME::containsOnlyDeclarations() is called from a %s) \n",sage_class_name());
               ROSE_ASSERT(false);
               break;
        }

     return returnValue;
   }


bool
SgScopeStatement::supportsDefiningFunctionDeclaration()
   {
  // DQ (10/18/2006): Not all scopes permit function declarations. Any function prototype in a 
  // scope appropriate for a function definition triggers requirements for name qualification.
  // This function returns true if the scope is appropriate for the definition of a function
  // or member function (i.e. is a SgGlobal, SgClassDefinition, or SgNamespaceDefinitionStatement).

  // This is equivalent to the test for if the scope only permits declarations.
     return containsOnlyDeclarations();
   }


// DQ (7/17/2002) Added to support rewrite mechanism some scopes can only contain
// SgDeclarationStmt while others can contain any kind of SgStatement
void
SgScopeStatement::insertStatementInScope ( SgStatement* newTransformationStatement, bool atTop )
   {
  // Put the new statement at the front (without regard to any dependencies on declared types)

  // We have only debugged this case so far
  // ROSE_ASSERT (atTop == true);

     bool inFront = (atTop == true);
     SgScopeStatement* currentScope = this;
     if (atTop == true)
        {
          if (currentScope->containsOnlyDeclarations() == true)
             {
               SgDeclarationStatementPtrList & declarationList = currentScope->getDeclarationList();
               SgDeclarationStatementPtrList::iterator declaration = declarationList.begin();
               ROSE_ASSERT ( isSgDeclarationStatement(newTransformationStatement) != NULL );
               SgDeclarationStatement* newDeclarationStatement = isSgDeclarationStatement(newTransformationStatement);

               ROSE_ASSERT(newDeclarationStatement != NULL);

               unsigned oldSize = declarationList.size();
            // if (declarationList.size() == 0)
               if (declarationList.empty() == true)
                  {
                 // append_declaration(newTransformationStatement);
#ifndef REMOVE_SET_PARENT_FUNCTION
                    newDeclarationStatement->set_parent(currentScope);
#endif
                 // printf ("Case declarationList.size() == 0: parent of newDeclarationStatement may not be set properly (same for scope) \n");
                    declarationList.push_back(newDeclarationStatement);

                 // DQ (6/24/2006): We have to handle this case explicitly
                    newDeclarationStatement->set_parent(currentScope);
                    ROSE_ASSERT(newDeclarationStatement->get_parent() != NULL);
                  }
                 else
                  {
                    ROSE_ASSERT ( *declaration != NULL );
                    insert_statement (*declaration,newTransformationStatement,inFront);

                 // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
               ROSE_ASSERT (declarationList.size() == oldSize+1);
               
#if 0
               printf ("Exiting after call to insert_statement in $CLASSNAME::insertStatementInScope() \n");
               ROSE_ABORT();
#endif
             }
            else
             {
               SgStatementPtrList & statementList = currentScope->getStatementList();
               SgStatementPtrList::iterator statement = statementList.begin();

            // if (statementList.size() == 0)
               if (statementList.empty() == true)
                  {
#ifndef REMOVE_SET_PARENT_FUNCTION
                    newTransformationStatement->set_parent(currentScope);
#endif
                 // printf ("Case statementList.size() == 0: parent of newTransformationStatement may not be set properly (same for scope) \n");
                    statementList.push_back(newTransformationStatement);

                 // DQ (6/24/2006): We have to handle this case explicitly
                    newTransformationStatement->set_parent(currentScope);
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
                 else
                  {
                    ROSE_ASSERT ( *statement != NULL );
                    insert_statement (*statement,newTransformationStatement,inFront);

                 // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
             }

       // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
          ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
        }
       else
        {
          if (currentScope->containsOnlyDeclarations() == true)
             {
               SgDeclarationStatementPtrList & declarationList = currentScope->getDeclarationList();
               SgDeclarationStatementPtrList::reverse_iterator declaration = declarationList.rbegin();
               ROSE_ASSERT ( isSgDeclarationStatement(newTransformationStatement) != NULL );
               SgDeclarationStatement* newDeclarationStatement = isSgDeclarationStatement(newTransformationStatement);

               ROSE_ASSERT(newDeclarationStatement != NULL);

               unsigned oldSize = declarationList.size();
            // if (declarationList.size() == 0)
               if (declarationList.empty() == true)
                  {
                 // append_declaration(newTransformationStatement);
#ifndef REMOVE_SET_PARENT_FUNCTION
                    newDeclarationStatement->set_parent(currentScope);
#endif
                 // printf ("Case declarationList.size() == 0: parent of newDeclarationStatement may not be set properly (same for scope) \n");
                    declarationList.push_back(newDeclarationStatement);

                 // DQ (6/24/2006): We have to handle this case explicitly
                    newDeclarationStatement->set_parent(currentScope);
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
                 else
                  {
                    ROSE_ASSERT ( *declaration != NULL );
                    insert_statement (*declaration,newTransformationStatement,inFront);

                 // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
               ROSE_ASSERT (declarationList.size() == oldSize+1);

            // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
               ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
#if 0
               printf ("Exiting after call to insert_statement in $CLASSNAME::insertStatementInScope() \n");
               ROSE_ABORT();
#endif
             }
            else
             {
               SgStatementPtrList & statementList = currentScope->getStatementList();
               SgStatementPtrList::reverse_iterator statement = statementList.rbegin();

            // if (statementList.size() == 0)
               if (statementList.empty() == true)
                  {
#ifndef REMOVE_SET_PARENT_FUNCTION
                    newTransformationStatement->set_parent(currentScope);
#endif
                 // printf ("Case statementList.size() == 0: parent of newTransformationStatement may not be set properly (same for scope) \n");
                    statementList.push_back(newTransformationStatement);

                 // DQ (6/24/2006): We have to handle this case explicitly
                    newTransformationStatement->set_parent(currentScope);
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
                 else
                  {
                    ROSE_ASSERT ( *statement != NULL );
                    insert_statement (*statement,newTransformationStatement,inFront);

                 // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
             }
        }

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
   }

// DQ (7/17/2002) Added to support rewrite mechanism some scopes can only contain
// SgDeclarationStmt while others can contain any kind of SgStatement
SgDeclarationStatementPtrList &
SgScopeStatement::getDeclarationList ()
// $CLASSNAME::getDeclarationList ( SgScopeStatement* currentScope )
   {
  // Supporting function for SynthesizedAttributeBaseClassType::insertAtTopOfScope().  This should
  // perhaps be moved to the SgScopeStatement object at some point.

     SgScopeStatement* currentScope = this;
     ROSE_ASSERT (currentScope != NULL);

     SgDeclarationStatementPtrList* currentStatementList = NULL;
     switch ( currentScope->variantT() )
        {
          case V_SgClassDefinition:
             {
               SgClassDefinition* classDefinitionScope = isSgClassDefinition(currentScope);
               ROSE_ASSERT (classDefinitionScope != NULL);
               currentStatementList = &(classDefinitionScope->get_members());
               break;
             }

          case V_SgTemplateInstantiationDefn:
             {
               SgTemplateInstantiationDefn* templateInstantiationDefinitionScope = isSgTemplateInstantiationDefn(currentScope);
               ROSE_ASSERT (templateInstantiationDefinitionScope != NULL);
               currentStatementList = &(templateInstantiationDefinitionScope->get_members());
               break;
             }

          case V_SgGlobal:
             {
               SgGlobal* globalScope = isSgGlobal(currentScope);
               ROSE_ASSERT (globalScope != NULL);
               currentStatementList = &(globalScope->get_declarations());
               break;
             }

          case V_SgNamespaceDefinitionStatement:
             {
               SgNamespaceDefinitionStatement* namespaceScope = isSgNamespaceDefinitionStatement(currentScope);
               ROSE_ASSERT (namespaceScope != NULL);
               currentStatementList = &(namespaceScope->get_declarations());
               break;
             }

          default:
               printf ("ERROR: default reached in switch (getDeclarationList()) currentScope = %s \n",currentScope->sage_class_name());
               printf ("Note: this function is not defined for all IR nodes derived from SgScopeStatement (use SgScopeStatement::containsOnlyDeclarations() to check)\n");
               ROSE_ASSERT(false);
               break;
        }

     return *currentStatementList;
   }

const SgDeclarationStatementPtrList &
SgScopeStatement::getDeclarationList () const
// $CLASSNAME::getDeclarationList ( SgScopeStatement* currentScope )
   {
  // Supporting function for SynthesizedAttributeBaseClassType::insertAtTopOfScope().  This should
  // perhaps be moved to the SgScopeStatement object at some point.

     const SgScopeStatement* currentScope = this;
     ROSE_ASSERT (currentScope != NULL);

  // SgDeclarationStatementPtrList* currentStatementList = NULL;
     switch ( currentScope->variantT() )
        {
          case V_SgClassDefinition:
             {
               const SgClassDefinition* classDefinitionScope = isSgClassDefinition(currentScope);
               ROSE_ASSERT (classDefinitionScope != NULL);
            // currentStatementList = &(classDefinitionScope->get_members());
               return classDefinitionScope->get_members();
               break;
             }

          case V_SgTemplateInstantiationDefn:
             {
               const SgTemplateInstantiationDefn* templateInstantiationDefinitionScope = isSgTemplateInstantiationDefn(currentScope);
               ROSE_ASSERT (templateInstantiationDefinitionScope != NULL);
            // currentStatementList = &(templateInstantiationDefinitionScope->get_members());
               return templateInstantiationDefinitionScope->get_members();
               break;
             }

          case V_SgGlobal:
             {
               const SgGlobal* globalScope = isSgGlobal(currentScope);
               ROSE_ASSERT (globalScope != NULL);
            // currentStatementList = &(globalScope->get_declarations());
               return globalScope->get_declarations();
               break;
             }

          case V_SgNamespaceDefinitionStatement:
             {
               const SgNamespaceDefinitionStatement* namespaceScope = isSgNamespaceDefinitionStatement(currentScope);
               ROSE_ASSERT (namespaceScope != NULL);
            // currentStatementList = &(namespaceScope->get_declarations());
               return namespaceScope->get_declarations();
               break;
             }

          default:
               printf ("ERROR: default reached in switch (getDeclarationList() const) currentScope = %s \n",currentScope->sage_class_name());
               printf ("Note: this function is not defined for all IR nodes derived from SgScopeStatement (use SgScopeStatement::containsOnlyDeclarations() to check)\n");
               ROSE_ASSERT(false);
               break;
        }

     printf ("This should be unreachable code! \n");
     ROSE_ASSERT(false);
  // return *currentStatementList;
     static SgDeclarationStatementPtrList defaultList;
     return defaultList;
   }

#if 0
// DQ (1/30/2007): Added this cases that previously caused the default case to be used
// so that better error handling could be used.
SgStatementPtrList
SgScopeStatement::generateStatementList()
   {
  // This function permits access to the statements or declarations as a list of statements
  // since declarations are derived from statements.  This function generates a copy of the
  // list in both cases (symmetrically for both types).

#if 0
     printf ("In $CLASSNAME::generateStatementList() containsOnlyDeclarations() = %s \n",
          containsOnlyDeclarations() ? "true" : "false");
#endif

     SgStatementPtrList returnList;
     if (containsOnlyDeclarations() == true)
        {
          SgDeclarationStatementPtrList & declarationList = getDeclarationList();
          SgDeclarationStatementPtrList::iterator i = declarationList.begin();
          for (i = declarationList.begin(); i != declarationList.end(); i++)
               returnList.push_back(*i);

          ROSE_ASSERT (returnList.size() == declarationList.size());

#if 0
       // error checking
          SgStatementPtrList::iterator j = returnList.begin();
          for (i = declarationList.begin(); i != declarationList.end(); i++)
             {
               ROSE_ASSERT ( (*i) == (*j) );
               printf ("     declaration = %s \n",(*i)->unparseToString().c_str());
               j++;
             }
#endif
        }
       else
        {
       // Handle special case of two lists in a single statement (just append the 2nd list to the 1st list
          SgIfStmt* ifStatement = isSgIfStmt(this);
          if (ifStatement != NULL)
             {
               returnList = ifStatement->get_true_body()->getStatementList();
               if (ifStatement->get_false_body())
                  {
                    SgStatementPtrList falseList = ifStatement->get_false_body()->getStatementList();
                    for (SgStatementPtrList::iterator i = falseList.begin(); i != falseList.end(); i++)
                       {
                         returnList.push_back(*i);
                       }
                  }
             }
            else
             {
               returnList = getStatementList();
             }
        }

  // printf ("In generateStatementList(): returnList.size() = %zu \n",returnList.size());

     return returnList;
   }
#endif

// DQ (7/17/2002) Added to support rewrite mechanism some scopes can only contain
// SgDeclarationStmt while others can contain any kind of SgStatement
SgStatementPtrList &
SgScopeStatement::getStatementList ()
   {
  // Supporting function for SynthesizedAttributeBaseClassType::insertAtTopOfScope().  This should
  // perhaps be moved to the SgScopeStatement object at some point.

  // If this were a virtual member function then this would be far simpler :-).

     SgScopeStatement* currentScope = this;
     ROSE_ASSERT (currentScope != NULL);

     SgStatementPtrList* currentStatementList = NULL;
     switch ( currentScope->variantT() )
        {
          case V_SgBasicBlock:
             {
               SgBasicBlock* basicBlock = isSgBasicBlock(currentScope);
               ROSE_ASSERT (basicBlock != NULL);
               currentStatementList = &(basicBlock->get_statements());
               break;
             }

          case V_SgCatchOptionStmt:
             {
               SgCatchOptionStmt* catchOptionScope = isSgCatchOptionStmt(currentScope);
               ROSE_ASSERT (catchOptionScope != NULL);
               ROSE_ASSERT (catchOptionScope->get_body() != NULL);
               currentStatementList = &(SageInterface::ensureBasicBlockAsBodyOfCatch(catchOptionScope)->getStatementList());
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgClassDefinition:
             {
               printf ("case SgClassDefinition in SgScopeStatement::getStatementList() called by mistake, use SgScopeStatement::getDeclarationList() instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               ROSE_ASSERT(false);
               break;
             }

          case V_SgDoWhileStmt:
             {
               SgDoWhileStmt* doWhileScope = isSgDoWhileStmt(currentScope);
               ROSE_ASSERT (doWhileScope != NULL);
               ROSE_ASSERT (doWhileScope->get_body() != NULL);
               currentStatementList = &(SageInterface::ensureBasicBlockAsBodyOfDoWhile(doWhileScope)->getStatementList());
               break;
             }

          case V_SgForStatement:
             { 
               SgForStatement* forScope = isSgForStatement(currentScope);
               ROSE_ASSERT (forScope != NULL);
            // Liao, 9/29/2008, This function could be called during parsing and 
            // the loop body is not yet filled up
            //   ROSE_ASSERT (forScope->get_loop_body() != NULL);
            // Should this be defined given that there are two SgBasicBlock objects in a SgForStatement
            // currentStatementList = forScope->get_init_stmt();
               currentStatementList = &(SageInterface::ensureBasicBlockAsBodyOfFor(forScope)->getStatementList());
               break;
             }

          case V_SgFunctionDefinition:
             {
               SgFunctionDefinition* functionScope = isSgFunctionDefinition(currentScope);
               ROSE_ASSERT (functionScope != NULL);
               ROSE_ASSERT (functionScope->get_body() != NULL);
               currentStatementList = &(functionScope->get_body()->getStatementList());
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgTemplateInstantiationDefn:
             {
               printf ("case SgTemplateInstantiationDefn in SgScopeStatement::getStatementList() called by mistake, use SgScopeStatement::getDeclarationList() instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               ROSE_ASSERT(false);
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgGlobal:
             {
               printf ("case SgGlobal in SgScopeStatement::getStatementList() called by mistake, use SgScopeStatement::getDeclarationList() instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               
               ROSE_ASSERT(false);
               break;
             }

          case V_SgIfStmt:
             {
               SgIfStmt* ifStatement = isSgIfStmt(currentScope);
               ROSE_ASSERT (ifStatement != NULL);

#if 0
            // Merge the different lists from the true and false blocks (this might not 
            // provide the correct semantics for some uses of the final list).
               ROSE_ASSERT (ifStatement->true_body() != NULL);
               currentStatementList  =  new SgStatementPtrList (ifStatement->true_body()->getStatementList());
               ROSE_ASSERT (ifStatement->false_body() != NULL);
               currentStatementList->merge(ifStatement->false_body()->getStatementList());
#endif

               printf ("getStatementList() return value not defined for SgIfStmt containing true and false bodies (use generateStatementList() to form copy of merges lists) \n");
               ROSE_ABORT();
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgNamespaceDefinitionStatement:
             {
               printf ("case SgNamespaceDefinitionStatement in SgScopeStatement::getStatementList() called by mistake, use SgScopeStatement::getDeclarationList() instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               ROSE_ASSERT(false);
               break;
             }

          case V_SgSwitchStatement:
             {
               SgSwitchStatement* switchStatement = isSgSwitchStatement(currentScope);
               ROSE_ASSERT (switchStatement != NULL);
               ROSE_ASSERT (switchStatement->get_body() != NULL);
               currentStatementList = &(SageInterface::ensureBasicBlockAsBodyOfSwitch(switchStatement)->getStatementList());
               break;
             }

          case V_SgWhileStmt:
             {
               SgWhileStmt* whileStatement = isSgWhileStmt(currentScope);
               ROSE_ASSERT (whileStatement != NULL);
               ROSE_ASSERT (whileStatement->get_body() != NULL);
               currentStatementList = &(SageInterface::ensureBasicBlockAsBodyOfWhile(whileStatement)->getStatementList());
               break;
             }

          case V_SgFortranDo:
             {
               SgFortranDo* doStatement = isSgFortranDo(currentScope);
               ROSE_ASSERT (doStatement != NULL);
               ROSE_ASSERT (doStatement->get_body() != NULL);
               currentStatementList = &(doStatement->get_body()->getStatementList());
               break;
             }

          default:
               printf ("ERROR: default reached in switch (getStatementList()) currentScope = %s \n",currentScope->sage_class_name());
               printf ("Note: this function is not defined for all IR nodes derived from SgScopeStatement (use SgScopeStatement::containsOnlyDeclarations() to check)\n");
               ROSE_ABORT();
               break;
        }

     return *currentStatementList;
   }


// DQ (10/6/2007): Added const version of this function to support const version of generateStatementList() 
const SgStatementPtrList &
SgScopeStatement::getStatementList () const
   {
  // Supporting function for SynthesizedAttributeBaseClassType::insertAtTopOfScope().  This should
  // perhaps be moved to the SgScopeStatement object at some point.

  // If this were a virtual member function then this would be far simpler :-).

     const SgScopeStatement* currentScope = this;
     ROSE_ASSERT (currentScope != NULL);

     static const SgStatementPtrList emptyStatementList;

  // SgStatementPtrList* currentStatementList = NULL;
     switch ( currentScope->variantT() )
        {
          case V_SgBasicBlock:
             {
               const SgBasicBlock* basicBlock = isSgBasicBlock(currentScope);
               ROSE_ASSERT (basicBlock != NULL);
            // currentStatementList = &(basicBlock->get_statements());
               return basicBlock->get_statements();
               break;
             }

          case V_SgCatchOptionStmt:
             {
               const SgCatchOptionStmt* catchOptionScope = isSgCatchOptionStmt(currentScope);
               ROSE_ASSERT (catchOptionScope != NULL);
               ROSE_ASSERT (catchOptionScope->get_body() != NULL);
            // currentStatementList = &(catchOptionScope->get_body()->getStatementList());
               return isSgBasicBlock(catchOptionScope->get_body()) ? isSgBasicBlock(catchOptionScope->get_body())->getStatementList() : emptyStatementList;
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgClassDefinition:
             {
               printf ("case SgClassDefinition in SgScopeStatement::getStatementList() const called by mistake, use SgScopeStatement::getDeclarationList() const instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               ROSE_ASSERT(false);
               break;
             }

          case V_SgDoWhileStmt:
             {
               const SgDoWhileStmt* doWhileScope = isSgDoWhileStmt(currentScope);
               ROSE_ASSERT (doWhileScope != NULL);
               ROSE_ASSERT (doWhileScope->get_body() != NULL);
            // currentStatementList = &(doWhileScope->get_body()->getStatementList());
               return isSgBasicBlock(doWhileScope->get_body()) ? isSgBasicBlock(doWhileScope->get_body())->getStatementList() : emptyStatementList;
               break;
             }

          case V_SgForStatement:
             { 
               const SgForStatement* forScope = isSgForStatement(currentScope);
               ROSE_ASSERT (forScope != NULL);
               ROSE_ASSERT (forScope->get_loop_body() != NULL);
            // Should this be defined given that there are two SgBasicBlock objects in a SgForStatement
            // currentStatementList = forScope->get_init_stmt();
            // currentStatementList = &(forScope->get_loop_body()->getStatementList());
               return isSgBasicBlock(forScope->get_loop_body()) ? isSgBasicBlock(forScope->get_loop_body())->getStatementList() : emptyStatementList;
               break;
             }

// Liao, 6/17/2008, upc_forall statement             
          case V_SgUpcForAllStatement:
             { 
               const SgUpcForAllStatement* forScope = isSgUpcForAllStatement(currentScope);
               ROSE_ASSERT (forScope != NULL);
               ROSE_ASSERT (forScope->get_loop_body() != NULL);
            // Should this be defined given that there are two SgBasicBlock objects in a SgForStatement
            // currentStatementList = forScope->get_init_stmt();
            // currentStatementList = &(forScope->get_loop_body()->getStatementList());
               return isSgBasicBlock(forScope->get_loop_body()) ? isSgBasicBlock(forScope->get_loop_body())->getStatementList() : emptyStatementList;
               break;
             }

          case V_SgFunctionDefinition:
             {
               const SgFunctionDefinition* functionScope = isSgFunctionDefinition(currentScope);
               ROSE_ASSERT (functionScope != NULL);
               ROSE_ASSERT (functionScope->get_body() != NULL);
            // currentStatementList = &(functionScope->get_body()->getStatementList());
               return functionScope->get_body()->getStatementList();
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgTemplateInstantiationDefn:
             {
               printf ("case SgTemplateInstantiationDefn in SgScopeStatement::getStatementList() const called by mistake, use SgScopeStatement::getDeclarationList() const instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               ROSE_ASSERT(false);
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgGlobal:
             {
               printf ("case SgGlobal in SgScopeStatement::getStatementList() const called by mistake, use SgScopeStatement::getDeclarationList() const instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               
               ROSE_ASSERT(false);
               break;
             }

          case V_SgIfStmt:
             {
               const SgIfStmt* ifStatement = isSgIfStmt(currentScope);
               ROSE_ASSERT (ifStatement != NULL);

#if 0
            // Merge the different lists from the true and false blocks (this might not 
            // provide the correct semantics for some uses of the final list).
               ROSE_ASSERT (ifStatement->true_body() != NULL);
               currentStatementList  =  new SgStatementPtrList (ifStatement->true_body()->getStatementList());
               ROSE_ASSERT (ifStatement->false_body() != NULL);
               currentStatementList->merge(ifStatement->false_body()->getStatementList());
#endif

               printf ("getStatementList() const return value not defined for SgIfStmt containing true and false bodies (use generateStatementList() const to form copy of merges lists) \n");
               ROSE_ABORT();
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgNamespaceDefinitionStatement:
             {
               printf ("case SgNamespaceDefinitionStatement in SgScopeStatement::getStatementList() const called by mistake, use SgScopeStatement::getDeclarationList() const instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               ROSE_ASSERT(false);
               break;
             }

          case V_SgSwitchStatement:
             {
               const SgSwitchStatement* switchStatement = isSgSwitchStatement(currentScope);
               ROSE_ASSERT (switchStatement != NULL);
               ROSE_ASSERT (switchStatement->get_body() != NULL);
            // currentStatementList = &(switchStatement->get_body()->getStatementList());
               return isSgBasicBlock(switchStatement->get_body()) ? isSgBasicBlock(switchStatement->get_body())->getStatementList() : emptyStatementList;
               break;
             }

          case V_SgWhileStmt:
             {
               const SgWhileStmt* whileStatement = isSgWhileStmt(currentScope);
               ROSE_ASSERT (whileStatement != NULL);
               ROSE_ASSERT (whileStatement->get_body() != NULL);
            // currentStatementList = &(whileStatement->get_body()->getStatementList());
               return isSgBasicBlock(whileStatement->get_body()) ? isSgBasicBlock(whileStatement->get_body())->getStatementList() : emptyStatementList;
               break;
             }

          case V_SgAssociateStatement:
             {
            // Not clear if we should include the list of SgVariableDeclarations in this list or not!
               const SgAssociateStatement* associateStatement = isSgAssociateStatement(currentScope);
               ROSE_ASSERT (associateStatement != NULL);
               ROSE_ASSERT (associateStatement->get_body() != NULL);
               return associateStatement->get_body()->getStatementList();
               break;
             }

          case V_SgFortranDo:
             {
               const SgFortranDo* doStatement = isSgFortranDo(currentScope);
               ROSE_ASSERT (doStatement != NULL);
               ROSE_ASSERT (doStatement->get_body() != NULL);
               return doStatement->get_body()->getStatementList();
               break;
             }

          case V_SgForAllStatement:
             { 
               const SgForAllStatement* forAllScope = isSgForAllStatement(currentScope);
               ROSE_ASSERT (forAllScope != NULL);
               ROSE_ASSERT (forAllScope->get_body() != NULL);
            // Should this be defined given that there are two SgBasicBlock objects in a SgForStatement
            // currentStatementList = forScope->get_init_stmt();
            // currentStatementList = &(forScope->get_loop_body()->getStatementList());
               return forAllScope->get_body()->getStatementList();
               break;
             }

          // FMZ (CoArray with team)
          case V_SgCAFWithTeamStatement:
             {
               const SgCAFWithTeamStatement* teamScope = isSgCAFWithTeamStatement(currentScope);
               ROSE_ASSERT (teamScope != NULL);
               ROSE_ASSERT (teamScope->get_body() != NULL);
               return isSgBasicBlock(teamScope->get_body()) ? isSgBasicBlock(teamScope->get_body())->getStatementList() : emptyStatementList;
               break;
             }


          default:
               printf ("ERROR: default reached in switch (getStatementList() const) currentScope = %s \n",currentScope->sage_class_name());
               printf ("Note: this function is not defined for all IR nodes derived from SgScopeStatement (use SgScopeStatement::containsOnlyDeclarations() to check)\n");
               ROSE_ASSERT(false);
               break;
        }

     printf ("This should be unreachable code! \n");
     ROSE_ASSERT(false);
  // return *currentStatementList;
  // return SgStatementPtrList();
     static SgStatementPtrList defaultList;
     return defaultList;
   }


const SgStatementPtrList
SgScopeStatement::generateStatementList() const
   {
  // This function permits access to the statements or declarations as a list of statements
  // since declarations are derived from statements.  This function generates a copy of the
  // list in both cases (symmetrically for both types).

#if 0
     printf ("In $CLASSNAME::generateStatementList() containsOnlyDeclarations() = %s \n",
          containsOnlyDeclarations() ? "true" : "false");
#endif

     SgStatementPtrList returnList;
     if (containsOnlyDeclarations() == true)
        {
          const SgDeclarationStatementPtrList & declarationList = getDeclarationList();
          SgDeclarationStatementPtrList::const_iterator i = declarationList.begin();
          for (i = declarationList.begin(); i != declarationList.end(); i++)
               returnList.push_back(*i);

          ROSE_ASSERT (returnList.size() == declarationList.size());

#if 0
       // error checking
          const SgStatementPtrList::const_iterator j = returnList.begin();
          for (i = declarationList.begin(); i != declarationList.end(); i++)
             {
               ROSE_ASSERT ( (*i) == (*j) );
               printf ("     declaration = %s \n",(*i)->unparseToString().c_str());
               j++;
             }
#endif
        }
       else
        {
       // Handle special case of two lists in a single statement (just append the 2nd list to the 1st list)
          const SgIfStmt* ifStatement = isSgIfStmt(this);
          if (ifStatement != NULL)
             {
               if (isSgScopeStatement(ifStatement->get_true_body()))
                  {
                    returnList = isSgScopeStatement(ifStatement->get_true_body())->getStatementList();
                  }
               if (isSgScopeStatement(ifStatement->get_false_body()))
                  {
                    const SgStatementPtrList& falseList = isSgScopeStatement(ifStatement->get_false_body())->getStatementList();
                    returnList.insert(returnList.end(), falseList.begin(), falseList.end());
                  }
             }
            else
             {
               returnList = getStatementList();
             }
        }

  // printf ("In generateStatementList(): returnList.size() = %zu \n",returnList.size());

     return returnList;
   }

unsigned int
SgScopeStatement::generateUniqueStatementNumberForScope( SgStatement* statement )
   {
     unsigned int counter = 0;
     bool found = this->generateUniqueStatementNumberForScopeHelper(counter, statement);
     ROSE_ASSERT (found);
     return counter;
   }

bool
SgScopeStatement::generateUniqueStatementNumberForScopeHelper(unsigned int& counter, SgStatement* statement)
   {
  // DQ (2/20/2007): This function supports the AST merge mechanism, but is general 
  // and may be useful for the mangled name generation in the future.

  // This function generates a unique number for each statement in the scope by returning
  // its position value countered from the top of the list of statements of declarations.
  // It is used in the AST merge within the mechanism to generate unique names for both 
  // un-named enums and class declarations and template declarations of overloaded 
  // functions in a templated class (since at the point of instantiation of the outer class
  // the names of any overloaded functions are all the same).  The value of returned 
  // by this function should only be relied upon to be unique for the given scope (nothing more).
  // This function may be useful for naming unnamed scopes such as though in loop constructs.

#if 1
     printf ("In SgScopeStatement::generateUniqueStatementNumberForScope() containsOnlyDeclarations() = %s \n",
          containsOnlyDeclarations() ? "true" : "false");
#endif

     if (containsOnlyDeclarations() == true)
        {
          const SgDeclarationStatement* declaration = isSgDeclarationStatement(statement);
          ROSE_ASSERT(declaration != NULL);

          const SgDeclarationStatementPtrList & declarationList = getDeclarationList();
          SgDeclarationStatementPtrList::const_iterator i = declarationList.begin();
          while ( (i != declarationList.end()) && ( (*i)->get_definingDeclaration() != declaration->get_definingDeclaration()) )
             {
               printf ("counter = %d *i = %p = %s defining declaration = %p statement = %p = %s statement defining declaration = %p \n",
                    counter,*i,(*i)->class_name().c_str(),(*i)->get_definingDeclaration(),statement,statement->class_name().c_str(),declaration->get_definingDeclaration());
               counter++;
               i++;
             }

          if (i == declarationList.end())
             {
               printf ("statement = %p = %s not found in scope (declaration list) = %p = %s \n",statement,statement->class_name().c_str(),this,this->class_name().c_str());
               return false;
             }
            else
             {
               printf ("END: counter = %d *i = %p = %s defining declaration = %p statement = %p = %s statement defining declaration = %p \n",
                    counter,*i,(*i)->class_name().c_str(),(*i)->get_definingDeclaration(),statement,statement->class_name().c_str(),declaration->get_definingDeclaration());
               return true;
             }

        }
       else
        {
       // Handle special case of two lists in a single statement (just add the 2nd list to the 1st result)
          SgIfStmt* ifStatement = isSgIfStmt(this);
          if (ifStatement != NULL)
             {
               // The calls to generateUniqueStatementNumberForScopeHelper both
               // increment the counter for the number of nested statements
               // found in their respective regions of the program.
               // Note that the condition of the if is not checked -- this
               // matches the previous behavior, but may not be correct.
               bool foundTrue = false;
               if (isSgBasicBlock(ifStatement->get_true_body())) {
                 foundTrue = isSgBasicBlock(ifStatement->get_true_body())->generateUniqueStatementNumberForScopeHelper(counter, statement);
               } else {
                 foundTrue = (statement == ifStatement->get_true_body());
                 if (!foundTrue) ++counter;
               }
               if (foundTrue) {
                 return true;
               } else {
                 bool foundFalse = false;
                 if (isSgBasicBlock(ifStatement->get_false_body())) {
                   foundFalse = isSgBasicBlock(ifStatement->get_false_body())->generateUniqueStatementNumberForScopeHelper(counter, statement);
                 } else {
                   foundFalse = (statement != NULL && statement == ifStatement->get_false_body());
                   if (!foundFalse) ++counter;
                 }
                 if (foundFalse) {
                   return true;
                 } else {
                   return false;
                 }
               }
             }
            else
             {
               const SgStatementPtrList & statementList = getStatementList();
               SgStatementPtrList::const_iterator i = statementList.begin();
               while ( (i != statementList.end()) && (*i != statement) )
                  {
                    counter++;
                    i++;
                  }

               if (i == statementList.end())
                  {
                    printf ("statement = %p = %s not found in scope (statement list) = %p = %s \n",statement,statement->class_name().c_str(),this,this->class_name().c_str());
                    ROSE_ASSERT(counter == statementList.size());
                  }
             }
        }

     printf ("In generateUniqueStatementNumberForScope(): counter = %u \n",counter);

     return counter;
   }

SgStatement*
SgScopeStatement::firstStatement() const
   {
     const SgStatementPtrList & statementList = getStatementList();

     SgStatement* first = NULL;
     if (statementList.empty() == false)
          first = *(statementList.begin());

     return first;
   }

SgStatement*
SgScopeStatement::lastStatement() const
   {
     SgStatement* last = NULL;

#if 0
     const SgStatementPtrList & statementList = getStatementList();
     if (statementList.empty() == false)
          last = *(statementList.rbegin());
#else
  // This function has to handle the details of looking for the last statement dependent 
  // upon if the scope contains a list of SgDeclarationStatement or SgStatement.
     SgStatementPtrList returnList;
     if (containsOnlyDeclarations() == true)
        {
          const SgDeclarationStatementPtrList & declarationList = getDeclarationList();
          if (declarationList.empty() == false)
               last = *(declarationList.rbegin());
        }
       else
        {
       // Handle special case of two lists in a single statement (just append the 2nd list to the 1st list)
          const SgIfStmt* ifStatement = isSgIfStmt(this);
          if (ifStatement != NULL)
             {
            // Both the true and false bodies can be either a SgBasicBlock or any SgStatement.
            // NOTE: If the false body is empty then use the last statement of the true body.
            // Having an empty false body is a common normalization within the IR, though less 
            // so for C/C++ recently and more for Fortrna (as I recall).
               SgScopeStatement* ifScopeFalseBody = isSgScopeStatement(ifStatement->get_false_body());
               if (ifScopeFalseBody != NULL && ifScopeFalseBody->getStatementList().empty() == false)
                  {
                 // const SgStatementPtrList& falseList = isSgScopeStatement(ifStatement->get_false_body())->getStatementList();
                 // returnList.insert(returnList.end(), falseList.begin(), falseList.end());
                    const SgStatementPtrList & statementList = ifScopeFalseBody->getStatementList();
#if 1
                    ROSE_ASSERT (statementList.empty() == false);
                    last = *(statementList.rbegin());
#else
                    if (statementList.empty() == false)
                       {
                         last = *(statementList.rbegin());
                       }
                      else
                       {
                      // I think that this path should not be possible!
                         printf ("ERROR: false branch statementList.empty() == true \n");
                         ROSE_ASSERT(false);
                       }
#endif
                  }
                 else
                  {
                    SgStatement* falseStatement = ifStatement->get_false_body();
                    if (falseStatement != NULL)
                       {
                         last = falseStatement;
                       }
                      else
                       {
                      // If there is no false body then we have to look at the bottom of the true body.
                      // Both the true and false bodies can be either a SgBasicBlock or any SgStatement.
                         if (isSgScopeStatement(ifStatement->get_true_body()) != NULL)
                            {
                           // returnList = isSgScopeStatement(ifStatement->get_true_body())->getStatementList();
                              const SgStatementPtrList & statementList = isSgScopeStatement(ifStatement->get_true_body())->getStatementList();
                              if (statementList.empty() == false)
                                 {
                                   last = *(statementList.rbegin());
                                 }
                                else
                                 {
                                   printf ("ERROR: true branch statementList.empty() == true \n");
                                   ROSE_ASSERT(false);
                                 }
                            }
                           else
                            {
                              SgStatement* trueStatement = ifStatement->get_true_body();
                              last = trueStatement;
                            }

                         ROSE_ASSERT(last != NULL);
                       }

                    ROSE_ASSERT(last != NULL);
                  }

               ROSE_ASSERT(last != NULL);
             }
            else
             {
            // returnList = getStatementList();
               const SgStatementPtrList & statementList = getStatementList();
               if (statementList.empty() == false)
                    last = *(statementList.rbegin());
             }
        }
#endif

     return last;
   }

bool
SgScopeStatement::isCaseInsensitive() const
   {
  // Case sensitive scopes are for C/C++ and case insensitive scopes are for Fortran.
  // The case sensitive behavior is property of the symbol table only, but it represented
  // in the scope API to be consistatn with the symbol table handling API being presented 
  // at the scope level (SgScopeStatment).

     ROSE_ASSERT(p_symbol_table != NULL);
     return p_symbol_table->isCaseInsensitive();
   }

void
SgScopeStatement::setCaseInsensitive(bool b)
   {
  // Case sensitive scopes are for C/C++ and case insensitive scopes are for Fortran.
  // The case sensitive behavior is property of the symbol table only, but it represented
  // in the scope API to be consistatn with the symbol table handling API being presented 
  // at the scope level (SgScopeStatment).

     ROSE_ASSERT(p_symbol_table != NULL);
     p_symbol_table->setCaseInsensitive(b);
   }


SOURCE_SCOPE_STATEMENT_END


SOURCE_FUNCTION_TYPE_TABLE_STATEMENT_START

/* \brief Hash table of function types (table is stored on global scope).

   Hash table of function types (table is stored on global scope and includes data
   from all scopes). Function types are placed into and retrieved from this data 
   base (simple hash table) of function types.
 */
// DQ (1/31/2006): Modified to build all types in the memory pools
// SgFunctionTypeTable Sgfunc_type_table;

// SgFunctionTypeTable::SgFunctionTypeTable( bool case_insensitive )
SgFunctionTypeTable::SgFunctionTypeTable()
  // DQ (8/31/2006): Use an empty name for the fileInfo so that we can support testing for absolute paths for filenames.
   : SgStatement( new Sg_File_Info ("",0,0) )
   {
  // DQ (11/27/2010): Added support for case sensitive and insensitive matching (for C/C++ and Fortran, respectively).
  // DQ (2/19/2007): Use a much larger size symbol table for the function types (the input value is the hash table size, which should be a prime number)!
  // p_function_type_table = new SgSymbolTable();
  // p_function_type_table = new SgSymbolTable(1001,case_insensitive);
     p_function_type_table = new SgSymbolTable();
     ROSE_ASSERT(p_function_type_table != NULL);

  // DQ (2/16/2006): Set this parent directly (now tested)
     p_function_type_table->set_parent(this);

  // Set the parent of the Sg_File_Info object
  // ROSE_ASSERT(get_file_info() != NULL);
     ROSE_ASSERT(get_startOfConstruct() != NULL);
  // get_file_info()->set_parent(this);
  // p_startOfConstruct->set_parent(this);
     this->get_startOfConstruct()->set_parent(this);

  // DQ (11/3/2007): The internal test like to see that both the startOfConstruct and endOfConstruct are set!
     this->set_endOfConstruct( new Sg_File_Info ("",0,0) );
     this->get_endOfConstruct()->set_parent(this);

  // DQ (11/27/2010): In retrospect I think that should should always be false!
  // Note that the function type table is global and could include translation 
  // units from both C/C++ and Fortran.
  // ROSE_ASSERT(case_insensitive == false);
   }

// DQ (2/19/2007): This appears to not be called but is here because 
// the ROSETTA code requires it (I think).
void
SgFunctionTypeTable::post_construction_initialization()
   {
   }

void
SgFunctionTypeTable::print_functypetable(std::ostream& os)
   {
  // printf ("ERROR: Sage $CLASSNAME::print_functypetable function called! \n");
  // abort();

     os << endl << "...FuncTypeTbl..." << endl;
  // p_function_type_table.print(os);

     ROSE_ASSERT(p_function_type_table != NULL);
  // p_function_type_table->print(os);
     p_function_type_table->print("Called from $CLASSNAME::print_functypetable");
   }

void
SgFunctionTypeTable::insert_function_type(const SgName& n, SgType *t)
   {
     ROSE_ASSERT (p_function_type_table != NULL);
     ROSE_ASSERT (t != NULL);

     SgFunctionTypeSymbol* newSymbol = new SgFunctionTypeSymbol(n,t);
     ROSE_ASSERT (newSymbol != NULL);
#if 0
     printf ("Inside of SgFunctionTypeTable::insert_function_type(SgName,SgType*): n = %s type = %s = %s \n",
          n.str(),t->sage_class_name(),t->unparseToString().c_str());
#endif
  // printf ("Is the qualified name being used! \n");
  // ROSE_ASSERT(false);

     p_function_type_table->insert(n, newSymbol);
  // p_function_type_table->insert(n, new SgFunctionTypeSymbol(n,t));
   }

// DQ (1/31/2007): Added support for removing function type symbols (used in AST merge)
void
SgFunctionTypeTable::remove_function_type(const SgName& n)
   {
     ROSE_ASSERT (p_function_type_table != NULL);
     p_function_type_table->remove_function_type(n);
   }

#if 0
// see if this is ever used!
void
SgFunctionTypeTable::insert_function_type(const SgFunctionDeclaration *fdecl)
   {
     assert(fdecl != NULL);
     printf ("Inside of SgFunctionTypeTable::insert_function_type(SgFunctionDeclaration = %s) \n",fdecl->get_name().str());
     SgFunctionType* type = isSgFunctionType(fdecl->get_type());
     ROSE_ASSERT(type != NULL);

     SgName n = type->get_mangled_type();
  // printf ("Using function name = %s  should be using qualified function type name \n",n.str());

     printf ("Looking up %s in function table \n",n.str());
     if (lookup_function_type(n) != NULL)
        {
          printf ("Found function %s (skip reinsertion) \n",n.str());
       // return; // DQ: no need for multiple return!
        }
       else
        {
       // printf ("Function NOT Found: so insert in table %s \n",n.str());
          insert_function_type(n,type);
        }
   }
#endif

SgType*
SgFunctionTypeTable::lookup_function_type(const SgName& n)
   {
  // printf ("In SgFunctionTypeTable::lookup_function_type: Looking for %s \n",n.str());
     ROSE_ASSERT (p_function_type_table != NULL);
  // SgFunctionTypeSymbol *fsymb = isSgFunctionTypeSymbol(p_function_type_table->findfunctype(n));
     SgSymbol *symbol = p_function_type_table->find_function_type(n);
     SgFunctionTypeSymbol *fsymb = isSgFunctionTypeSymbol(symbol);
     SgType* returnType = NULL;

     if (fsymb != NULL)
        {
          returnType = fsymb->get_type();
          ROSE_ASSERT(returnType != NULL);
       // printf ("In SgFunctionTypeTable::lookup_function_type(): found function type %s \n",returnType->class_name().c_str());
        }

     return returnType;
   }

SOURCE_FUNCTION_TYPE_TABLE_STATEMENT_END


SOURCE_GLOBAL_STATEMENT_START


// DQ (9/8/2004): Added to support qualified name generation
SgName
SgGlobal::get_qualified_name() const
   {
  // DQ (8/25/2005): This is the case where we previously names the global scope as "::"
  // within name qualification.  This was done to handle test2005_144.C but it broke
  // test2004_80.C So we have moved to an explicit marking of IR nodes using global scope
  // qualification (since it clearly seems to be required).
  // DQ (8/22/2005): Added global scope qualifier (see test2005_144.C) it is sometimes 
  // required to prevent base class types from being used instead of globally defined types.
  // Note that this will still evaluate so that "returnName.is_null()" will be true

  // DQ (10/11/2006): Under the new name qualification, we must traverse all the way
  // to global scope, and include global scope to get test2006_157.C correct.
  // return SgName ("");
     return SgName ("::");
   }

SgName
SgGlobal::get_mangled_name(void) const
   {
  // DQ (2/22/2007): This function is added to prevent "::" substrings in mangled names of other declarations.
  // DQ (3/12/2007): This is likely faster than using the mangled name map
     return SgName ("__global__");
   }

void
SgGlobal::post_construction_initialization()
   {
   }

void
SgGlobal::append_declaration(SgDeclarationStatement * what) 
   {
  // DQ (3/10/2007): Make sure that the statement does not already exist in the scope
  // It may be OK if is is marked explicitly as shared. Note that this is a linear time test.
#if 0
  // printf ("In SgGlobal::append_declaration(): what = %p = %s \n",what,what->class_name().c_str());
     if (find(get_declarations().begin(),get_declarations().end(),what) != get_declarations().end() && what->get_file_info()->isShared() == false)
        {
          printf ("Error: SgGlobal::append_declaration(): what = %p = %s \n",what,what->class_name().c_str());
          what->get_startOfConstruct()->display("statement does not already exists: debug");
        }

  // Since we have later error checking we don't require this here as it introduces a performance problem.
     ROSE_ASSERT(find(get_declarations().begin(),get_declarations().end(),what) == get_declarations().end() || what->get_file_info()->isShared() == true);
#endif

     get_declarations().push_back(what);
     what->set_parent(this);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

#if 1
void
SgGlobal::prepend_declaration(SgDeclarationStatement * what) 
   {
     get_declarations().insert(get_declarations().begin(), what);
     what->set_parent(this);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

#if 0
void
SgGlobal::insert_declaration ( const SgDeclarationStatementPtrList::iterator& where, SgDeclarationStatement* what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
#error "DEAD CODE"
     what->set_parent(this);
#endif
     what->set_parent(this);

     get_declarations().insert(where,what);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }
#endif
#endif

bool
SgGlobal::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, get_declarations(), target, newstmt, inFront, extractBasicBlock, false);
   }

bool 
SgGlobal:: replace_child(SgStatement *target ,SgStatement * newstmt, bool extractBasicBlock)
   {
     return  StatementListInsertChild( this, get_declarations(), target, newstmt, true, extractBasicBlock, true);
   }

#if 0
std::map<SgNode*,std::string> &
SgGlobal:: get_mangledNameCache()
   {
     return p_mangledNameCache;
   }

std::map<std::string, int> &
SgGlobal:: get_shortMangledNameCache()
   {
     return p_shortMangledNameCache;
   }
#endif

std::ostream & operator<< ( std::ostream & os, std::map<SgNode*,std::string> & x )
   {
  // printf ("Error: Not implemented, operator<< ( std::ostream & os, std::map<SgNode*,std::string> & x ) \n");
  // os << " pair (" << (*x).first.str() << "," << ((*x).second) << ")";

     os << "output operator for std::map<SgNode*,std::string> not implemented";
     return os;
   }

SOURCE_GLOBAL_STATEMENT_END

SOURCE_GLOBAL_STATEMENT_PARSER_START

// This is a specialized parse function for the $CLASSNAME class defined in Statement.code

// We include the "Sg" in the name of the parse function because we want each grammar's
// collection of overloaded parse functions to return the root node of that grammar.  Since multiple
// grammars exist we have to have different collections of overloaded parse functions return different
// types, and overloaded functions must return the same type (C++ language constraint).  The solution is to have
// the overloaded parse functions for each grammar share the names that are unique to that grammar only.
// thus we prefix the parse member function name with "Sg".


SgNode*
Sgparse ( $PARENT_GRAMMARS_PREFIX_Global* Xptr )
   {
  // Function description:
  // This function parses the lower level grammar into a higher level grammar

  // Specifics of this function:
  // We could bury the reference to the project into this function since their is only one global scope
  // Or we could pass the project as a parameter to this function (since it is the root of all program trees?)

     printf ("Inside of $CLASSNAME friend function Sgparse($PARENT_GRAMMARS_PREFIX_Global*) \n");

#if 0
  // This makes no sense 

  // Error checking
     ROSE_ASSERT(Xptr != NULL);
     ROSE_ASSERT(Xptr->getGrammar() != NULL);
     if (Xptr->getGrammar()->isRootGrammar() == true)
        {
       // it is an error for isRootGrammar() == true
          printf ("ERROR: isRootGrammar() == true in SgScopeStatement::parse ( $PARENT_GRAMMARS_PREFIX_ScopeStatement* X )! \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT(Xptr->getGrammar()->isRootGrammar() == false);
#endif

  // Later we will automate the generation of this code
  // $PARSE_CODE_FOR_LIST

     $PARENT_GRAMMARS_PREFIX__File_Info* parentGrammarFileInfo = Xptr->get_file_info();
     ROSE_ASSERT (parentGrammarFileInfo != NULL);
     Sg_File_Info* fileInfo = 
          new Sg_File_Info (parentGrammarFileInfo->get_filename(),
                                          parentGrammarFileInfo->get_line(),
                                          parentGrammarFileInfo->get_col());
     ROSE_ASSERT (fileInfo != NULL);

     $CLASSNAME* returnValuePtr = new $CLASSNAME(fileInfo);
     ROSE_ASSERT (returnValuePtr != NULL);

     printf ("Call to parse declarations in global scope! \n");

  // Only declarations are allows in the global scope
#if 1
     SgDeclarationStatementPtrList::iterator p = Xptr->get_declarations().begin();
     while(p != Xptr->get_declarations().end())
#else
     SgDeclarationStatementPtrList::iterator p = Xptr->get_declarations().begin();
     while(p != Xptr->get_declarations().end())
#endif
        {
       // parse the statement and see what sort of statement we get

          printf (".");

          ROSE_ASSERT( isSgDeclarationStatement(*p) != NULL );
       // SgDeclarationStatement* newstmt = returnValuePtr->parse (Xptr);

       // Comment this out for now while we get existing code debugged
#if 1
       // Each statement in the global scope is a declaration statement (but we want to consider 
       // that they could be an X_DeclarationStatement, so we assume they are all SgStatements
       // SgStatement* newstmt = Sgparse (*p);
       // But the return type of all parse functions is a SgNode pointer (so use that)
          SgNode* newstmt = Sgparse (*p);
          ROSE_ASSERT(newstmt != NULL);

          returnValuePtr->append_declaration( (SgDeclarationStatement*) newstmt );
#endif
          p++;
        }

     printf ("\nEnd of declarations \n");
     return returnValuePtr;
   }

SOURCE_GLOBAL_STATEMENT_PARSER_END


SOURCE_DECLARATION_STATEMENT_START

// DQ (12/21/2005): Build the static empty list to use as a default argument for the SgQualifiedNameType constructor
// SgQualifiedNamePtrList SgDeclarationStatement::p_defaultQualifiedNamePtrList;

SgQualifiedNamePtrList &
SgDeclarationStatement::get_qualifiedNameList()
   {
     return p_qualifiedNameList;
   }

const SgQualifiedNamePtrList &
SgDeclarationStatement::get_qualifiedNameList() const
   {
     return p_qualifiedNameList;
   }

void
SgDeclarationStatement::set_qualifiedNameList( const SgQualifiedNamePtrList & x )
   {
     p_qualifiedNameList = x;
   }

void
SgDeclarationStatement::post_construction_initialization()
   {}

// DQ (11/28/2009): Changed return type from "int" to "bool"
bool
SgDeclarationStatement::isForward() const 
   { return get_forward(); }

void
SgDeclarationStatement::setForward() 
   { set_forward(true); }

void
SgDeclarationStatement::unsetForward() 
   { set_forward(false); }

// DQ (11/28/2009): Changed return type from "int" to "bool"
bool
SgDeclarationStatement::isNameOnly() const 
   { return get_nameOnly(); }

void
SgDeclarationStatement::setNameOnly() 
   { set_nameOnly(true); }

void
SgDeclarationStatement::unsetNameOnly() 
   { set_nameOnly(false); }

// DQ (11/28/2009): Changed return type from "int" to "bool"
bool
SgDeclarationStatement::isExternBrace() const 
   { return get_externBrace(); }

void
SgDeclarationStatement::setExternBrace() 
   { set_externBrace(true); }

void
SgDeclarationStatement::unsetExternBrace() 
   { set_externBrace(false); }

// DQ (11/28/2009): Changed return type from "int" to "bool"
bool
SgDeclarationStatement::skipElaborateType() const 
   { return get_skipElaborateType(); }

void
SgDeclarationStatement::setSkipElaborateType() 
   { set_skipElaborateType(true); }

void
SgDeclarationStatement::unsetSkipElaborateType() 
   { set_skipElaborateType(false); }


void
SgDeclarationStatement::testForBadGenerateTemplateName( const std::string & name ) 
   {
  // DQ (2/20/2005): Error checking on existence of substrings that can be common
  // in building template name and which are a source of errors in generated code.
     if ( (name.find("<<") != string::npos) || (name.find(">>") != string::npos) )
        {
       // This could just be the input or output operators so make sure this is not that case!
          if ( (name.find("operator<<") == string::npos) && (name.find("operator>>") == string::npos) )
             {
            // OK, we have some sort of error to report!
               printf ("\n\n");
               printf ("Error: \"<<\" or \">>\" found in generated name, this could lead to an error in compiling the generated code later \n");
               printf ("..... name generated in processing a %s IR node \n",sage_class_name());
               printf ("..... generated name = %s \n",name.c_str());
               printf ("\n\n");
               ROSE_ASSERT (false);
            // ROSE_ASSERT (returnName.find("<<") == string::npos);
            // ROSE_ASSERT (returnName.find(">>") == string::npos);
             }
        }

  // Search for common substring of unconverted EDG generated typenames...
     if ( name.find("____") != string::npos )
        {
          printf ("Error: \"____\" found in ROSE generated type name = %s (likely and unconverted EDG name) \n",name.c_str());
          printf ("Error: SgDeclarationStatement (this) = %p = %s = %s \n",this,this->class_name().c_str(),SageInterface::get_name(this).c_str());
          get_file_info()->display("Error: likely and unconverted EDG name");
          ROSE_ASSERT (false);
        }
   }


bool
SgDeclarationStatement::skipEmptyTemplateArgumentListTest ( SgFunctionDeclaration* functionDeclaration )
   {
  // DQ (4/13/2005): Avoid output of empty lists of template arguments in function names
  // as in "endl<>" (which is a bug in g++ version 3.4, see test2005_55.C).  This
  // should only apply to function and member functions since they alone can skip the output of "<>".
  // What we do below is skip the "<" and ">" when the list of template arguments would be empty.
  // It would be empty when either there are no arguments or non were explicitly specified in the 
  // source code.

  // Note that this function can only be applied to functions (since only they are explicitly 
  // mark with if there template arguments are specified or not!)

     ROSE_ASSERT(functionDeclaration != NULL);

  // default is true, so empty lists are not output (could this be an error?)
     bool skipEmptyTemplateArgumentList = true;

     string functionName;
     SgTemplateArgumentPtrListPtr templateArgListPtr = NULL;

  // One or the other of these are valid pointers, but not both!
     SgTemplateInstantiationFunctionDecl       *templateInstantiationFunctionDeclaration       = 
          isSgTemplateInstantiationFunctionDecl(functionDeclaration);
     SgTemplateInstantiationMemberFunctionDecl *templateInstantiationMemberFunctionDeclaration = 
          isSgTemplateInstantiationMemberFunctionDecl(functionDeclaration);

     if (templateInstantiationFunctionDeclaration != NULL)
        {
          functionName       = templateInstantiationFunctionDeclaration->get_templateName().str();
          templateArgListPtr = &templateInstantiationFunctionDeclaration->get_templateArguments();
        }
       else
        {
          ROSE_ASSERT(templateInstantiationMemberFunctionDeclaration != NULL);
          functionName       = templateInstantiationMemberFunctionDeclaration->get_templateName().str();
          templateArgListPtr = &templateInstantiationMemberFunctionDeclaration->get_templateArguments();
        }

#if 0
     printf ("In skipEmptyTemplateArgumentListTest: Handling function name = %s \n",functionName.c_str());
#endif

     ROSE_ASSERT(templateArgListPtr != NULL);

     SgTemplateArgumentPtrList::const_iterator i = templateArgListPtr->begin();
     while (i != templateArgListPtr->end())
        {
#if 0
          printf ("templateArgList element *i = %s \n",(*i)->sage_class_name());
#endif

       // DQ (2/27/2005): Added support for output of only template arguments 
       // that were explicit in the source code.  Only meaningful for function 
       // and member function template arguments.
          bool templateArgumentWasExplicitlySpecified = (*i)->get_explicitlySpecified();
          bool outputTemplateArgument = false;
          if ( templateArgumentWasExplicitlySpecified == true )
             {
               outputTemplateArgument = true;
               skipEmptyTemplateArgumentList = false;
             }
          
#if 0
          printf ("outputTemplateArgument = %s \n",(outputTemplateArgument == true) ? "true" : "false");
#endif

          i++;
        }

#if 0
     printf ("skipEmptyTemplateArgumentList = %s \n",(skipEmptyTemplateArgumentList == true) ? "true" : "false");
#endif

     return skipEmptyTemplateArgumentList;
   }


void
resetTemplateNamesInScope ( SgScopeStatement* scope )
   {
  // DQ (8/11/2005): This function loops over all parent scopes to reset
  // any possibly unset names in instantiated templated classes.

  // DQ (2/10/2007): I hope we can assert this!
     ROSE_ASSERT(scope != NULL);

  // printf ("In resetTemplateNamesInScope: traversing through parent scopes (scope = %p = %s) \n",scope,scope->class_name().c_str());

     while ( scope != NULL && isSgGlobal(scope) == NULL )
        {
       // printf ("In resetTemplateNamesInScope(%s) \n",scope->class_name().c_str());

          switch(scope->variantT())
             {
               case V_SgFunctionDefinition:
                  {
                 // Nothing to do here, I think, unless we have to reset template function names
                    break;
                  }

               case V_SgGlobal:
               case V_SgBasicBlock:
               case V_SgCatchOptionStmt:
               case V_SgSwitchStatement:
               case V_SgIfStmt:
               case V_SgWhileStmt:
               case V_SgDoWhileStmt:
               case V_SgForStatement:
                  {
                 // Nothing to do here, I think, unless we have to reset template function names
                    break;
                  }

               case V_SgClassDefinition:
                  {
                    SgDeclarationStatement* parentDeclaration = NULL;
                    parentDeclaration = isSgClassDefinition(scope)->get_declaration();
                    ROSE_ASSERT(parentDeclaration != NULL);
                 // Nothing to do here!
                    break;
                  }

            // This turns out to be the only important case!
               case V_SgTemplateInstantiationDefn:
                  {
                    SgTemplateInstantiationDefn* defn = isSgTemplateInstantiationDefn(scope);
                    ROSE_ASSERT(defn != NULL);
                    ROSE_ASSERT(defn->get_declaration() != NULL);
                    SgTemplateInstantiationDecl *decl = isSgTemplateInstantiationDecl(defn->get_declaration());
                    ROSE_ASSERT(decl != NULL);
                    decl->resetTemplateName();
                    break;
                  }

               case V_SgNamespaceDefinitionStatement:
                  {
                    SgDeclarationStatement* parentDeclaration = NULL;
                    parentDeclaration = isSgNamespaceDefinitionStatement(scope)->get_namespaceDeclaration();
                    ROSE_ASSERT(parentDeclaration != NULL);
                 // Nothing to do here!
                    break;
                  }

               default:
                    printf ("Error: default reached in evaluation of scope within resetTemplateNamesInScope scope = %s \n",
                         scope->sage_class_name());
                    ROSE_ASSERT(false);
             }

          scope = scope->get_scope();
        }
   }



// DQ (2/15/2005): This is the former SgTemplateInstantitionDecl::resetTemplateName()
// member function.  It has been moved to a global supporting function so that similar
// support can be added to the SgTemplateInstantiationFunctionDecl and the 
// SgTemplateInstantiationMemberFunctionDecl IR nodes.  With this design function names
// are not known, except through their mangled names, until after the AST fixup phase.
// I think that this will not be an issue within ROSE.  
// Several input parameters are passed, these are the private variables within the 
// IR nodes.
// void $CLASSNAME::resetTemplateName ()
void
SgDeclarationStatement::resetTemplateNameSupport ( bool & nameResetFromMangledForm, SgName & name )
   {
  // This function generates the full template name (e.g. "ABC<int>") instead of the mangled name
  // stored in the p_name variable.  Note that the templateArguments must be defined, we can't
  // seem to just set this in the EDG interface since not all the pieces are in place as SAGE III
  // IR nodes. It resets the mangled name in p_name to the full template name.

  // DQ (9/27/2004) Note: This is the only place within the construction of the Sage III AST (from EDG)
  // where the unparser is called.  It is in general unsafe to do this and it may be that this should 
  // be reserved for after the Sage III AST is fully constructed and all post processing fixup 
  // (currently limited to setting all parent pointers) is complete.

     ROSE_ASSERT (this != NULL);
     string returnName;

#if 0
  // DQ (9/25/2007): Old test, no longer valid.
  // DQ (10/11/2004): Error checking for infinite recursion (just in case it could happen)
     static int counter = 0;
     if (counter > 10000)
        {
          printf ("resetTemplateNameSupport could be in endless recursion ... \n");
          ROSE_ASSERT(false);
        }
#endif

  // DQ (11/23/2004): Check any possible template declarations in higher-level scopes 
  // (in which this declaration may be nested).  Such unreset names show up in qualified 
  // names that may be generated.  Note that this should be an explicit loop over all 
  // parent scopes since any non-template parent scope would break the handling of all 
  // templates between here and the global scope!  Handle this case after we debug the 
  // current simpler case!
#if 0
     printf ("Implementation of resetTemplateNameSupport() requires loop over parent scopes!!! \n");
#endif

     SgScopeStatement* parentScope = get_scope();
#if 0
     printf ("In resetTemplateNameSupport(): At %s parentScope = %s \n",sage_class_name(),parentScope->sage_class_name());
#endif

  // DQ (2/10/2007): I hope we can assert this!
     ROSE_ASSERT(parentScope != NULL);

  // This function loops over all parent scopes
     resetTemplateNamesInScope(parentScope);

  // If the name has not been reset to the form "ABC<int>" then reset it now!
  // DQ (2/15/2005): Modified to reference input parameters
  // if (get_nameResetFromMangledForm() == false)
     if (nameResetFromMangledForm == false)
        {
       // returnName = get_templateName().str();
       // SgTemplateArgumentPtrListPtr templateArgListPtr = get_templateArguments();

          bool appendTemplateArguments   = true;

          bool skipEmptyTemplateArgumentList = false;

       // DQ (2/28/2005): function templates need to be separated out since for them the marker of being explicit make sense.
          bool functionTemplateArguments = false;
          SgTemplateArgumentPtrListPtr templateArgListPtr = NULL;
          switch(variantT())
             {
               case V_SgTemplateInstantiationDecl:
                  {
                    SgTemplateInstantiationDecl* node = isSgTemplateInstantiationDecl(this);
                    ROSE_ASSERT(node != NULL);
                    returnName         = node->get_templateName().str();
                    templateArgListPtr = &node->get_templateArguments();

                 // DQ (2/21/2005): Error checking on existence of substrings that can be common
                 // in building template name and which are a source of errors in generated code.
                    testForBadGenerateTemplateName(returnName);
                    break;
                  }

            // DQ (4/13/2005): Combine these two cases since they are identical (error: both cases must be separate!)
               case V_SgTemplateInstantiationFunctionDecl:
            // case V_SgTemplateInstantiationMemberFunctionDecl:
                  {
                    SgTemplateInstantiationFunctionDecl* node = isSgTemplateInstantiationFunctionDecl(this);
                    ROSE_ASSERT(node != NULL);
                    returnName         = node->get_templateName().str();
                    templateArgListPtr = &node->get_templateArguments();

                 // DQ (2/28/2005): function templates need to be separated out since for them the marker of being explicit make sense.
                    functionTemplateArguments = true;

                 // DQ (2/17/2005): We can't translate "operator+" into "operator+<int>" since it will become "+<int>" 
                 // in the unparser so make sure that this is not a name of an overloaded operator function.
                 // printf ("function name = %s \n",returnName.c_str());
                 // if (TransformationSupport::classifyOverloadedOperator(returnName) != TransformationSupport::FUNCTION_CALL_OPERATOR_CODE)
                    if (node->get_specialFunctionModifier().isOperator() == true)
                       {
                      // printf ("Skipping appending the templates arguments to this overloaded operator \n");
                         appendTemplateArguments = false;
                       }

                 // DQ (4/13/2005): Avoid output of empty template lists where not required (e.g. "std::endl<>" ).
                    skipEmptyTemplateArgumentList = skipEmptyTemplateArgumentListTest(node);

                 // DQ (2/21/2005): Error checking on existence of substrings that can be common
                 // in building template name and which are a source of errors in generated code.
                    testForBadGenerateTemplateName(returnName);
                    break;
                  }
#if 1
               case V_SgTemplateInstantiationMemberFunctionDecl:
                  {
                    SgTemplateInstantiationMemberFunctionDecl* node = isSgTemplateInstantiationMemberFunctionDecl(this);
                    ROSE_ASSERT(node != NULL);

                 // printf ("node = %p = (templateName) %s = (name) %s \n",node,node->get_templateName().str(),node->get_name().str());

                    returnName         = node->get_templateName().str();
                    templateArgListPtr = &node->get_templateArguments();

                 // DQ (2/28/2005): function templates need to be separated out since for them the marker of being explicit make sense.
                    functionTemplateArguments = true;

                 // DQ (2/17/2005): We can't translate "operator+" into "operator+<int>" since it will become "+<int>" 
                 // in the unparser so make sure that this is not a name of an overloaded operator function.
                 // printf ("member function name = %s \n",returnName.c_str());
                 // if (TransformationSupport::classifyOverloadedOperator(returnName) != TransformationSupport::FUNCTION_CALL_OPERATOR_CODE)
                    if (node->get_specialFunctionModifier().isOperator() == true)
                       {
                      // printf ("Skipping appending the templates arguments to this overloaded operator \n");
                         appendTemplateArguments = false;
                       }

                 // DQ (4/13/2005): Avoid output of empty template lists where not required (e.g. "std::endl<>" ).
                    skipEmptyTemplateArgumentList = skipEmptyTemplateArgumentListTest(node);

                 // DQ (2/21/2005): Error checking on existence of substrings that can be common
                 // in building template name and which are a source of errors in generated code.
                    testForBadGenerateTemplateName(returnName);
                    break;
                  }
#endif
               default:
                  {
                 // ... nothing to do here
                  }
             }

          ROSE_ASSERT(templateArgListPtr != NULL);

       // DQ (4/13/2005): Sometimes template parameters are present but were not specified in the source code and if so we 
       // should also not output "<>".  This is a stronger test than that implemented previously (fixes output of "std::endl<>" as well).
       // DQ (2/17/2005): We want to avoid "<>" appearing where template arguments are meant to be used (e.g. in function names)
       // if (templateArgListPtr != NULL)
       // if ( (appendTemplateArguments == true) && (templateArgListPtr->size() > 0) )
          if ( ( (appendTemplateArguments == true) && (templateArgListPtr->size() > 0) ) && (skipEmptyTemplateArgumentList == false) )
             {
#if 0
               printf ("In $CLASSNAME::resetTemplateName(): templateArgListPtr->size() = %zu \n",templateArgListPtr->size());
#endif

               returnName += " < ";
               SgTemplateArgumentPtrList::const_iterator i = templateArgListPtr->begin();
               while (i != templateArgListPtr->end())
                  {
#if 0
                    printf ("templateArgList element *i = %s \n",(*i)->sage_class_name());
#endif

                 // DQ (2/27/2005): Added support for output of only template arguments 
                 // that were explicit in the source code.  Only meaningful for function 
                 // and member function template arguments.
                    bool templateArgumentWasExplicitlySpecified = (*i)->get_explicitlySpecified();
                 // bool templateArgumentWasExplicitlySpecified = true;
                 // if (templateArgumentWasExplicitlySpecified == true)
                    bool outputTemplateArgument = false;
                    if ( (functionTemplateArguments == false) || 
                         ( (functionTemplateArguments == true) && (templateArgumentWasExplicitlySpecified == true) ) )
                       {
                         outputTemplateArgument = true;
                       }
#if 0
                    printf ("functionTemplateArguments = %s \n",(functionTemplateArguments == true) ? "true" : "false");
                    printf ("outputTemplateArgument = %s \n",(outputTemplateArgument == true) ? "true" : "false");
#endif
                    if (outputTemplateArgument == true)
                       {
                         ROSE_ASSERT( *i != NULL);
#if 0
                         printf ("In $CLASSNAME::resetTemplateName(): (*i)->get_argumentType() = %d \n",(*i)->get_argumentType());
#endif
                         switch((*i)->get_argumentType())
                            {
                              case SgTemplateArgument::argument_undefined:
                                 {
                                   printf ("Error: SgTemplateArgument::argument_undefined not allowed \n");
                                   ROSE_ASSERT(false);
                                   break;
                                 }
                              case SgTemplateArgument::type_argument:
                                 {
                                   ROSE_ASSERT((*i)->get_type() != NULL);
                                   SgType* argumentType = (*i)->get_type();
#if 0
                                   printf ("SgTemplateArgument::type_argument: argumentType = %p = %s \n",argumentType,argumentType->sage_class_name());
#endif
                                   switch(argumentType->variantT())
                                      {
                                        case V_SgClassType:
                                           {
                                          // DQ (10/13/2004): If this is a template declaration then we might have to reset its name
                                             SgClassType* classType = isSgClassType(argumentType);
                                          // printf ("Found a class declaration ... \n");
                                             SgDeclarationStatement* declaration = classType->get_declaration();
                                             ROSE_ASSERT(declaration != NULL);
                                             SgClassDeclaration* classDeclaration = isSgClassDeclaration(declaration);
                                             ROSE_ASSERT(classDeclaration != NULL);
                                             SgTemplateInstantiationDecl* templateClassDeclaration = isSgTemplateInstantiationDecl(classDeclaration);
                                             if (templateClassDeclaration != NULL)
                                                {
                                               // printf ("Found a template instantiation declaration  (call resetTemplateName) ... \n");
                                                  templateClassDeclaration->resetTemplateName();
                                                }
                                             break;
                                           }
                                        case V_SgTypedefType:
                                           {
                                             SgTypedefType* typedefType = isSgTypedefType(argumentType);
                                          // printf ("Found a typedef declaration ... \n");
                                             SgDeclarationStatement* declaration = typedefType->get_declaration();
                                             ROSE_ASSERT(declaration != NULL);
                                             SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(declaration);
                                             ROSE_ASSERT(typedefDeclaration != NULL);
                                             SgTemplateInstantiationDefn* defn = isSgTemplateInstantiationDefn(typedefDeclaration->get_scope());
                                             if (defn != NULL)
                                                {
                                               // If we start the resetTemplateName() function here in the parent scope of the typedef 
                                               // type's declaration then it should continue to call resetTemplateName() through the 
                                               // rest of the scopes to the root (global scope).  Unless there is a non-template in the
                                               // chain!  So I guess the code above must be an explicit loop over all parent scopes 
                                               // until we reach global scope!
                                                  SgTemplateInstantiationDecl* decl = isSgTemplateInstantiationDecl(defn->get_declaration());
                                                  ROSE_ASSERT(decl != NULL);
                                                  decl->resetTemplateName();
                                                }
                                             break;
                                           }

                                     // DQ (9/11/2005): Handle these cases together
                                        case V_SgPointerType:
                                        case V_SgModifierType:
                                        case V_SgReferenceType:
                                           {
                                          // Need to reach in and see if this is a template instantiation of a class type and then reset its name
                                          // SgModifierType* modifierType = isSgModifierType(argumentType);
                                          // ROSE_ASSERT(modifierType != NULL);
                                          // SgType* strippedType = modifierType->stripType();

                                          // printf ("Case of SgPointerType, SgModifierType, SgReferenceType \n");
#if 0
                                          // This passes by too many places where (within typedefs for example) template names could be reset
                                             SgType* strippedType = argumentType->stripType()
#else
                                          // Handle this explicitly so that we can see the full type chain (in case there is a unset template name in the chain!)
                                             SgType* currentType = argumentType;

                                             SgModifierType*  modType     = NULL;
                                             SgPointerType*   pointType   = NULL;
                                             SgReferenceType* refType     = NULL;
                                             SgArrayType*     arrayType   = NULL;
                                             SgTypedefType*   typedefType = NULL;

                                          // Loop through the chain of types (modifiers, references, pointers, array types, and typedefs
                                             while (true)
                                                {
                                                  if ( (modType = isSgModifierType(currentType)) )
                                                     {
                                                       currentType = modType->get_base_type();
                                                     }
                                                    else
                                                     {
                                                       if ( (refType = isSgReferenceType(currentType)) )
                                                          {
                                                            currentType = refType->get_base_type();
                                                          }
                                                         else
                                                          {
                                                            if ( (pointType = isSgPointerType(currentType)) )
                                                               {
                                                                 currentType = pointType->get_base_type();
                                                               }
                                                              else
                                                               {
                                                                 if ( (arrayType = isSgArrayType(currentType)) )
                                                                    {
                                                                      currentType = arrayType->get_base_type();
                                                                    }
                                                                   else
                                                                    {
                                                                   // DQ (6/21/2005): Added support for typedef types to be uncovered by findBaseType()
                                                                      if ( (typedefType = isSgTypedefType(currentType)) )
                                                                         {
                                                                           currentType = typedefType->get_base_type();
                                                                         }
                                                                        else
                                                                         {
                                                                        // Exit the while(true){} loop!
                                                                           break;
                                                                         }
                                                                    }
                                                               }
                                                          }
                                                     }

                                               // printf ("In resetTemplateName: stripping type - currentType = %s hidden behind this = %s \n",
                                               //      currentType->sage_class_name(),argumentType->sage_class_name());

                                               // Check all typedefs that we find along the way (in this while loop through the modifiers)!
                                                  if (typedefType != NULL)
                                                     {
#if 1
                                                       SgDeclarationStatement* likelyTypedefDeclaration = typedefType->get_declaration();
                                                       ROSE_ASSERT( likelyTypedefDeclaration != NULL);
                                                       SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(likelyTypedefDeclaration);
                                                       ROSE_ASSERT( typedefDeclaration != NULL);
                                                    // printf ("In resetTemplateName: In loop over typedefs, modifiers, etc. found a typedef = %s \n",typedefDeclaration->get_name().str());
#endif
                                                       SgType* baseType = typedefType->get_base_type();
                                                       ROSE_ASSERT(currentType == baseType);
                                                       ROSE_ASSERT(baseType != NULL);
                                                       SgClassType* classType = isSgClassType(baseType);
                                                       if (classType != NULL)
                                                          {
                                                         // printf ("In loop over typedefs, modifiers, etc. found a class type \n");
                                                            SgDeclarationStatement* declaration = classType->get_declaration();
                                                            ROSE_ASSERT(declaration != NULL);
                                                            SgTemplateInstantiationDecl* classTemplateInstantiation = isSgTemplateInstantiationDecl(declaration);
                                                            if (classTemplateInstantiation != NULL)
                                                               {
                                                              // printf ("Found a instantiated class template inside the class type (resetting name = %s) \n",
                                                              //      classTemplateInstantiation->get_name().str());
                                                                 classTemplateInstantiation->resetTemplateName();
                                                               }
                                                          }

                                                    // ROSE_ASSERT(typedefType->get_declaration() != NULL);
                                                    // ROSE_ASSERT(isSgTypedefDeclaration(typedefType->get_declaration()) != NULL);
                                                    // SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(typedefType->get_declaration());
                                                       SgScopeStatement* typedefScope = typedefDeclaration->get_scope();
                                                       ROSE_ASSERT(typedefScope != NULL);
                                                    // printf ("In resetTemplateName: traversing through parent scopes to resent any instantiated template names \n");
                                                       resetTemplateNamesInScope(typedefScope);
                                                     }

                                               // reset these to NULL (to avoid saving a history, this allows the typedefType to be checked)
                                                  modType     = NULL;
                                                  refType     = NULL;
                                                  pointType   = NULL;
                                                  arrayType   = NULL;
                                                  typedefType = NULL;
                                                }

                                             SgType* strippedType = currentType;
#endif
                                             ROSE_ASSERT(strippedType != NULL);
                                             SgClassType* classType = isSgClassType(strippedType);
                                             if (classType != NULL)
                                                {
                                               // printf ("Found a class type \n");
                                                  SgDeclarationStatement* declaration = classType->get_declaration();
                                                  ROSE_ASSERT(declaration != NULL);
                                                  SgTemplateInstantiationDecl* classTemplateInstantiation = isSgTemplateInstantiationDecl(declaration);
                                                  if (classTemplateInstantiation != NULL)
                                                     {
                                                    // printf ("Found a instantiated class template inside the class type (resetting name = %s) \n",
                                                    //      classTemplateInstantiation->get_name().str());
                                                       classTemplateInstantiation->resetTemplateName();
                                                     }
                                                }
                                             break;
                                           }

                                     // DQ (8/29/2009): Added SgArrayType to eliminate error message about 
                                     // default being reached (missed including this type previously).
                                        case V_SgArrayType:

                                     // DQ (2/28/2005): List of types used in compiling Kull
                                        case V_SgTypeChar:
                                        case V_SgTypeWchar:
                                        case V_SgTypeBool:
                                        case V_SgTypeSignedChar:
                                        case V_SgTypeUnsignedChar:
                                        case V_SgTypeShort:
                                        case V_SgTypeUnsignedShort:
                                        case V_SgTypeUnsignedInt:
                                        case V_SgTypeLong:
                                        case V_SgTypeUnsignedLong:
                                        case V_SgTypeLongLong:
                                        case V_SgTypeUnsignedLongLong:
                                        case V_SgTypeFloat:
                                        case V_SgTypeDouble:
                                        case V_SgTypeLongDouble:
                                        case V_SgTypeVoid:
                                        case V_SgTypeInt:
                                        case V_SgEnumType:
                                           {
                                          // Nothing to do here with these primitive types (listed explicitly to avoid compiler warnings)
                                             break;
                                           }

                                         default:
                                           {
                                             printf ("Default reached in switch over SgTemplateArgument::type_argument (argumentType = %p = %s) \n",argumentType,argumentType->sage_class_name());
                                          // ROSE_ASSERT(false);
                                           }
                                      }
                                   break;
                                 }

                              case SgTemplateArgument::nontype_argument:
                                 {
                                // These can be boolean or integer values, for example.
                                   ROSE_ASSERT((*i)->get_expression() != NULL);
#if 0
                                   SgExpression* argumentExpression = (*i)->get_expression();
                                   printf ("SgTemplateArgument::nontype_argument: argumentExpression = %p = %s \n",
                                        argumentExpression,argumentExpression->sage_class_name());
#endif
                                   break;
                                 }

                              case SgTemplateArgument::template_template_argument:
                                 {
                                // DQ (8/24/2006): This is not a name that needs to be reset,
                                // so I think there is nothing to do here!
                                   ROSE_ASSERT((*i)->get_templateDeclaration() != NULL);

                                // printf ("Warning: SgTemplateArgument::template_template_argument not implemented \n");
                                // ROSE_ASSERT(false);
                                   break;
                                 }

                              default:
                                 {
                                   printf ("Default reached in switch over (*i)->get_argumentType() = %d \n",(*i)->get_argumentType());
                                   ROSE_ASSERT(false);
                                 }
                            }

                      // DQ (2/21/2005): Error checking on existence of substrings that can be common
                      // in building template name and which are a source of errors in generated code.
                         testForBadGenerateTemplateName(returnName);

                      // DQ (2/28/2005): Pass in an explicit unparse info object to control (and turn off) the 
                      // unparsing of definitions within the unparsing of types used as template arguments.
                      // This avoids generation of bad code like "x6.foo<const enum values {zero,nonzero}>();"
                      // (see test2005_13.C for details on this bug).
                         SgUnparse_Info unparseInfo;
                         unparseInfo.set_SkipDefinition();
                         ROSE_ASSERT (unparseInfo.SkipDefinition() == true);

                      // DQ (2/28/2005): Set these to be consistent with unparseToString
                      // Skip all comments in unparsing
                         unparseInfo.set_SkipComments();
                         ROSE_ASSERT (unparseInfo.SkipComments() == true);
                      // Skip all whitespace in unparsing (removed in generated string)
                         unparseInfo.set_SkipWhitespaces();
                         ROSE_ASSERT (unparseInfo.SkipWhitespaces() == true);

                      // Skip all directives (macros are already substituted by the front-end, so this has no effect on those)
                         unparseInfo.set_SkipCPPDirectives();
                         ROSE_ASSERT (unparseInfo.SkipCPPDirectives() == true);

                      // DQ (6/9/2007): Set the scope from which the name qualification for the template arguments should be computed!
                         ROSE_ASSERT(*i != NULL);
                         SgScopeStatement* localScope = (*i)->get_scope();
                         unparseInfo.set_current_scope(localScope);

                      // DQ (2/28/2005): Call globalUnparseToString() so tht we can specify 
                      // greater control over unparsing.
                      // DQ (10/12/2004): This can be called now the this function is called after the 
                      // post-processing fixup of the parent nodes in the AST (after the EDG/Sage III translation).
                      // This simplifies the implementation and permits the unparser to call the functions 
                      // required to generate qualified names (which require that the parent pointers be set).
                      // returnName += (*i)->unparseToString(unparseInfo);

                      // printf ("Before globalUnparseToString: returnName = %s \n",returnName.c_str());
                         returnName += globalUnparseToString(*i,&unparseInfo);
                      // printf ("After globalUnparseToString: returnName = %s \n",returnName.c_str());

                      // DQ (2/21/2005): Error checking on existence of substrings that can be common
                      // in building template name and which are a source of errors in generated code.
                         testForBadGenerateTemplateName(returnName);
                       }

                 // DQ (2/27/2005): Added support for output of only template arguments 
                 // that were explicit in the source code.
                 // if (templateArgumentWasExplicitlySpecified == true)
                    if (outputTemplateArgument == true)
                       {
                      // Increment to next template argument
                         i++;

                         if (i != templateArgListPtr->end())
                            returnName += " , ";
                       }
                      else
                       {
                      // Increment to next template argument
                         i++;
                       }
                  }

            // Close off the template argument list
               returnName += " > ";

#if 0
            // DQ (2/20/2005): Error checking on existence of substrings that can be common
            // in building template name and which are a source of errors in generated code.
               if ( (returnName.find("<<") != string::npos) || (returnName.find(">>") != string::npos) )
                  {
                    printf ("returnName = %s \n",returnName.c_str());
                  }
               ROSE_ASSERT (returnName.find("<<") == string::npos);
               ROSE_ASSERT (returnName.find(">>") == string::npos);
#endif
             }
            else
             {
            // DQ (2/17/2005): This can be the case of a member function of a templated class which 
            // would of course not have any template arguments specific to it as a function.
            // printf ("Error in resetTemplateName(): No valid template argument list \n");
            // ROSE_ASSERT(false);
             }

       // printf ("In SgDeclarationStatement::resetTemplateNameSupport(): Output the symbol table for scope = %p = %s: \n",parentScope,parentScope->class_name().c_str());
       // SageInterface::outputLocalSymbolTables(parentScope);
#if 0
       // DQ (2/10/2007): Unload the associated symbol using the old name and reload it into the symbol table using the new name!
          printf ("\n\nCalling this->get_symbol_from_symbol_table() on %s parentScope = %p = %s name = %s count = %ld \n",
               this->class_name().c_str(),parentScope,parentScope->class_name().c_str(),name.str(),parentScope->count_symbol(name));
          printf ("     this = %p = %s definingDeclaration         = %p \n",this,this->class_name().c_str(),this->get_definingDeclaration());
          printf ("     this = %p = %s firstNondefiningDeclaration = %p \n",this,this->class_name().c_str(),this->get_firstNondefiningDeclaration());
          const SgTemplateInstantiationDecl* templateInstantiation = isSgTemplateInstantiationDecl(this);
          if (templateInstantiation != NULL)
             {
               printf ("templateInstantiation->get_name()  = %s get_templateName() = %s \n",templateInstantiation->get_name().str(),templateInstantiation->get_templateName().str());
               printf ("templateInstantiation->get_scope() = %p = %s \n",templateInstantiation->get_scope(),templateInstantiation->get_scope()->class_name().c_str());
             }
          const SgTemplateInstantiationFunctionDecl* templateInstantiationFunction = isSgTemplateInstantiationFunctionDecl(this);
          if (templateInstantiationFunction != NULL)
             {
               printf ("templateInstantiationFunction->get_name()  = %s get_templateName() = %s \n",templateInstantiationFunction->get_name().str(),templateInstantiationFunction->get_templateName().str());
               printf ("templateInstantiationFunction->get_scope() = %p = %s \n",templateInstantiationFunction->get_scope(),templateInstantiationFunction->get_scope()->class_name().c_str());
             }
          const SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunction = isSgTemplateInstantiationMemberFunctionDecl(this);
          if (templateInstantiationMemberFunction != NULL)
             {
               printf ("templateInstantiationMemberFunction->get_name()  = %s get_templateName() = %s \n",templateInstantiationMemberFunction->get_name().str(),templateInstantiationMemberFunction->get_templateName().str());
               printf ("templateInstantiationMemberFunction->get_scope() = %p = %s \n",templateInstantiationMemberFunction->get_scope(),templateInstantiationMemberFunction->get_scope()->class_name().c_str());
             }
#endif
          SgSymbol* symbol = this->get_symbol_from_symbol_table();
          if (symbol == NULL)
             {
            // If searching for the old name returned a null symbol pointer then make sure that there is an entry for the new name
            // printf ("Searching for returnName = %s \n",returnName.c_str());
#if 0
               if (parentScope->count_symbol(returnName) >= 1)
                  {
                    printf ("Warning: symbol for returnName = %s is already in the symbol table but not associated with this = %p = %s count = %ld \n",
                         returnName.c_str(),this,this->class_name().c_str(),parentScope->count_symbol(returnName));
                    printf ("     (count too large) this = %p = %s this->get_definingDeclaration()         = %p \n",this,this->class_name().c_str(),this->get_definingDeclaration());
                    printf ("     (count too large) this = %p = %s this->get_firstNondefiningDeclaration() = %p \n",this,this->class_name().c_str(),this->get_firstNondefiningDeclaration());
                  }
#endif
            // ROSE_ASSERT(parentScope->count_symbol(returnName) >= 1);
#if 0
               printf ("There are a number of reasons why we could not have a valid symbol at this point: (parentScope = %p = %s = %s) \n",
                    parentScope,parentScope->class_name().c_str(),SageInterface::get_name(parentScope).c_str());
               printf ("   1) template used as base class in SgCtorInitializerList \n");
               printf ("   2) template used as in a type \n");
               printf ("   3) Either the processing of the defining or non-defining declaration already removed the symbol using the old name \n");
               printf ("******************** START **********************\n");
               printf ("In SgDeclarationStatement::resetTemplateNameSupport(): Output the symbol table for scope = %p = %s: \n",parentScope,parentScope->class_name().c_str());
               SageInterface::outputLocalSymbolTables(parentScope);
               printf ("******************** DONE ***********************\n");
#endif
             }
            else
             {
            // Remove the symbol (previously inserted under the old name and hashed accordingly) 
            // so that we can reinsert it into the symbol table after we change the name.
#if 0
               printf ("Removing the symbol = %p = %s name = %s from scope %p = %s \n",symbol,symbol->class_name().c_str(),name.str(),parentScope,parentScope->class_name().c_str());
               SgClassSymbol* classSymbol = isSgClassSymbol(symbol);
               if (classSymbol != NULL)
                  {
                    printf ("classSymbol->get_declaration() = %p = %s name = %s \n",classSymbol->get_declaration(),classSymbol->get_declaration()->class_name().c_str(),classSymbol->get_declaration()->get_name().str());
                  }
               SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(symbol);
               if (functionSymbol != NULL)
                  {
                    printf ("functionSymbol->get_declaration() = %p = %s name = %s \n",functionSymbol->get_declaration(),functionSymbol->get_declaration()->class_name().c_str(),functionSymbol->get_declaration()->get_name().str());
                  }
               SgMemberFunctionSymbol* memberFunctionSymbol = isSgMemberFunctionSymbol(symbol);
               if (memberFunctionSymbol != NULL)
                  {
                    printf ("memberFunctionSymbol->get_declaration() = %p = %s name = %s \n",memberFunctionSymbol->get_declaration(),memberFunctionSymbol->get_declaration()->class_name().c_str(),memberFunctionSymbol->get_declaration()->get_name().str());
                  }
#endif
#if 0
               printf ("In SgDeclarationStatement::resetTemplateNameSupport(): removing symbol = %p = %s for symbol_basis = %p = %s \n",
                    symbol,symbol->class_name().c_str(),symbol->get_symbol_basis(),symbol->get_symbol_basis()->class_name().c_str());
#endif
            // ROSE_ASSERT(false);

               parentScope->remove_symbol(symbol);
             }

       // DQ (2/15/2005): Modified to reference input parameters ("name" is an input parameter to this function!)
       // set_name( returnName.c_str());
          name = returnName.c_str();
       // DQ (2/10/2007): If we have a symbol then reinsert it into the symbol table using the new name
          if (symbol != NULL)
             {
            // printf ("Inserting the symbol = %p = %s name = %s from scope %p = %s \n",symbol,symbol->class_name().c_str(),name.str(),parentScope,parentScope->class_name().c_str());
               parentScope->insert_symbol(name,symbol);
#if 0
               printf ("In SgDeclarationStatement::resetTemplateNameSupport(): Output the symbol table: \n");
               SageInterface::outputLocalSymbolTables(parentScope);
#endif
             }
       // DQ (2/15/2005): Modified to reference input parameters
       // DQ (10/11/2004): Removed call to unparser since it often requires that the parents
       // be set.  Now we have to mark this template as no longer containing a mangled name
       // set_nameResetFromMangledForm(true);
          nameResetFromMangledForm = true;

       // DQ (2/20/2005): Error checking on existence of substrings that can be common
       // in building template name and which are a source of errors in generated code.
          testForBadGenerateTemplateName(returnName);
        }
   }

// This is a local file scope (support) function
static void
stringSupport ( string & sourceString, const string & targetString, const string & replacementString )
   {
     if (sourceString.find(targetString) != string::npos)
        {
          sourceString.replace(sourceString.find(targetString),targetString.size(),replacementString);
        }
   }

// SgName $CLASSNAME::fixupTemplateNameForMangledNameSupport( const SgName & name) const
// static SgName fixupTemplateNameForMangledNameSupport( const SgName & name)
SgName $CLASSNAME::fixupTemplateNameForMangledNameSupport( const SgName & name) const
   {
  // Where template names are reset to the form "foo < int >" we can look for just
  // the " < " and " > " substrings which are guaranteed to exist by construction!
     string s = name.str();

  // printf ("In fixupTemplateNameForMangledNameSupport(): Before filtering s = %s \n",s.c_str());

  // Now remove any spaces (since we can't have spaces in mangled names)
     while (s.find(" ") != string::npos)
        {
          s.replace(s.find(" "),1,"");
        }

  // To safely fixup all template syntax (e.g. "<x>") to remove the "<" and ">" we have to take care to not 
  // change the name of any operator (such as "operator<<", "operator>>", "operator<", "operator>", 
  // "operator<=", and "operator>="
  // Note that this is a current bug for:
  // __copy_backward_dispatch<std::vector <int,std::allocator<int>>::value_type*,std::vector<int,std::allocator<int>>::value_type*,__type_traits<int>::has_trivial_assignment_operator>

#if 0
     if (s.find("_operator>") != string::npos)
        {
          printf ("This name constains the substring \"_operator>\" which will not be translated into a mangled name correctly! \n");
          printf ("   Original name = %s \n",s.c_str());
       // ROSE_ASSERT(false);
        }
#endif

  // DQ (6/22/2005): Special case handling for substring "_operator>"
     stringSupport (s,"_operator>","_operator?");

     stringSupport (s,"operator>>","operator??");
     stringSupport (s,"operator<<","operator$$");
     stringSupport (s,"operator>","operator?");
     stringSupport (s,"operator<","operator$");
     stringSupport (s,"operator*","operator@");

     string templateMarkerStart = "<";
     int length = templateMarkerStart.size();
     while (s.find(templateMarkerStart) != string::npos)
        {
       // s.replace(s.find(templateMarkerStart),3,"__templateArgs__");
          s.replace(s.find(templateMarkerStart),length,"__tas__"); // Template Arguments Start (TAS)
        }

     string templateMarkerEnd   = ">";
     length = templateMarkerEnd.size();
     while (s.find(templateMarkerEnd) != string::npos)
        {
       // s.replace(s.find(templateMarkerEnd),3,"__");
          s.replace(s.find(templateMarkerEnd),length,"__tae__"); // Template Arguments End (TAE)
        }

     string scopeOperator       = "::";
     length = scopeOperator.size();
     while (s.find(scopeOperator) != string::npos)
        {
          s.replace(s.find(scopeOperator),length,"__scope__"); // replace scope operator in qualified names
        }

     string commaSeparator      = ",";
     length = commaSeparator.size();
     while (s.find(commaSeparator) != string::npos)
        {
          s.replace(s.find(commaSeparator),length,"__comma__"); // replace the comma separator between template arguments
        }

     string referenceMarker     = "&";
     length = referenceMarker.size();
     while (s.find(referenceMarker) != string::npos)
        {
          s.replace(s.find(referenceMarker),length,"__ref__"); // replace the comma separator between template arguments
        }

     string pointerMarker       = "*";
     length = pointerMarker.size();
     while (s.find(pointerMarker) != string::npos)
        {
          s.replace(s.find(pointerMarker),length,"__ptr__"); // replace the comma separator between template arguments
        }

  // DQ (8/10/2005): This is a fix for a bug where a "-" shows up in some template 
  // arguments within names generated from compiling boost (boost/mpl/if.hpp).
  // I think that is shows up with "-1" is passed as an argument to a template.
     string minusMarker         = "_-";
     length = minusMarker.size();
     while (s.find(minusMarker) != string::npos)
        {
          s.replace(s.find(minusMarker),length,"__minus__"); // replace the minus operator between template arguments
        }

  // DQ (6/22/2005): Special case handling for substring "_operator>"
     stringSupport (s,"_operator?","_operator__tae__");

     stringSupport (s,"operator??","operator>>");
     stringSupport (s,"operator$$","operator<<");
     stringSupport (s,"operator?","operator>");
     stringSupport (s,"operator$","operator<");
     stringSupport (s,"operator@","operator*");

  // Now remove any spaces (since we can't have spaces in mangled names)
     while (s.find(" ") != string::npos)
        {
          s.replace(s.find(" "),1,"");
        }

  // printf ("In fixupTemplateNameForMangledNameSupport(): after filtering s = %s \n",s.c_str());

     ROSE_ASSERT (s.find("::") == string::npos);
     if (s.find(":") != string::npos)
        {
       // sleep(2);
          printf ("Error: failed test for embedded \":\" in template name = %s \n",s.c_str());
        }
     ROSE_ASSERT (s.find(":") == string::npos);
     ROSE_ASSERT (s.find(",") == string::npos);

     return s;
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgDeclarationStatement::get_mangled_name(void) const
   {
  // printf ("In $CLASSNAME::get_mangled_name() name = %s \n",SageInterface::get_name(this).c_str());

     SgName returnName;

     returnName = "Not_yet_defined_mangled_name";

     printf ("Warning: mangled name for %s not yet defined, base class SgDeclarationStatement::get_mangled_name called \n",class_name().c_str());
     ROSE_ASSERT(false);

     return returnName;
   }

SgName
SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration_in_scope ( SgScopeStatement* scope ) const
   {
     SgName name;

     ROSE_ASSERT(scope != NULL);

  // First setup the prefix for the generated name
     switch (scope->variantT())
        {
          case V_SgGlobal:
             {
            // Some unnamed declarations can appear in global scope and we have to figure out how 
            // to assign them unique names.  See the examples for each case below.
            // SgGlobal* definition = isSgGlobal(parent);

               name = string("unnamed_class_declaration_in_global_definition_");
               break;
             }
             
          case V_SgClassDefinition:
             {
               name = string("unnamed_class_declaration_in_class_definition_");
               break;
             }

          case V_SgTemplateInstantiationDefn:
             {
               name = string("unnamed_class_declaration_in_class_template_definition_");
               break;
             }
             
          case V_SgBasicBlock:
             {
               name = string("unnamed_class_declaration_in_basic_block_");
               break;
             }

          case V_SgNamespaceDefinitionStatement:
             {
               SgNamespaceDefinitionStatement* definition = isSgNamespaceDefinitionStatement(scope);
            // It might be overkill to us the mangled name here
               name = string("unnamed_declaration_in_namespace_definition_") + definition->get_mangled_name();
#if 0
               printf ("This case should be implemented the same as for the SgGlobal case above \n");
               ROSE_ASSERT(false);
#endif
               break;
             }

          default:
             {
               printf ("Default reached in unnamed declaration within parent = %p = %s \n",scope,scope->class_name().c_str());
               get_file_info()->display("Error: location of problem unnamed SgClassDeclaration");
               ROSE_ASSERT(scope->get_file_info() != NULL);
               scope->get_file_info()->display("Error: location of problem unnamed SgClassDeclaration");
               ROSE_ASSERT(false);
             }

        }

  // Now generate the unique string for the declaration (use the data/enum members where possible)
     switch(variantT())
        {
          case V_SgClassDeclaration:
             {
            // case of "class { int x; }; in global scope
               const SgClassDeclaration* classDeclaration = isSgClassDeclaration(this);
               ROSE_ASSERT(classDeclaration != NULL);
               const SgClassDefinition* classDefinition = isSgClassDefinition(this);
            // ROSE_ASSERT(classDefinition != NULL);
               if (classDefinition != NULL)
                  {
                    name = name + "defining_declaration";
                    const SgDeclarationStatementPtrList & l = classDefinition->get_members();
                    SgDeclarationStatementPtrList::const_iterator i = l.begin();
                    while (i != l.end())
                       {
                      // name += (*i)->get_name() + "_class_member_";
                         name += (*i)->get_mangled_name() + "_class_member_";
                         i++;
                       }
                  }
                 else
                  {
                    name = name + "nondefining_declaration";
                  }
               break;
             }

          case V_SgEnumDeclaration:
             {
            // case of "enum { x,y,z; }; in global scope
               name = string("unnamed_enum_declaration_in_global_definition_");

               const SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(this);
               ROSE_ASSERT(enumDeclaration != NULL);
               const SgInitializedNamePtrList & l = enumDeclaration->get_enumerators();
               SgInitializedNamePtrList::const_iterator i = l.begin();
               while (i != l.end())
                  {
                    name += (*i)->get_name() + "_enum_field_";
                    i++;
                  }
               break;
             }

          default:
             {
               printf ("Default reached in SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration_in_scope (this = %p = %s) \n",
                    this,class_name().c_str());
               break;
             }
        }

  // printf ("SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration_in_scope() returning name = %s \n",name.str());

     return name;
   }

SgName
SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration ( SgNode* parent ) const
   {
  // This function generates a name for a class, enum, or typedef (maybe) where the declaration 
  // is not provided a name in the source code.  Examples include:
  //    typedef struct { int state;} my_struct_typedef;
  //    typedef enum { zero_enum_in_typedef } mynumbers_typedef;
  //    class { int x } variable_from_anonymous_class_declaration;
  //    enum { zero_enum_field } mynumbers_enum;
  // Without this feature different classes can be mangled to the same (empty) names.

     ROSE_ASSERT(parent != NULL);

     SgName name;

     switch (parent->variantT())
        {
          case V_SgVariableDeclaration:
             { 
            // SgVariableDeclaration::p_variableDeclarationContainsBaseTypeDefiningDeclaration should also be true, I think.
               SgVariableDeclaration* declaration = isSgVariableDeclaration(parent);
            // It might be overkill to us the mangled name here
               name = string("unnamed_declaration_in_variable_declaration_") + declaration->get_mangled_name();
               break;
             }

          case V_SgTypedefDeclaration:
             {
            // SgTypedefDeclaration::p_typedefBaseTypeContainsDefiningDeclaration should also be true, I think.
               SgTypedefDeclaration* declaration = isSgTypedefDeclaration(parent);
            // It might be overkill to us the mangled name here
               name = string("unnamed_declaration_in_typedef_declaration_") + declaration->get_mangled_name();
               break;
             }

          case V_SgGlobal:
          case V_SgBasicBlock:
          case V_SgClassDefinition:
          case V_SgTemplateInstantiationDefn:
          case V_SgNamespaceDefinitionStatement:
             {
            // Some unnamed declarations can appear in global scope and we have to figure out how 
            // to assign them unique names.  See the examples for each case below.
            // printf ("Unnamed declaration appears in a scope (instead of another declaration) \n");
               SgScopeStatement* scope = isSgScopeStatement(parent);
               ROSE_ASSERT(scope != NULL);
               name = SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration_in_scope(scope);
               break;
             }

          default:
             {
               printf ("Default reached in un-named declaration within parent = %p = %s \n",parent,parent->class_name().c_str());
               get_file_info()->display("Error: location of problem un-named SgClassDeclaration");
               ROSE_ASSERT(parent->get_file_info() != NULL);
               parent->get_file_info()->display("Error: location of problem un-named SgClassDeclaration");
               ROSE_ASSERT(false);
             }
        }

  // printf ("SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration() returning name = %s \n",name.str());

     return name;
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgDeclarationStatement::get_symbol_from_symbol_table() const
   {
     printf ("Error: virtual function SgDeclarationStatement::get_symbol_from_symbol_table() called on base class SgDeclarationStatement this = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);
     return NULL;
   }

SgSymbol*
SgDeclarationStatement::search_for_symbol_from_symbol_table() const
   {
     SgDeclarationStatement* declaration = get_declaration_associated_with_symbol();
     if (declaration == NULL)
        {
          printf ("Error: in SgDeclarationStatement::search_for_symbol_from_symbol_table(): declaration == NULL \n");
          printf ("     this = %p = %s = %s \n",this,this->class_name().c_str(),SageInterface::get_name(this).c_str());
        }
     ROSE_ASSERT(declaration != NULL);
     SgSymbol* symbol = declaration->get_symbol_from_symbol_table();
     ROSE_ASSERT(symbol != NULL);
     return symbol;
   }

// DQ (7/4/2007): Search for the declaration that would identify the associated symbol
SgDeclarationStatement*
SgDeclarationStatement::get_declaration_associated_with_symbol() const
   {
#if 0
     SgScopeStatement* scope = this->get_scope();
     printf ("In get_declaration_associated_with_symbol(): this = %p = %s = %s scope = %p = %s \n",
          this,this->class_name().c_str(),SageInterface::get_name(this).c_str(),scope,scope->class_name().c_str());
     printf ("this = %p this->get_firstNondefiningDeclaration() = %p this->get_definingDeclaration() = %p \n",
          this,this->get_firstNondefiningDeclaration(),this->get_definingDeclaration());
     printf ("this->get_symbol_from_symbol_table() = %p this->get_firstNondefiningDeclaration()->get_symbol_from_symbol_table() = %p this->get_definingDeclaration()->get_symbol_from_symbol_table() = %p \n",
          this->get_symbol_from_symbol_table(),
          this->get_firstNondefiningDeclaration() != NULL ? this->get_firstNondefiningDeclaration()->get_symbol_from_symbol_table() : NULL,
          this->get_definingDeclaration() != NULL ? this->get_definingDeclaration()->get_symbol_from_symbol_table() : NULL);
#endif

     ROSE_ASSERT(this != NULL);

     SgDeclarationStatement* declarationAssociatedWithSymbol = NULL;
     declarationAssociatedWithSymbol = this->get_firstNondefiningDeclaration();

  // Else it used the defining declaration
     if (declarationAssociatedWithSymbol == NULL)
        {
          declarationAssociatedWithSymbol = this->get_definingDeclaration();
       // declarationAssociatedWithSymbol = this->get_firstNondefiningDeclaration();
       // printf ("this->get_firstNondefiningDeclaration() == NULL so use definingDeclaration = %p \n",declarationAssociatedWithSymbol);

       // DQ (6/25/2007): As a special case the friend function in test2005_06.C is defined in the 
       // class and has a forward declaration outside of the class in global scope.
          ROSE_ASSERT(declarationAssociatedWithSymbol != NULL);
          if (declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL)
             {
            // printf ("Using this->get_definingDeclaration(): declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL \n");

               declarationAssociatedWithSymbol = const_cast<SgDeclarationStatement*>(this);

               if (declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL)
                  {
                    printf ("Error: No symbol found, declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL: declarationAssociatedWithSymbol = %p = %s = %s \n",
                         declarationAssociatedWithSymbol,declarationAssociatedWithSymbol->class_name().c_str(),SageInterface::get_name(declarationAssociatedWithSymbol).c_str());
                    SgScopeStatement* scope = declarationAssociatedWithSymbol->get_scope();
                    printf ("declarationAssociatedWithSymbol scope = %p = %s = %s \n",scope,scope->class_name().c_str(),SageInterface::get_name(scope).c_str());
                    scope->get_symbol_table()->print("declarationAssociatedWithSymbol");
                  }
               ROSE_ASSERT(declarationAssociatedWithSymbol->get_symbol_from_symbol_table() != NULL);
             }
        }
       else
        {
          ROSE_ASSERT(declarationAssociatedWithSymbol != NULL);
#if 0
          printf ("declarationAssociatedWithSymbol != NULL: this = %p = %s \n",declarationAssociatedWithSymbol,this->class_name().c_str());
#endif
          if (declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL)
             {
#if 0
               printf ("declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL \n");
#endif
               SgDeclarationStatement* previousDeclarationAssociatedWithSymbol = declarationAssociatedWithSymbol;

               declarationAssociatedWithSymbol = this->get_definingDeclaration();

            // If this is NULL then we should have found the symbol  using the firstNondefiningDeclaration
               if (declarationAssociatedWithSymbol == NULL)
                  {
                 // DQ (6/30/2007): Test if the this pointer has an associated symbol.
                    printf ("Error: problem this = %p = %s = %s \n",
                         this,this->class_name().c_str(),SageInterface::get_name(this).c_str());
                    ROSE_ASSERT(this->get_symbol_from_symbol_table() == NULL);
                    this->get_startOfConstruct()->display("declarationAssociatedWithSymbol == NULL: debug");

                    this->get_scope()->print_symboltable("declarationAssociatedWithSymbol == NULL");
                  }
            // ROSE_ASSERT(declarationAssociatedWithSymbol != NULL);
               if (declarationAssociatedWithSymbol == NULL)
                  {
                    printf ("In SgDeclarationStatement::get_declaration_associated_with_symbol(): declarationAssociatedWithSymbol == NULL no associated symbol for this declaration = %p = %s = %s \n",
                         previousDeclarationAssociatedWithSymbol,previousDeclarationAssociatedWithSymbol->class_name().c_str(),
                         SageInterface::get_name(previousDeclarationAssociatedWithSymbol).c_str());
                  }

               if ( (declarationAssociatedWithSymbol != NULL) && (declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL) )
                  {
                    printf ("Error: declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL \n");
                    printf ("     declarationAssociatedWithSymbol = %p = %s = %s \n",
                         declarationAssociatedWithSymbol,
                         declarationAssociatedWithSymbol->class_name().c_str(),
                         SageInterface::get_name(declarationAssociatedWithSymbol).c_str());
                  }

               if ( (declarationAssociatedWithSymbol != NULL) && (declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL) )
                  {
                    this->get_startOfConstruct()->display("this");
                    declarationAssociatedWithSymbol->get_startOfConstruct()->display("declarationAssociatedWithSymbol");
                    SgTemplateInstantiationDecl* templateInstantiationClassDeclaration = isSgTemplateInstantiationDecl(declarationAssociatedWithSymbol);
                    if (templateInstantiationClassDeclaration != NULL)
                       {
                         SgScopeStatement* scope = templateInstantiationClassDeclaration->get_scope();
                         printf ("templateInstantiationClassDeclaration->get_scope() = %p = %s = %s \n",scope,scope->class_name().c_str(),SageInterface::get_name(scope).c_str());
                         ROSE_ASSERT(templateInstantiationClassDeclaration->get_templateDeclaration() != NULL);
                         templateInstantiationClassDeclaration->get_templateDeclaration()->get_startOfConstruct()->display("template");
                         printf ("templateInstantiationClassDeclaration->get_definingDeclaration()         = %p \n",templateInstantiationClassDeclaration->get_definingDeclaration());
                         printf ("templateInstantiationClassDeclaration->get_firstNondefiningDeclaration() = %p \n",templateInstantiationClassDeclaration->get_firstNondefiningDeclaration());
                       }
                  }

            // ROSE_ASSERT(declarationAssociatedWithSymbol != NULL);

               if (declarationAssociatedWithSymbol != NULL)
                  {
                    if (declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL)
                       {
                         printf ("declarationAssociatedWithSymbol = %p = %s = %s \n",
                              declarationAssociatedWithSymbol,declarationAssociatedWithSymbol->class_name().c_str(),
                              SageInterface::get_name(declarationAssociatedWithSymbol).c_str());
                         SgScopeStatement* scope = declarationAssociatedWithSymbol->get_scope();
                         printf ("declarationAssociatedWithSymbol scope = %p = %s = %s \n",scope,scope->class_name().c_str(),SageInterface::get_name(scope).c_str());
                         scope->get_symbol_table()->print("declarationAssociatedWithSymbol");
                       }
                    ROSE_ASSERT(declarationAssociatedWithSymbol->get_symbol_from_symbol_table() != NULL);
                  }
             }
        }

  // ROSE_ASSERT(declarationAssociatedWithSymbol != NULL);

#if 0
     printf ("In get_declaration_associated_with_symbol(): declarationAssociatedWithSymbol = %p \n",declarationAssociatedWithSymbol);
#endif

     return declarationAssociatedWithSymbol;
   }

// DQ (7/22/2007): This should be a member function of SgDeclarationStatement
bool
SgDeclarationStatement::hasAssociatedSymbol() const
   {
     bool returnValue = true;

  // SgFunctionParameterList should likely not even be a declaration, but at least it has 
  // not associated symbol in the symbol table. SgVariableDeclaration contain a list of
  // SgInitializedName objects and those have associated symbols, the SgVariableDeclaration
  // does not have an associated symbol.
     if (isSgFunctionParameterList(this) != NULL || 
         isSgCtorInitializerList(this)   != NULL ||
         isSgPragmaDeclaration(this)     != NULL ||
         isSgVariableDeclaration(this)   != NULL ||
         isSgVariableDefinition(this)    != NULL )
        {
          returnValue = false;
        }

     return returnValue;
   }



SOURCE_DECLARATION_STATEMENT_END

SOURCE_TEMPLATE_SPECIALIZATION_SUPPORT_START

bool
$CLASSNAME::isSpecialization() const
   {
     bool returnValue = false;
     returnValue = (p_specialization == SgDeclarationStatement::e_specialization);
     return returnValue;
   }

bool
$CLASSNAME::isPartialSpecialization() const
   {
     bool returnValue = false;
     returnValue = (p_specialization == SgDeclarationStatement::e_partial_specialization);
     return returnValue;
   }

SOURCE_TEMPLATE_SPECIALIZATION_SUPPORT_END


SOURCE_BASIC_BLOCK_STATEMENT_START

SgBasicBlock::SgBasicBlock(Sg_File_Info* info, SgStatement* stmt)
:$BASECLASS(info)
   {
  /* now a call to the user defined initialization function */
     post_construction_initialization();
     if (stmt != NULL)
        {
          append_statement(stmt);

       // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
          ROSE_ASSERT(stmt->get_parent() != NULL);
        }
   }

SgBasicBlock::SgBasicBlock( SgStatement* stmt )
:$BASECLASS()
   {
  /* now a call to the user defined initialization function */
     post_construction_initialization();
     if (stmt != NULL)
        {
          append_statement(stmt);

       // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
          ROSE_ASSERT(stmt->get_parent() != NULL);
        }
   }

// DQ (9/8/2004): Added to support qualified name generation
SgName
SgBasicBlock::get_qualified_name() const
   {
  // DQ (8/28/2005): This is where we might name blocks if we select to do so at some point
  // as a way of building unique names for qualified named declarations.

  // Note that this will still evaluate so that "returnName.is_null()" will be true
     SgName returnName = "";
     return returnName;
   }

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgBasicBlock::get_mangled_name(void) const
   {
     return SgName ("");
   }

void
SgBasicBlock::post_construction_initialization()
   {
   // Call the base class post_construction_initialization() member function
   // SgScopeStatement::post_construction_initialization();
   }

void
SgBasicBlock::append_statement(SgStatement * what) 
   {
//   printf ("In $CLASSNAME::append_statement(): Call to insert_statement() commented out \n");
//   ROSE_ABORT();

     get_statements().push_back(what);
     what->set_parent(this);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

#if 1
void
SgBasicBlock::prepend_statement(SgStatement *what)
   {
     get_statements().insert(get_statements().begin(), what);
     what->set_parent(this);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }
#endif

#if 0
void
SgBasicBlock::append_statement(const SgStatementPtrList::iterator& where, SgStatement * what) 
   {
  // Alternative that allows for appending after any statement in the list
  // insert_statement(where,what);

     SgStatementPtrList::iterator tempIterator = where;
     tempIterator++;
  // Handle the case of appending at the end of the list
     if ( tempIterator == get_statements().end() )
        {
          append_statement (what);
        }
       else
        {
          insert_statement (tempIterator,what);
        }

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }
#endif

#if 0
void
SgBasicBlock::prepend_statement(const SgStatementPtrList::iterator& where, SgStatement *what)
   {
  // Alternative that allows for prepending before any statement in the list
     insert_statement(where, what);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }
#endif

#if 0
void
SgBasicBlock::insert_statement(const SgStatementPtrList::iterator& where, SgStatement * what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif

#if PRINT_SIDE_EFFECT_WARNINGS
     printf ("Warning Side-Effect: Calling set_parent on %p = %s (set to %p = %s) \n",what,what->sage_class_name(),this,sage_class_name());
#endif
     what->set_parent(this);

     get_statements().insert(where,what);
   }
#endif

bool
SgBasicBlock::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     return  StatementListInsertChild( this, p_statements, target, newstmt, true, extractBasicBlock, true);
   }

bool
SgBasicBlock::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
   {
     return  StatementListInsertChild( this, p_statements, target, newstmt, inFront, extractBasicBlock, false);
   }

SOURCE_BASIC_BLOCK_STATEMENT_END


SOURCE_IF_STATEMENT_START
void
SgIfStmt::post_construction_initialization()
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.

  // printf ("Note: modified SgIfStmt::post_construction_initialization() to set parents of conditional, true_body, and false_body \n");

// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (get_conditional() != NULL) get_conditional()->set_parent(this);
     if (get_true_body()   != NULL) get_true_body  ()->set_parent(this);
     if (get_false_body()  != NULL) get_false_body ()->set_parent(this);
// #endif
   }

bool
SgIfStmt::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     if (StatementReplace(this, p_conditional, target, newstmt) == true)
        {
          return true; 
        }
       else
        {
          if (StatementReplace(this, p_true_body, target, newstmt) == true)
             {
               return true;
             }
            else
             {
               if (StatementReplace(this, p_false_body, target, newstmt) == true)
                  {
                    return true;
                  }
                 else
                  {
                    return false;
                  }
             }
        }
   }

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgIfStmt::get_mangled_name(void) const
   {
     return SgName ("");
   }

SOURCE_IF_STATEMENT_END

SOURCE_FOR_INIT_STATEMENT_START

void
SgForInitStatement::post_construction_initialization()
   {
   }

void
SgForInitStatement::append_init_stmt(SgStatement * what)
   {
     get_init_stmt().push_back(what);
     what->set_parent(this);
   }

void
SgForInitStatement::prepend_init_stmt(SgStatement * what)
   {
     get_init_stmt().insert(get_init_stmt().begin(), what);
     what->set_parent(this);
   }

#if 0
void
SgForInitStatement::insert_init_stmt(const SgStatementPtrList::iterator& where, SgStatement * what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif

  // DQ (6/24/2006): This is a structural operation so it is OK to set the parent
     what->set_parent(this);

     get_init_stmt().insert(where,what);
   }
#endif

bool
SgForInitStatement::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, p_init_stmt, target, newstmt, true, extractBasicBlock, true);
   }

bool 
SgForInitStatement::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, p_init_stmt, target, newstmt, inFront, extractBasicBlock, false);
   }

SOURCE_FOR_INIT_STATEMENT_END


SOURCE_FOR_STATEMENT_START

void
SgForStatement::post_construction_initialization()
   {
  // DQ (6/24/2006): Refactored this code to build the SgForInitStatement 
  // for all SgForStatement as part of constructor.
     ROSE_ASSERT(p_for_init_stmt == NULL);
  // SgForInitStatement* forInitStatement = new SgForInitStatement(New_File_Info(this));
     SgForInitStatement* forInitStatement = NULL;
     if (get_startOfConstruct() != NULL)
        {
          forInitStatement = new SgForInitStatement(New_File_Info(this));

       // DQ (10/27/2006): This will have to be updated after construction, 
       // since we don't know the ending position at this point!
          forInitStatement->set_endOfConstruct(New_File_Info(this));

       // DQ (12/17/2006): Fixup the parents of Sg_File_Info objects
          forInitStatement->get_startOfConstruct()->set_parent(forInitStatement);
          forInitStatement->get_endOfConstruct()->set_parent(forInitStatement);
        }
       else
        {
          forInitStatement = new SgForInitStatement();
        }

     ROSE_ASSERT(forInitStatement != NULL);

  // All SgForStatement IR nodes should have a valid SgForInitStatement (even if it is an empty list!).
     set_for_init_stmt(forInitStatement);

     forInitStatement->set_parent(this);

  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_test != NULL)
        {
          p_test->set_parent(this);
        }

  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_increment != NULL)
        {
          p_increment->set_parent(this);
        }

  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_loop_body != NULL)
        {
          p_loop_body->set_parent(this);
        }
   }

// MS: moved StatementPtrList to ForInitStatement. Therefore the call is simply forwarded and the same interface
SgStatementPtrList &
SgForStatement::get_init_stmt()
   { 
  // DQ (6/24/2006): If this is always true then we can simplify this function.
     ROSE_ASSERT(p_for_init_stmt != NULL);
     return get_for_init_stmt()->get_init_stmt(); 
   }

const SgStatementPtrList &
SgForStatement::get_init_stmt() const
   {
  // DQ (6/24/2006): When we later simplify the append, prepend, insert functions this will be important.
     ROSE_ASSERT(p_for_init_stmt != NULL);

     return get_for_init_stmt()->get_init_stmt();
   }

void
SgForStatement::append_init_stmt(SgStatement * what)
   { 
  // DQ (6/24/2006): If this is always true then we can simplify this function.
     ROSE_ASSERT(p_for_init_stmt != NULL);
     get_for_init_stmt()->append_init_stmt(what);
   }

void
SgForStatement::prepend_init_stmt(SgStatement * what)
   {
  // DQ (6/24/2006): If this is always true then we can simplify this function.
     ROSE_ASSERT(p_for_init_stmt != NULL);
     get_for_init_stmt()->prepend_init_stmt(what); 
   }

bool
SgForStatement::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
       if ( StatementReplace(this, p_loop_body, target, newstmt) == true )
           return true;
       else if ( StatementReplace(this, p_for_init_stmt, target, newstmt) == true )
           return true;
       else if ( StatementReplace(this, p_test, target, newstmt) == true )
           return true;
       else 
           return false;
   }

// DQ (11/25/2005): preserve the previous interface so that
// the most common case of where a test is an expression can
// be handled as before.  We can deprecate this function later.
// Currently the test has been modified to allow it to be a SgStatement
// and in the case of an expression, it is just a SgExprStatement.
// This is required for C and C++ which allows declarations to be
// placed where the test is evaluated in a for loop (note that this
// is part of uniform changes to the IR to fixup such details).
SgExpression* 
SgForStatement::get_test_expr () const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT(p_test != NULL);
     ROSE_ASSERT(isSgStatement(p_test) != NULL);

     SgExpression*    testExpression = NULL;
     SgExprStatement* exprStatement  = isSgExprStatement(p_test);
     if (exprStatement != NULL)
        {
       // testExpression = exprStatement->get_the_expr();
          testExpression = exprStatement->get_expression();
          ROSE_ASSERT(testExpression != NULL);
        }
       else
        {
          printf ("test in SgForStatement is a %s \n",p_test->class_name().c_str());
          ROSE_ASSERT(false);
        }

     ROSE_ASSERT(testExpression != NULL);
     return testExpression;
   }

void
SgForStatement::set_test_expr (SgExpression* expr )
   {
  // DQ (11/25/2005): preserve the previous interface. This function 
  // sets the SgStatement using a SgExpressionRoot IR node.
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (expr != NULL);

     Sg_File_Info* fileInfo = New_File_Info(expr);
     SgExprStatement* expressionStatement = new SgExprStatement(fileInfo,expr);
     ROSE_ASSERT(expressionStatement != NULL);

  // DQ (10/27/2006): This might have to be reset later, 
  // since at this point we might not know the exact size.
     expressionStatement->set_endOfConstruct(New_File_Info(expr));

     expressionStatement->get_startOfConstruct()->set_parent(expressionStatement);
     expressionStatement->get_endOfConstruct()->set_parent(expressionStatement);

     if (get_test() != NULL)
        {
          printf ("Warning SgForStatement::set_test_expr is clobbering the existing test statement \n");
        }
     set_test(expressionStatement);

  // DQ (4/7/2006): Set the parents
     expressionStatement->set_parent(this);

     ROSE_ASSERT(isSgStatement(p_test) != NULL);
   }

// DQ (12/6/2006): We need this sort of function now that we have removed the expression root node!
// The requirement of not being able to do operations uniformly on expressions may be the disadvantage
// of not having used the SgExpressionRoot IR node as a concept.
int
SgForStatement::replace_expression(SgExpression * original_expression, SgExpression * new_expression )
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(original_expression != NULL);
     ROSE_ASSERT(new_expression != NULL);

     ROSE_ASSERT(original_expression == p_increment);

     set_increment(new_expression);

     new_expression->set_parent(this);

  // DQ: Let this be a memory leak for now to avoid initial problems.
     ROSE_ASSERT(original_expression != NULL);
  // delete original_expression;

     return 0;
   }

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgForStatement::get_mangled_name(void) const
   {
     return SgName ("");
   }

SOURCE_FOR_STATEMENT_END

SOURCE_FORALL_STATEMENT_START

void
SgForAllStatement::post_construction_initialization()
   {
   }

SOURCE_FORALL_STATEMENT_END

SOURCE_UPC_FORALL_STATEMENT_START

// Liao, we have to duplicate most code from SgForStatement since 
// SgUpcForAllStatement and SgForStatement are not related 
// Copy the member functions from SgForStatement below:
void
SgUpcForAllStatement::post_construction_initialization()
   {
    ROSE_ASSERT(p_for_init_stmt == NULL);
  // SgForInitStatement* forInitStatement = new SgForInitStatement(New_File_Info(this));
     SgForInitStatement* forInitStatement = NULL;
     if (get_startOfConstruct() != NULL)
        {
          forInitStatement = new SgForInitStatement(New_File_Info(this));

       // DQ (10/27/2006): This will have to be updated after construction, 
       // since we don't know the ending position at this point!
          forInitStatement->set_endOfConstruct(New_File_Info(this));

       // DQ (12/17/2006): Fixup the parents of Sg_File_Info objects
          forInitStatement->get_startOfConstruct()->set_parent(forInitStatement);
          forInitStatement->get_endOfConstruct()->set_parent(forInitStatement);
        }
       else
        {
          forInitStatement = new SgForInitStatement();
        }

     ROSE_ASSERT(forInitStatement != NULL);

  // All SgUpcForAllStatement IR nodes should have a valid SgForInitStatement (even if it is an empty list!).
     set_for_init_stmt(forInitStatement);

     forInitStatement->set_parent(this);

  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_test != NULL)
        {
          p_test->set_parent(this);
        }

  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_increment != NULL)
        {
          p_increment->set_parent(this);
        }

  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_loop_body != NULL)
        {
          p_loop_body->set_parent(this);
        }
   }

// MS: moved StatementPtrList to ForInitStatement. Therefore the call is simply forwarded and the same interface
SgStatementPtrList &
SgUpcForAllStatement::get_init_stmt()
   { 
  // DQ (6/24/2006): If this is always true then we can simplify this function.
     ROSE_ASSERT(p_for_init_stmt != NULL);
     return get_for_init_stmt()->get_init_stmt(); 
   }

const SgStatementPtrList &
SgUpcForAllStatement::get_init_stmt() const
   {
  // DQ (6/24/2006): When we later simplify the append, prepend, insert functions this will be important.
     ROSE_ASSERT(p_for_init_stmt != NULL);

     return get_for_init_stmt()->get_init_stmt();
   }

void
SgUpcForAllStatement::append_init_stmt(SgStatement * what)
   { 
  // DQ (6/24/2006): If this is always true then we can simplify this function.
     ROSE_ASSERT(p_for_init_stmt != NULL);
     get_for_init_stmt()->append_init_stmt(what);
   }

void
SgUpcForAllStatement::prepend_init_stmt(SgStatement * what)
   {
  // DQ (6/24/2006): If this is always true then we can simplify this function.
     ROSE_ASSERT(p_for_init_stmt != NULL);
     get_for_init_stmt()->prepend_init_stmt(what); 
   }
bool
SgUpcForAllStatement::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_loop_body, target, newstmt) == true )
          return true;
       else
          if ( StatementReplace(this, p_for_init_stmt, target, newstmt) == true )
               return true;
            else 
               return false;
   }

SgExpression* 
SgUpcForAllStatement::get_test_expr () const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT(p_test != NULL);
     ROSE_ASSERT(isSgStatement(p_test) != NULL);

     SgExpression*    testExpression = NULL;
     SgExprStatement* exprStatement  = isSgExprStatement(p_test);
     if (exprStatement != NULL)
        {
       // testExpression = exprStatement->get_the_expr();
          testExpression = exprStatement->get_expression();
          ROSE_ASSERT(testExpression != NULL);
        }
       else
        {
          printf ("test in SgUpcForAllStatement is a %s \n",p_test->class_name().c_str());
          ROSE_ASSERT(false);
        }

     ROSE_ASSERT(testExpression != NULL);
     return testExpression;
   }
void
SgUpcForAllStatement::set_test_expr (SgExpression* expr )
   {
  // DQ (11/25/2005): preserve the previous interface. This function 
  // sets the SgStatement using a SgExpressionRoot IR node.
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (expr != NULL);

    Sg_File_Info* fileInfo = New_File_Info(expr);
     SgExprStatement* expressionStatement = new SgExprStatement(fileInfo,expr);
     ROSE_ASSERT(expressionStatement != NULL);

  // DQ (10/27/2006): This might have to be reset later, 
  // since at this point we might not know the exact size.
     expressionStatement->set_endOfConstruct(New_File_Info(expr));

     expressionStatement->get_startOfConstruct()->set_parent(expressionStatement);
     expressionStatement->get_endOfConstruct()->set_parent(expressionStatement);

     if (get_test() != NULL)
        {
          printf ("Warning SgUpcForAllStatement::set_test_expr is clobbering the existing test statement \n");
        }
     set_test(expressionStatement);

  // DQ (4/7/2006): Set the parents
     expressionStatement->set_parent(this);

     ROSE_ASSERT(isSgStatement(p_test) != NULL);
   }
int
SgUpcForAllStatement::replace_expression(SgExpression * original_expression, SgExpression * new_expression )
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(original_expression != NULL);
     ROSE_ASSERT(new_expression != NULL);

     ROSE_ASSERT(original_expression == p_increment);

     set_increment(new_expression);

     new_expression->set_parent(this);

  // DQ: Let this be a memory leak for now to avoid initial problems.
     ROSE_ASSERT(original_expression != NULL);
  // delete original_expression;

     return 0;
   }

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgUpcForAllStatement::get_mangled_name(void) const
   {
     return SgName ("");
   }

SOURCE_UPC_FORALL_STATEMENT_END

SOURCE_UPC_NOTIFY_STATEMENT_START
void
SgUpcNotifyStatement::post_construction_initialization()
   {
   }

SOURCE_UPC_NOTIFY_STATEMENT_END

SOURCE_UPC_WAIT_STATEMENT_START
void
SgUpcWaitStatement::post_construction_initialization()
   {
   }

SOURCE_UPC_WAIT_STATEMENT_END

SOURCE_UPC_BARRIER_STATEMENT_START
void
SgUpcBarrierStatement::post_construction_initialization()
   {
   }

SOURCE_UPC_BARRIER_STATEMENT_END

SOURCE_UPC_FENCE_STATEMENT_START
void
SgUpcFenceStatement::post_construction_initialization()
   {
   }

SOURCE_UPC_FENCE_STATEMENT_END



SOURCE_FUNCTION_DECLARATION_STATEMENT_START

void
SgFunctionDeclaration::post_construction_initialization()
   {
  // Sg_File_Info* thisFileInfo = get_file_info();
  // ROSE_ASSERT (thisFileInfo != NULL);

  // DQ (10/25/2004): Force generation of new file info object (all such objects should be unique)
  // initialize the FunctionParameterList as an object that is referred to from FunctionDeclaration
  // Sg_File_Info* fileInfo = new Sg_File_Info(*thisFileInfo);
  // ROSE_ASSERT (fileInfo != NULL);

  // DQ (11/12/2006): Modified to permit being called by constructor without Sg_File_Info objects.
  // DQ (7/19/2005): set parameter list on a single location (and independently of existence of function parameters)
  // p_args = new SgFunctionParameterList(fileInfo);
     SgFunctionParameterList* args = NULL;
     if (get_startOfConstruct() != NULL)
        {
          args = new SgFunctionParameterList(New_File_Info(this));
          args->get_startOfConstruct()->set_parent(args);
        }
       else
        {
       // DQ (11/12/2006): Use the new constructor.
          args = new SgFunctionParameterList();
        }
     ROSE_ASSERT (args != NULL);
     set_parameterList(args);

  // DQ (7/19/2005): set the parent explicitly
     get_parameterList()->set_parent(this);

  // DQ (3/6/2007): Set the firstNondefiningDeclaration of args to itself (this is now required 
  // for the AST consistency tests after the AST merge).  Likely because one where a member function 
  // is referenced before being declared in a class the member function was not previously visited by 
  // the AST traversal and so one of its defining or non-defining declarations was not set and after 
  // the merge this declaration is used (shared) and thus accessed where before it had been hidden.
  // DQ (3/15/2006): Let this be NULL so that it will be fixed by the fixupDeclarations function 
  // within the post processing phase.
  // DQ (9/6/2005): Since a SgFunctionParameterList is a SgDeclarationStatement we should set
  // either its defining or non-defining declaration (I choose the non-defining declaration).
  // args->set_definingDeclaration(args);
  // args->set_firstNondefiningDeclaration(args);
     args->set_firstNondefiningDeclaration(args);

  // DQ (10/25/2004): Add a ending file info object for completeness (though this is not yet 
  // initialized to the correct position, yet).  Initially let's get them in place then we can
  // work on the accuracy afterward!
  // Sg_File_Info* endingPosition = new Sg_File_Info(*thisFileInfo);
  // ROSE_ASSERT (endingPosition != NULL);
  // p_args->set_endOfConstruct(endingPosition);

  // DQ (7/31/2006): Explicit initialization of this data member is required!
  // JJW (8/6/2008): It probably isn't now that p_exceptionSpecification is a vector
     p_exceptionSpecification.clear();
   }

SgType*
SgFunctionDeclaration::get_orig_return_type() const
   {
     return get_type()->get_orig_return_type();
   }

void
SgFunctionDeclaration::hasEllipses()
   {
  // Record as true!
     get_type()->set_has_ellipses(1);
   }

#if 0
/* InitalizedName tuple : (SgName, DeclStmt, type, Initializer) */
SgInitializedNamePtrList::iterator 
SgFunctionDeclaration::insert_arg(const SgInitializedNamePtrList::iterator& where, SgInitializedName* what)
   {
  // DQ (7/19/2005): This is now set in the post_construction_initialization()
     ROSE_ASSERT(get_parameterList() != NULL);

     return get_parameterList()->insert_arg(where,what);
   }
#endif

void
SgFunctionDeclaration::append_arg( SgInitializedName* what)
   {
  // DQ (7/19/2005): This is now set in the post_construction_initialization()
     ROSE_ASSERT(get_parameterList() != NULL);

     get_parameterList()->append_arg(what);
   }

void
SgFunctionDeclaration::prepend_arg( SgInitializedName* what)
   {
  // DQ (7/19/2005): This is now set in the post_construction_initialization()
     ROSE_ASSERT(get_parameterList() != NULL);

     get_parameterList()->prepend_arg(what);
   }

SgInitializedNamePtrList & 
SgFunctionDeclaration::get_args() 
   {
  // DQ (7/19/2005): This is now set in the post_construction_initialization()
     ROSE_ASSERT(get_parameterList() != NULL);

     return get_parameterList()->get_args();
   }

const SgInitializedNamePtrList & 
SgFunctionDeclaration::get_args() const 
   {
  // QY:11/2/04 should make sure get_parameterList() != 0
     assert(get_parameterList() != NULL);
     return get_parameterList()->get_args();
   }

// QY:11/2/04: Removed p_mangled_name member because it is always obtained from p_type anyway
// void $CLASSNAME::set_mangled_name()
//   {
//     SgUnparse_Info info;
//     info.set_decl_stmt((SgDeclarationStatement *)this);
//     info.set_name(p_name);
//     info.set_PrintName();
//     if(p_type)
//          p_mangled_name=p_type->get_mangled(info);
//   }

bool
SgFunctionDeclaration::isTemplateFunction() const
   {
  // DQ (4/28/2005): This function tests for a template function. It is non-trivial because
  // we combine both non-template member functions in templated classes (or nested classes 
  // of templated classes) with member functions that are templated.

     bool returnValue = false;

     const SgTemplateInstantiationFunctionDecl *templateFunction = isSgTemplateInstantiationFunctionDecl(this);
     if (templateFunction != NULL)
        {
          returnValue = true;

       // Error checking 
          ROSE_ASSERT(templateFunction->get_templateDeclaration() != NULL);
          ROSE_ASSERT(templateFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_function /* 3 */);
        }
       else
        {
          const SgTemplateInstantiationMemberFunctionDecl *templateMemberFunction = isSgTemplateInstantiationMemberFunctionDecl(this);
          if (templateMemberFunction != NULL)
             {
            // This is a template member function but we need to know if it is a member 
            // function of a template class or a template function in a non template class.
               SgTemplateDeclaration *templateDeclaration = templateMemberFunction->get_templateDeclaration();
               ROSE_ASSERT(templateDeclaration != NULL);

            // printf ("type of template declaration = %d \n",templateDeclaration->get_template_kind());
#if 0
               SgTemplateParameterPtrList *templateParameterList = templateDeclaration->get_templateParameters();
               if (templateParameterList == NULL)
                  {
                    printf ("Null pointer to SgTemplateParameterPtrList in template declaration \n");
                  }
                 else
                  {
                    int numberOfTemplateParameters = templateParameterList->size();
                    printf ("Number of template parameters = %d \n",numberOfTemplateParameters);
                  }
            // ROSE_ASSERT(templateParameterList != NULL);
#endif
            // ROSE_ASSERT(templateMemberFunction->get_templateArguments() != NULL);
               int numberOfTemplateArguments  = templateMemberFunction->get_templateArguments().size();

            // printf ("Number of template arguments  = %d \n",numberOfTemplateArguments);

               if (numberOfTemplateArguments == 0)
                  {
                 // This is the case of a non-template member function in a templated class or nested class of a templated class!
                 // printf ("This is the case of a non-template member function in a templated class or nested class of a templated class \n");
                    returnValue = false;

                 // Error checking
                    ROSE_ASSERT(templateMemberFunction->get_templateDeclaration() != NULL);

                 // DQ (8/12/2005): This can also be a template declaration for a class (at least where the template declaration is stringified presently)
                 // if (templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_m_function /* 4 */)
                    if ( templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_m_function /* 4 */ &&
                         templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_class /* 1 */ &&
                         templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_m_class /* 2 */)
                       {
                         printf ("Error: templateMemberFunction->get_templateDeclaration()->get_template_kind() = %d != e_template_m_function || e_template_class \n",
                              templateMemberFunction->get_templateDeclaration()->get_template_kind());
                      // templateMemberFunction->get_file_info()->display("Error: templateMemberFunction->get_templateDeclaration()->get_template_kind()");
                      // templateMemberFunction->get_file_info()->display("debug");
                       }

                 // DQ (12/14/2005): Added acceptable case of e_template_m_class.
                 // DQ (7/4/2005): Commented out so that we can compile KULL (substituted warning message)
                 // ROSE_ASSERT(templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_m_function /* 4 */);
                    ROSE_ASSERT( templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_m_function /* 4 */ ||
                                 templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_class /* 1 */ ||
                                 templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_m_class /* 2 */);
                  }
                 else
                  {
                 // printf ("This is a valid templated member function! numberOfTemplateArguments = %d \n",numberOfTemplateArguments);
                    returnValue = true;

                 // Error checking
                    ROSE_ASSERT(templateMemberFunction->get_templateDeclaration() != NULL);
                 // if (templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_function /* 3 */)
                    if ( templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_function /* 3 */ &&
                         templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_class /* 1 */)
                       {
                         printf ("Error: templateMemberFunction->get_templateDeclaration()->get_template_kind() = %d != e_template_function || e_template_class \n",
                              templateMemberFunction->get_templateDeclaration()->get_template_kind());
                      // templateMemberFunction->get_file_info()->display("Error: templateMemberFunction->get_templateDeclaration()->get_template_kind()");
                      // templateMemberFunction->get_file_info()->display("debug");
                       }
                 // DQ (7/4/2005): Commented out so that we can compile KULL (substituted warning message)
                 // ROSE_ASSERT(templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_function /* 3 */);
                    ROSE_ASSERT( templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_function /* 3 */ ||
                                 templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_class /* 1 */);
                  }

            // printf ("type of template declaration = %d returnValue = %s \n",templateDeclaration->get_template_kind(),returnValue ? "true" : "false");
             }
        }

     return returnValue;
   }


// DQ (2/7/2006): New version added by Rich Vuduc
SgName
SgFunctionDeclaration::get_mangled_name() const
   {
  // RV (1/31/2006): Changed this routine to include the name
  // qualification in the mangled name, to guarantee the returned
  // string identifies a function uniquely. Moreover, the
  // SgMemberFunctionDeclaration child class then automatically
  // inherits the correct behavior.
  //! \todo Update ROSE manual to document the revised mangling scheme.

  // DQ (4/27/2005): I have considered making this the qualified
  // name, but decided against it. See notes in the ROSE manual
  // appendix about mangled names and qualified names.

     ROSE_ASSERT(this != NULL);

  // printf ("In SgFunctionDeclaration::get_mangled_name() for this = %p \n",this);

#if 0
#if SKIP_MANGLED_NAME_CACHING
  // Compute a mangled name from this function's type
     SgName type_name;
     SgName ret_type_name;
     const SgFunctionType* func_type = get_type();
     if (func_type != NULL)
        {
          type_name = func_type->get_mangled();
          const SgType* ret_type = func_type->get_return_type();
          if (ret_type)
               ret_type_name = ret_type->get_mangled();
        }
       else
          type_name = "defaultFunctionTypeName";
 
  // This function's name, transformed.
     SgName func_name = mangleFunctionName (get_name(), ret_type_name);
 
  // Compute the name qualification, if any.
     const SgScopeStatement* par_scope = get_scope();
     SgName scope_name = mangleQualifiers(par_scope);
 
  // Compute the final mangled name.
     return joinMangledQualifiers (scope_name, func_name + "__" + type_name);
#else
  // DQ (10/6/2006): Added support for mangled name caching!
  // SgGlobal* globalScope = TransformationSupport::getGlobalScope(this);
  // std::map<SgNode*,std::string> & mangledNameCache = globalScope->get_mangledNameCache();
  // Build an iterator
  // std::map<SgNode*,std::string>::iterator i = mangledNameCache.find(this);

     SgName mangledName;

     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgFunctionDeclaration*>(this));
     if (mangledNameString.empty() == false)
        {
       // get the precomputed mangled name!
          mangledName = mangledNameString.c_str();
       // printf ("Mangled name found \n");
        }
       else
        {
       // Compute a mangled name from this function's type
          SgName type_name;
          SgName ret_type_name;
          const SgFunctionType* func_type = get_type();
          if (func_type != NULL)
             {
               type_name = func_type->get_mangled();
               const SgType* ret_type = func_type->get_return_type();
               if (ret_type)
                    ret_type_name = ret_type->get_mangled();
             }
            else
             {
               type_name = "defaultFunctionTypeName";
             }
 
       // This function's name, transformed.
          SgName func_name = mangleFunctionName (get_name(), ret_type_name);
 
       // Compute the name qualification, if any.
          const SgScopeStatement* par_scope = get_scope();
          SgName scope_name = mangleQualifiers(par_scope);
 
       // Compute the final mangled name.
          mangledName = joinMangledQualifiers (scope_name, func_name + "__" + type_name);

       // Add this mangled name to the cache of mangled names
       // mangledNameCache[this] = string(mangledName.str());
       // mangledNameCache.insert ( pair<SgNode*,std::string>( this , string(mangledName.str()) ) );
       // printf ("Mangled name will be added to the cache! \n");

          mangledName = SageInterface::addMangledNameToCache(const_cast<SgFunctionDeclaration*>(this),mangledName);
        }

     return mangledName;
#endif

#else
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
  // SgFunctionDeclaration* function = const_cast<SgFunctionDeclaration*>(this);
  // std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(function);
  // if (i != p_globalMangledNameMap.end())
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgFunctionDeclaration*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
       // printf ("RETURN FROM CACHE: Inside of SgFunctionDeclaration::get_mangled_name(): mangledNameString = %s \n",mangledNameString.c_str());
          return mangledNameString;
        }
       else
        {
          SgName mangledName;

       // DQ (6/23/2010): Added support to maintain seperate "main()" functions as unique (to avoid them being merged).
          if (this->get_name() == "main")
             {
            // Append the pointer to the name to make this unique to avoid multiple function "main()" from being merged.
               mangledName = "main_";
               mangledName += StringUtility::numberToString(const_cast<SgFunctionDeclaration*>(this));
            // printf ("RETURN FROM DETECTED MAIN: Inside of SgFunctionDeclaration::get_mangled_name(): mangledName = %s \n",mangledName.str());
               return mangledName;
             }

       // Compute a mangled name from this function's type
          SgName type_name;
          SgName ret_type_name;
          const SgFunctionType* func_type = get_type();
          if (func_type != NULL)
             {
               type_name = func_type->get_mangled();
               const SgType* ret_type = func_type->get_return_type();
               if (ret_type)
                    ret_type_name = ret_type->get_mangled();
             }
            else
             {
               type_name = "defaultFunctionTypeName";
             }
 
       // This function's name, transformed.
          SgName func_name = mangleFunctionName (get_name(), ret_type_name);
 
       // Compute the name qualification, if any.
          const SgScopeStatement* par_scope = get_scope();
          SgName scope_name = mangleQualifiers(par_scope);

       // Compute the translation unit qualification, if any.
          string xlation_unit_qual = mangleTranslationUnitQualifiers(this);

       // Compute the final mangled name.
          mangledName = joinMangledQualifiers (scope_name, xlation_unit_qual + func_name + "__" + type_name);

       // DQ (6/22/2010): Better to use the function name with the paraleter list in the mangled name.  This helps disambiguate
       // code such as:
       //    typedef struct Domain_s { } Domain_t;
       //    int foo ( Domain_s *domain);
       //    int foo ( Domain_t *domain);
       // printf ("Inside of SgFunctionDeclaration::get_mangled_name(): mangledName = %s \n",mangledName.str());
#if 1
       // printf ("TEMP: Inside of SgFunctionDeclaration::get_mangled_name(): mangledName = %s \n",mangledName.str());
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgFunctionDeclaration*>(this),mangledName);
       // printf ("TEMP RETURN: Inside of SgFunctionDeclaration::get_mangled_name(): mangledName = %s \n",mangledName.str());

       // This results in infinite recursion in the evaluation.
          SgFunctionParameterList* parameterList = this->get_parameterList();
          ROSE_ASSERT(parameterList != NULL);
          SgName mangledParameterList = parameterList->get_mangled_name();
          mangledName += "__" + mangledParameterList;
       // printf ("Inside of SgFunctionDeclaration::get_mangled_name(): after adding parameter list mangledName = %s \n",mangledName.str());
#endif

       // Reset the mangled name in the map.
       // p_globalMangledNameMap[function] = mangledName;
          SgNode::get_globalMangledNameMap()[const_cast<SgFunctionDeclaration*>(this)] = mangledName;

          return mangledName;
        }
#endif
   }


#if 0
// Old code
SgName
SgFunctionDeclaration::get_mangled_name() const
   {
  // DQ (10/24/2003): fix for mangle names. Default value specified 
  //                  caused set_mangled_name() to not be called properly.
  // if(p_mangled_name.is_null())
  //   if (p_mangled_name == "defaultName")
  //        set_mangled_name();
  //   return p_mangled_name;

     SgName returnName;

  // QY: 11/2/04 go through p_type;  if p_type == 0, return "defaultname"? (as in the old version)
     if (get_type() != NULL)
        {
          SgUnparse_Info info;
          info.set_decl_stmt( const_cast<SgFunctionDeclaration*>(this));

       // DQ (4/28/2005): Need to filter out the use of template names and convert them to something 
       // that can appear in a mangled name!
       // DQ (4/27/2005): I have considered making this the qualified name, but decided against it.
       // see notes in the ROSE manual appendix about mangled names and qualified names.
       // info.set_name(get_name());

          const SgTemplateInstantiationFunctionDecl       *templateFunction       = isSgTemplateInstantiationFunctionDecl(this);
          const SgTemplateInstantiationMemberFunctionDecl *templateMemberFunction = isSgTemplateInstantiationMemberFunctionDecl(this);

       // SgName functionName = "_";  // Avoid numbers in leading character of names
       // functionName += get_name();
          SgName functionName = get_name().str();
#if 0
          if (templateMemberFunction == NULL && templateFunction == NULL)
             {
               printf ("This is not a template function = %s \n",functionName.str());
             }
#endif
          if (templateMemberFunction != NULL)
             {
            // This is a template member function but we need to know if it is a member 
            // function of a template class or a template function in a non template class.
            // printf ("Found a templated member function name = %s \n",functionName.str());
               if (templateMemberFunction->isTemplateFunction() == true)
                  {
                 // functionName = "memberfunction" + functionName;
                    functionName = fixupTemplateNameForMangledNameSupport(functionName);
                  }
                 else
                  {
                    string f = functionName.str();
                    if (f.find("<") != string::npos)
                       {
                      // printf ("Found template syntax in a non template member function! \n");
                         functionName = fixupTemplateNameForMangledNameSupport(functionName);
                       }
#if 0
                    f = functionName.str();
                    ROSE_ASSERT (f.find("<") == string::npos);
                    ROSE_ASSERT (f.find(">") == string::npos);
#endif
                  }
#if 0
               string f = functionName.str();
               ROSE_ASSERT (f.find("<") == string::npos);
               ROSE_ASSERT (f.find(">") == string::npos);
#endif
            }

          if (templateFunction != NULL)
             {
            // This is a template and it has a name in template form (e.g. templateName < templateArgument >)
            // what we need is a form which is more appropriate to name mangling.
            // printf ("Found a templated function name = %s \n",functionName.str());
            // functionName = "function" + functionName;
               functionName = fixupTemplateNameForMangledNameSupport(functionName);

            // string f = functionName.str();
            // ROSE_ASSERT (f.find("<") == string::npos);
            // ROSE_ASSERT (f.find(">") == string::npos);
             }

       // string f = functionName.str();
       // ROSE_ASSERT (f.find("<") == string::npos);
       // ROSE_ASSERT (f.find(">") == string::npos);

       // functionName = "_" + functionName;

          info.set_name(functionName);

          info.set_PrintName();

       // printf ("In SgFunctionDeclaration::get_mangled_name()get_type() = %s \n",get_type()->sage_class_name());

          returnName = get_type()->get_mangled(info);
        }
       else
        {
          returnName = "defaultFunctionTypeName";
        }

     string mangledName = returnName.str();

  // printf ("In SgFunctionDeclaration::get_mangled_name() mangledName = %s \n",mangledName.c_str());

     ROSE_ASSERT (mangledName.find("<") == string::npos);
     ROSE_ASSERT (mangledName.find(">") == string::npos);

     ROSE_ASSERT(mangledName.find('`') == string::npos);
     ROSE_ASSERT(mangledName.find('~') == string::npos);
     ROSE_ASSERT(mangledName.find('!') == string::npos);
     ROSE_ASSERT(mangledName.find('@') == string::npos);
     ROSE_ASSERT(mangledName.find('#') == string::npos);
     ROSE_ASSERT(mangledName.find('$') == string::npos);
     ROSE_ASSERT(mangledName.find('%') == string::npos);
     ROSE_ASSERT(mangledName.find('^') == string::npos);
     ROSE_ASSERT(mangledName.find('&') == string::npos);
     ROSE_ASSERT(mangledName.find('*') == string::npos);
     ROSE_ASSERT(mangledName.find('(') == string::npos);
     ROSE_ASSERT(mangledName.find(')') == string::npos);
     ROSE_ASSERT(mangledName.find('-') == string::npos);
     ROSE_ASSERT(mangledName.find('+') == string::npos);
     ROSE_ASSERT(mangledName.find('=') == string::npos);
     ROSE_ASSERT(mangledName.find('{') == string::npos);
     ROSE_ASSERT(mangledName.find('}') == string::npos);
     ROSE_ASSERT(mangledName.find('[') == string::npos);
     ROSE_ASSERT(mangledName.find(']') == string::npos);
     ROSE_ASSERT(mangledName.find('|') == string::npos);
     ROSE_ASSERT(mangledName.find('\\') == string::npos);
     ROSE_ASSERT(mangledName.find(':') == string::npos);
     ROSE_ASSERT(mangledName.find(';') == string::npos);
     ROSE_ASSERT(mangledName.find('\"') == string::npos);
     ROSE_ASSERT(mangledName.find('\'') == string::npos);
     ROSE_ASSERT(mangledName.find('?') == string::npos);
     ROSE_ASSERT(mangledName.find('.') == string::npos);
     ROSE_ASSERT(mangledName.find('/') == string::npos);
     ROSE_ASSERT(mangledName.find(',') == string::npos);

  // These are the most common cases that fail
     ROSE_ASSERT(mangledName.find('<') == string::npos);
     ROSE_ASSERT(mangledName.find('>') == string::npos);

     return returnName;
   }
#endif

// SgStatement* get_next(int&) const;

bool
SgFunctionDeclaration::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_definition, target, newstmt) == true )
          return true;
     else
          return ( StatementReplace(this, p_parameterList, target, newstmt) == true );
   }

#if 0
// DQ (8/18/2004): Removing older attribute mechanism

/******  SgFunctionDeclaration ******/
/* suppress the printing of atomic keyword */
int
get_suppress_atomic ($CLASSNAME *node)
   {
     SgFuncDecl_attr *attr= 
         (SgFuncDecl_attr *) Sgget_user_attribute 
              (node->get_uattributes(),"SgFuncDecl_attr");
     if(attr)
        return attr->get_suppress_atomic();

     return 0;
   }
#endif

// DQ (10/20/2004): Since constructor names don't require their template arguments this has a far simpler solution!
// for example: "template <typename T> class X { X(); }; X<int>::X() {}"

// DQ (10/20/2004): This function should be different from those that are automatically generated 
// via ROSETTA.  In the case of a constructor or destructor the class name should be used.  This 
// is particularly important in the case of constructors and destructors of templated classes since 
// the mangled form or the template class should not be used since it will not allow the generated 
// code to compile.  Instead of names of the form "ABC____L8" we want names of the form "ABC<int>".
// These functions are now implemented explicitly instead of being automatically generated via ROSETTA.
// SgName get_name() const
//    {
//      SgName returnName = p_name;
//      if ( get_specialFunctionModifier().isConstructor() || 
//           get_specialFunctionModifier().isDestructor()  ||
//           get_specialFunctionModifier().isConversion() )
//         {
//            printf ("In $CLASSNAME::get_name: case of a constructor, destructor or conversion operator \n");
//            returnName = "Use the class Name";
//         }
//      
//      return returnName;
//    }

// SgName SgFunctionDeclaration::get_qualified_name(); 
SgName
SgFunctionDeclaration::get_qualified_name() const
   {
  // DQ (10/15/2004): This function is similar to the one for SgClassDeclaration.
  // This function calls get_scope() which uses the parent pointers, thus 
  // it should not be called before the parent pointers are set (within the AST fixup after 
  // the Sage III AST is fully constructed).

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());
     return returnName;
   }


bool
SgFunctionDeclaration::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgFunctionDeclaration::get_symbol_from_symbol_table() const
   {
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
#if 0
     printf ("In SgFunctionDeclaration::get_symbol_from_symbol_table(): this = %p = %s = %s scope = %p = %s scope->get_symbol_table() = %p \n",
          this,this->class_name().c_str(),SageInterface::get_name(this).c_str(),scope,scope->class_name().c_str(),scope->get_symbol_table());
#endif
     return scope->get_symbol_table()->find(this);

  // ROSE_ASSERT(get_scope() != NULL);
  // return get_scope()->get_symbol_table()->find(this);
   }

SOURCE_FUNCTION_DECLARATION_STATEMENT_END


SOURCE_FUNCTION_PARAMETER_LIST_START

void
SgFunctionParameterList::post_construction_initialization()
   {
     if (get_file_info() != NULL)
        {
          Sg_File_Info* endingPosition = new Sg_File_Info(*(get_file_info()));
          ROSE_ASSERT (endingPosition != NULL);

       // DQ (12/18/2006): Fixup parents of Sg_File_Info objects.
          endingPosition->set_parent(this);

          set_endOfConstruct(endingPosition);
        }
   }

#if 0
SgInitializedNamePtrList::iterator 
SgFunctionParameterList::insert_arg(const SgInitializedNamePtrList::iterator& where, SgInitializedName* what)
   {
  // DQ (9/24/2004): this should be true but verify it!
     ROSE_ASSERT(what != NULL);

     SgInitializedNamePtrList::iterator new_item = get_args().insert(where, what);

  // DQ (9/24/2004): This code requires that parent pointers be set in the AST 
  // (which we would like to defer to post-processing AST Fixup).  See if we can 
  // eliminate this code.  The declaration in the InitializedName should have 
  // already been set anyway, so I don't think it should be reset!  Though it 
  // could be that it is not set to the function declaration!
#ifndef REMOVE_SET_PARENT_FUNCTION
     SgFunctionDeclaration* declStmt	= dynamic_cast<SgFunctionDeclaration*>(get_parent());
     ROSE_ASSERT(declStmt!=0);
     (*new_item)->set_declaration(declStmt); // MS: 'get_parent' instead of 'this'
#else
  // Verify that the declaration of all function parameters have been set to the function declaration!
    // ROSE_ASSERT((*new_item)->get_declaration() != NULL);
   //  ROSE_ASSERT ( isSgFunctionDeclaration( (*new_item)->get_declaration() ) != NULL );

//   if ( (*new_item)->get_declaration()->variantT() != V_SgFunctionDeclaration &&
//        (*new_item)->get_declaration()->variantT() != V_SgMemberFunctionDeclaration )
//      {
//        printf ("Error: function parameter declaration (not SgFunctionDeclaration or SgMemberFunctionDeclaration) set to %s \n",(*new_item)->get_declaration()->sage_class_name());
//      }
//   ROSE_ASSERT ( (*new_item)->get_declaration()->variantT() == V_SgFunctionDeclaration ||
//                 (*new_item)->get_declaration()->variantT() == V_SgMemberFunctionDeclaration );
#endif
     return new_item;
   }
#endif

void
SgFunctionParameterList::append_arg( SgInitializedName* what)
   {
     get_args().push_back(what);
     what->set_parent(this);
     // SgFunctionDeclaration* declStmt = isSgFunctionDeclaration(this->get_parent());
   }

void
SgFunctionParameterList::prepend_arg( SgInitializedName* what)
   {
     get_args().insert(get_args().begin(), what);
     what->set_parent(this);
     // SgFunctionDeclaration* declStmt = isSgFunctionDeclaration(this->get_parent());
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgFunctionParameterList::get_mangled_name(void) const
   {
#if 0
  // printf ("In $CLASSNAME::get_mangled_name() name = %s \n",SageInterface::get_name(this).c_str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName variableNames = "_args_";
     SgInitializedNamePtrList::const_iterator p = get_args().begin();
     while ( p != get_args().end() )
        {
       // DQ (2/22/2007): Added type to generated mangled name for each variable (supports AST merge generation of name for un-named classes)
       // variableNames += SgName("_variable_name_") + (*p)->get_mangled_name();
          variableNames += SgName("_variable_type_") + (*p)->get_type()->get_mangled() + SgName("_variable_name_") + (*p)->get_mangled_name();

          p++;
        }

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_function_parameter_list_") + variableNames;
     returnName = scope->get_mangled_name() + SgName("_function_parameter_list_") + variableNames;

  // printf ("Warning: mangled name for %s not yet defined (SgFunctionParameterList::get_mangled_name() called) \n",class_name().c_str());

     return returnName;
#else
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
  // SgFunctionParameterList* declaration = const_cast<SgFunctionParameterList*>(this);
  // std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
  // if (i != p_globalMangledNameMap.end())
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgFunctionParameterList*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName variableNames = "_args_";
          SgInitializedNamePtrList::const_iterator p = get_args().begin();
          while ( p != get_args().end() )
             {
            // DQ (2/22/2007): Added type to generated mangled name for each variable (supports AST merge generation of name for un-named classes)
               variableNames += SgName("_variable_type_") + (*p)->get_type()->get_mangled() + SgName("_variable_name_") + (*p)->get_mangled_name();

               p++;
             }

       // DQ (6/22/2010): Better to use the function name instead of the scopes mangled name.  This helps disambiguate
       // code such as:
       //    typedef struct Domain_s { } Domain_t;
       //    int foo ( Domain_s *domain);
       //    int foo ( Domain_t *domain);
       // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
       // This is a poor way to handle the generation of a mangled name (will be improved)
          SgName mangledName = get_scope()->get_mangled_name() + SgName("_function_parameter_list_") + variableNames;
       // SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(get_parent());
       // ROSE_ASSERT(functionDeclaration != NULL);
       // SgName mangledName = functionDeclaration->get_mangled_name() + SgName("_function_parameter_list_") + variableNames;

       // printf ("Inside of SgFunctionParameterList::get_mangled_name(void): mangledName = %s \n",mangledName.str());

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgFunctionParameterList*>(this),mangledName);
       // printf ("RETURN: Inside of SgFunctionParameterList::get_mangled_name(void): mangledName = %s \n",mangledName.str());

          return mangledName;
        }
#endif
   }

SOURCE_FUNCTION_PARAMETER_LIST_END


SOURCE_FUNCTION_DECLARATION_STATEMENT_PARSER_START

// This is a specialized parse function for the $CLASSNAME class defined in Statement.code

// We include the "Sg" in the name of the parse function because we want each grammar's
// collection of overloaded parse functions to return the root node of that grammar.  Since multiple
// grammars exist we have to have different collections of overloaded parse functions return different
// types, and overloaded functions must return the same type (C++ language constraint).  The solution is to have
// the overloaded parse functions for each grammar share the names that are unique to that grammar only.
// thus we prefix the parse member function name with "Sg".


SgNode*
Sgparse ( $PARENT_GRAMMARS_PREFIX_FunctionDeclaration* Xptr )
   {
  // Function description:
  // This function parses the lower level grammar into a higher level grammar

  // Specifics of this function:
  // We could bury the reference to the project into this function since their is only one global scope
  // Or we could pass the project as a parameter to this function (since it is the root of all program trees?)

     printf ("Inside of INCOMPLETE $CLASSNAME friend function Sgparse($PARENT_GRAMMARS_PREFIX_Global*) \n");

#if 0
  // This makes no sense 

  // Error checking
     ROSE_ASSERT(Xptr != NULL);
     ROSE_ASSERT(Xptr->getGrammar() != NULL);
     if (Xptr->getGrammar()->isRootGrammar() == true)
        {
       // it is an error for isRootGrammar() == true
          printf ("ERROR: isRootGrammar() == true in SgScopeStatement::parse ( $PARENT_GRAMMARS_PREFIX_ScopeStatement* X )! \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT(Xptr->getGrammar()->isRootGrammar() == false);
#endif

#if 0
  // Later we will automate the generation of this code
  // $PARSE_CODE_FOR_LIST

     printf ("function declaration name = %s \n",Xptr->get_name().str());

     $PARENT_GRAMMARS_PREFIX__File_Info* parentGrammarFileInfo = Xptr->get_file_info();
     ROSE_ASSERT (parentGrammarFileInfo != NULL);
     Sg_File_Info* new_fileInfo = 
          new Sg_File_Info (parentGrammarFileInfo->get_filename(),
                                          parentGrammarFileInfo->get_line(),
                                          parentGrammarFileInfo->get_col());
     ROSE_ASSERT (new_fileInfo != NULL);

#if 1
  // Build a new name object (all are identical to SgName)
     SgName* new_name = new SgName (Xptr->get_name().str());
     ROSE_ASSERT (new_name != NULL);

     printf ("WARNING: Need to specify more date to the $CLASSNAME constructor! \n");

     $CLASSNAME* returnValuePtr = new $CLASSNAME(new_fileInfo,new_name);
     ROSE_ASSERT (returnValuePtr != NULL);
#else
     $CLASSNAME* returnValuePtr = NULL; // new $CLASSNAME(new_fileInfo);
#endif
#endif

     $CLASSNAME* returnValuePtr = NULL;
     ROSE_ASSERT (returnValuePtr != NULL);

     return returnValuePtr;
   }

SOURCE_FUNCTION_DECLARATION_STATEMENT_PARSER_END



SOURCE_FUNCTION_DEFINTION_STATEMENT_START

// DQ (10/4/2006): Support for static map of SgBasicBlock IR nodes to integers.
// std::map<SgBasicBlockPtr, int> SgFunctionDefinition::p_block_number_map;

void
SgFunctionDefinition::post_construction_initialization()
   { }

SgFunctionDefinition::SgFunctionDefinition(Sg_File_Info* f, SgFunctionDeclaration* d, SgBasicBlock* body)
   : SgScopeStatement(f), p_body(body)
   {
     set_declaration(d); 
     if (d!=NULL) // Liao, 4/14/2009. Support bottom-up AST building: definition is built first, declaration may be still NULL 
      d->set_definition(this);
   }

SgFunctionDefinition::SgFunctionDefinition( SgFunctionDeclaration* d, SgBasicBlock* body)
   : SgScopeStatement(), p_body(body)
   {
     set_declaration(d); 
     if (d!=NULL)
      d->set_definition(this);
   }

SgFunctionDeclaration*
SgFunctionDefinition::get_declaration() const
   {
     SgNode* res = get_parent();
     SgFunctionDeclaration* res1 = isSgFunctionDeclaration(res); 
     assert( res == 0 || res1 != 0);
     return res1;
   }

void
SgFunctionDefinition::set_declaration(SgFunctionDeclaration* new_val)
   {
     set_parent(new_val);
   }

bool
SgFunctionDefinition::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     return ( StatementReplace(this, p_body, target, newstmt) == true );
   }

void
SgFunctionDefinition::append_statement(SgStatement * what)
   {
     assert(this != NULL);
     if (!get_body())
        {
          set_body(new SgBasicBlock(New_File_Info(this)));
        }
     get_body()->append_statement(what);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

void
SgFunctionDefinition::prepend_statement(SgStatement *what)
   {
     assert(this != NULL);
     if(!get_body()) {
          set_body(new SgBasicBlock(New_File_Info(this)));
     }
     get_body()->prepend_statement(what);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

// RV (2/5/2006): Added name mangling for function definitions
SgName
SgFunctionDefinition::get_mangled_name (void) const
   {
     const SgFunctionDeclaration* decl = get_declaration ();
     ROSE_ASSERT (decl);
     return decl->get_mangled_name ();
   }

// DQ (10/5/2006): Added support for faster (non-quadratic) computation of unique 
// labels for scopes in a function (as required for name mangling).
std::map<SgNode*,int> &
SgFunctionDefinition::get_scope_number_list()
   {
     return p_scope_number_list;
   }

// DQ (10/5/2006): Added support for faster (non-quadratic) computation of unique 
// labels for scopes in a function (as required for name mangling).
int
SgFunctionDefinition::get_scope_number ( const SgNode* scope ) const
   {
     SgFunctionDefinition* modifiableThis = const_cast<SgFunctionDefinition*>(this);
     SgNode* modifiableScope = const_cast<SgNode*>(scope);
     if (p_scope_number_list.empty() == true)
        {
       // Build a local reference that can be modified (cast cost from this cost function to get access).
          modifiableThis->resetScopeNumbers();
        }

     ROSE_ASSERT (p_scope_number_list.empty() == false);

  // int uniqueScopeNumber = p_scope_number_list[scope];

  // Make sure that the required entry is in the map!
     std::map<SgNode*, int>::const_iterator iter = this->p_scope_number_list.find(modifiableScope);
     if (iter == this->p_scope_number_list.end())
        {
#if 0
          printf ("In Function = %p = %s = %s \n",get_declaration(),get_declaration()->class_name().c_str(),SageInterface::get_name(get_declaration()).c_str());
          printf ("Looking for scope = %p = %s \n",scope,scope->class_name().c_str());
          scope->get_startOfConstruct()->display("Error: SgFunctionDefinition::get_scope_number: input scope debug");
          get_startOfConstruct()->display("Error: SgFunctionDefinition::get_scope_number: debug");
          for (std::map<SgNode*,int>::const_iterator i = p_scope_number_list.begin(); i != p_scope_number_list.end(); i++)
             {
               printf ("i->first = %p = %s i->second = %d \n",i->first,i->first->class_name().c_str(),i->second);
             }
#else
          int n = (int)modifiableThis->p_scope_number_list.size() + 1;
          modifiableThis->p_scope_number_list[modifiableScope] = n;
          iter = this->p_scope_number_list.find(modifiableScope);
#endif
        }
     ROSE_ASSERT(iter != this->p_scope_number_list.end());

     int uniqueScopeNumber = iter->second;

#if 0
     printf ("uniqueScopeNumber = %d for scope = %p = %s of function = %s \n",
          uniqueScopeNumber,scope,scope->class_name().c_str(),get_declaration()->get_name().str());
#endif

     ROSE_ASSERT(uniqueScopeNumber > 0);

     return uniqueScopeNumber;
   }

void
SgFunctionDefinition::clearScopeNumbers()
   {
  // std::map<SgNode*,int> & scopeMap = get_scope_number_list();
  // ROSE_ASSERT(scopeMap.empty() == true);

  // This functionality is moved out of the IR node to were it can be more easily developed (initially at least).
     SageInterface::clearScopeNumbers(this);
   }

void
SgFunctionDefinition::resetScopeNumbers()
   {
  // This function will be called automatically when get_scope_number() is call if the p_scope_number_list is empty.

  // std::map<SgNode*,int> & scopeMap = get_scope_number_list();
  // ROSE_ASSERT(scopeMap.empty() == true);

  // This functionality is moved out of the IR node to were it can be more easily developed (initially at least).
     SageInterface::resetScopeNumbers(this);
   }

std::ostream & operator<< ( std::ostream & os, std::map<SgNode*,int> & x )
   {
  // printf ("Error: Not implemented, operator<< ( std::ostream & os, std::map<SgNode*,int> & x ) \n");
  // os << " pair (" << (*x).first.str() << "," << ((*x).second) << ")";

     os << "output operator for std::map<SgNode*,int> not implemented";
     return os;
   }

// DQ (1/8/2007): Added to support qualified name generation (this forces 
// function parameters to have the correct qualified name, same as local
// variables declared in the scope of the function more directly (which
// is handled by having a special implementation of "SgBasicBlock::get_qualified_name() const"
SgName
SgFunctionDefinition::get_qualified_name() const
   {
  // DQ (8/28/2005): This is where we might name blocks if we select to do so at some point
  // as a way of building unique names for qualified named declarations.

  // Note that this will still evaluate so that "returnName.is_null()" will be true
     SgName returnName = "";
     return returnName;
   }


// MD (09/20/2010): Accessor for preinitialization lists associated with 
// this (constructor) definition. NULL if this has no such list.
SgCtorInitializerList* 
SgFunctionDefinition::get_CtorInitializerList() const {
  SgMemberFunctionDeclaration* memDecl = NULL;
  SgCtorInitializerList* ctorList = NULL;
  if ((memDecl = isSgMemberFunctionDeclaration(get_declaration())) != NULL &&
      (ctorList = memDecl->get_CtorInitializerList()) != NULL)
      return ctorList;
  else
    return NULL;
}

SOURCE_FUNCTION_DEFINTION_STATEMENT_END

SOURCE_FUNCTION_DEFINTION_STATEMENT_PARSER_START

// This is a specialized parse function for the $CLASSNAME class defined in Statement.code

// We include the "Sg" in the name of the parse function because we want each grammar's
// collection of overloaded parse functions to return the root node of that grammar.  Since multiple
// grammars exist we have to have different collections of overloaded parse functions return different
// types, and overloaded functions must return the same type (C++ language constraint).  The solution is to have
// the overloaded parse functions for each grammar share the names that are unique to that grammar only.
// thus we prefix the parse member function name with "Sg".


SgNode*
Sgparse ( $PARENT_GRAMMARS_PREFIX_FunctionDefinition* Xptr )
   {
  // Function description:
  // This function parses the lower level grammar into a higher level grammar

  // Specifics of this function:
  // We could bury the reference to the project into this function since their is only one global scope
  // Or we could pass the project as a parameter to this function (since it is the root of all program trees?)

     printf ("Inside of $CLASSNAME friend function Sgparse($PARENT_GRAMMARS_PREFIX_Global*) \n");

#if 0
  // This makes no sense 

  // Error checking
     ROSE_ASSERT(Xptr != NULL);
     ROSE_ASSERT(Xptr->getGrammar() != NULL);
     if (Xptr->getGrammar()->isRootGrammar() == true)
        {
       // it is an error for isRootGrammar() == true
          printf ("ERROR: isRootGrammar() == true in SgScopeStatement::parse ( $PARENT_GRAMMARS_PREFIX_ScopeStatement* X )! \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT(Xptr->getGrammar()->isRootGrammar() == false);
#endif

  // Later we will automate the generation of this code
  // $PARSE_CODE_FOR_LIST

  // printf ("function name = %s \n",p_name.str());

     $PARENT_GRAMMARS_PREFIX__File_Info* parentGrammarFileInfo = Xptr->get_file_info();
     ROSE_ASSERT (parentGrammarFileInfo != NULL);
     Sg_File_Info* fileInfo = 
          new Sg_File_Info (parentGrammarFileInfo->get_filename(),
                                          parentGrammarFileInfo->get_line(),
                                          parentGrammarFileInfo->get_col());
     ROSE_ASSERT (fileInfo != NULL);

     printf ("WARNING Need more data for $CLASSNAME constructor! \n");

     $CLASSNAME* returnValuePtr = new $CLASSNAME(fileInfo);
     ROSE_ASSERT (returnValuePtr != NULL);

     return returnValuePtr;
   }

SOURCE_FUNCTION_DEFINTION_STATEMENT_PARSER_END


SOURCE_MEMBER_FUNCTION_DECLARATION_STATEMENT_START

bool
SgMemberFunctionDeclaration::isDefinedInClass() const
   {
     bool returnValue = false;

  // If the scopes are the same then the class is structurally defined in the class scope
     bool isDefiningDeclaration  = (get_definition() != NULL);
     bool isDeclaredInClassScope = (get_parent() == get_scope());
     if ( (isDefiningDeclaration == true) && (isDeclaredInClassScope == true) )
          returnValue = true;

     return returnValue;
   }


void
SgMemberFunctionDeclaration::post_construction_initialization()
   {
  // DQ (9/15/2005): Remove side-effect from get_ctors() member function.
  // This was a problem for the AST tests where the post processing saw a 
  // NULL pointer and then the unparser was called in the rewrite mechanism 
  // and then the AST tests failed because the pointer was non-NULL (and 
  // also the SgCtorInitializerList had not been properly setup).
  // p_CtorInitializerList = new SgCtorInitializerList(New_File_Info(this));
     if (get_startOfConstruct() != NULL)
        {
          p_CtorInitializerList = new SgCtorInitializerList(New_File_Info(this));
        }
       else
        {
          p_CtorInitializerList = new SgCtorInitializerList();
        }
     ROSE_ASSERT(p_CtorInitializerList != NULL);

  // Like the "enum" declaration (SgEnumDeclaration) this can only be defined 
  // once, so it is its defining declaration.  Well, not exactly.  The uniform
  // handling of the defining and non-defining declarations requires that this
  // be set as the firstNondefining declaration.  This might be an error and 
  // should be reviewed.

  // DQ (9/20/2005): Need to set the nondefining declaration instead of the defining declaration!
  // p_CtorInitializerList->set_definingDeclaration(p_CtorInitializerList);
     p_CtorInitializerList->set_firstNondefiningDeclaration(p_CtorInitializerList);

  // DQ (9/21/2005): Added warning since this is an issue worth review! 
  // printf ("Warning: Set p_CtorInitializerList = %p firstNondefiningDeclaration to self, unclear if this is correct \n",p_CtorInitializerList);

  // DQ (9/21/2005): set the parent so that the scope will be computed correctly
  // (scope is not stored explicitly on the SgCtorInitializerList IR node).
     p_CtorInitializerList->set_parent(this);
   }

void
SgMemberFunctionDeclaration::append_ctor_initializer( SgInitializedName* iName)
   {
     ROSE_ASSERT(p_CtorInitializerList != NULL);
  // if (get_CtorInitializerList() == NULL) 
  //     set_CtorInitializerList(new SgCtorInitializerList(New_File_Info(this)));
     get_CtorInitializerList()->append_ctor_initializer(iName);
   }

void
SgMemberFunctionDeclaration::prepend_ctor_initializer( SgInitializedName* iName)
   {
     ROSE_ASSERT(p_CtorInitializerList != NULL);
  // if (get_CtorInitializerList() == NULL) 
  //     set_CtorInitializerList(new SgCtorInitializerList(New_File_Info(this)));
     get_CtorInitializerList()->prepend_ctor_initializer(iName);
   }

SgInitializedNamePtrList & 
SgMemberFunctionDeclaration::get_ctors()
   {
     ROSE_ASSERT(p_CtorInitializerList != NULL);
  // if (get_CtorInitializerList() == NULL) 
  //    set_CtorInitializerList(new SgCtorInitializerList(New_File_Info(this)));
     return get_CtorInitializerList()->get_ctors();
   }

const SgInitializedNamePtrList &
SgMemberFunctionDeclaration::get_ctors() const
   {
     ROSE_ASSERT(get_CtorInitializerList() != NULL);
     return get_CtorInitializerList()->get_ctors();
   }

// SgName SgMemberFunctionDeclaration::get_qualified_name(); 
SgName
SgMemberFunctionDeclaration::get_qualified_name() const
   {
  // DQ (8/28/2005): Modified to make this function consistent other get_qualified_name functions
  // It previously only returned the name of the class to which is was a member function!
  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName returnName = SgName::assembleQualifiedName (scope->get_qualified_name(), get_name ());

  // printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
   }

void
SgMemberFunctionDeclaration::set_orig_return_type(SgType *t)
   {
   // QY: removed p_orig_return_type. reset p_type by making another member function type (the original p_type might be shared?)
  // DQ (10/6/2004): Not sure why this works this way!
     ROSE_ASSERT(t != NULL);

     SgMemberFunctionType *ntype = isSgMemberFunctionType(get_type())->mkAnotherType(t);
     ROSE_ASSERT (ntype != NULL);
     set_type(ntype); // reset function type if necessary
   }

bool
SgMemberFunctionDeclaration::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( SgFunctionDeclaration::replace_child(target, newstmt,extractBasicBlock) == true )
        {
          return true;
        }
       else
        {
       // Handle other possible replacements
          if ( StatementReplace(this, p_scope, target, newstmt) == true )
             {
               return true;
             }
            else
             {
               return ( StatementReplace(this, p_CtorInitializerList, target, newstmt) == true );
             }
        }
   }

// DQ (10/12/2007): This is no longer a ROSETTA generated function, so that we can hide the get_associatedClassDeclaration 
// member, making it private to only support the SgMemberFunctionDeclaration::get_class_scope() member function.
SgClassDeclaration* 
SgMemberFunctionDeclaration::get_associatedClassDeclaration () const
   {
     assert (this != NULL);
  // return p_associatedClassDeclaration;

     SgClassDeclaration* returnValue = NULL;

  // The p_associatedClassDeclaration is only set when the class definition is unavailable (not defined in the current 
  // translation unit) and yet there is a class declared for there to be a member function declared.  This is always 
  // the case of a pointer to a member function, since only in this case can the pointer to a member function be declared 
  // without a member function having been declared.
     if (p_associatedClassDeclaration != NULL)
        {
       // If this is a valid pointer then it is only because the class definition has not been seen (and this backup 
       // mechanism has been used to relate the member function to the class declaration).
          returnValue = p_associatedClassDeclaration;
        }
       else
        {
       // When p_associatedClassDeclaration == NULL, it is because the class definition exists (and the backup mechanism 
       // of relating the member function to the class declaration was not required) and so the class declaration can be 
       // obtained directly from the class definition.
          SgClassDefinition* scope = get_class_scope();

       // Testing ...
       // ROSE_ASSERT(scope != NULL);
          if (scope == NULL)
             {
               printf ("ERROR: retuning NULL from SgMemberFunctionDeclaration::get_associatedClassDeclaration \n");
               return NULL;
             }
            else
             {
               returnValue = scope->get_declaration();
             }
        }

     return returnValue;
   }

// DQ (10/12/2007): This is no longer a ROSETTA generated function, so that we can hide the get_associatedClassDeclaration 
// member, making it private to only support the SgMemberFunctionDeclaration::get_class_scope() member function.
// This SgMemberFunctionDeclaration::set_associatedClassDeclaration() member function is public so that it can be set in 
// construction of the AST.
void
SgMemberFunctionDeclaration::set_associatedClassDeclaration ( SgClassDeclaration* associatedClassDeclaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_associatedClassDeclaration != NULL && associatedClassDeclaration != NULL && p_associatedClassDeclaration != associatedClassDeclaration)
        {
          printf ("Warning: associatedClassDeclaration = %p overwriting valid pointer p_associatedClassDeclaration = %p \n",associatedClassDeclaration,p_associatedClassDeclaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_associatedClassDeclaration != NULL && associatedClassDeclaration != NULL && p_associatedClassDeclaration != associatedClassDeclaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_associatedClassDeclaration = associatedClassDeclaration;
   }

SgClassDefinition* 
SgMemberFunctionDeclaration::get_class_scope(void) const
   {
  // DQ (10/12/2007): It is OK for this to be NULL! If it is NULL, then the get_associatedClassDeclaration() has the class declaration!

  // DQ (12/5/2004): The scope is explicit and should be a valid pointer (if not it is an error!)
  // ROSE_ASSERT(p_scope != NULL);

  // DQ (11/17/2004): Note that get_scope returns a SgScopeStatement, but member functions are always part 
  // of a SgClassDefinition and we want to reflect this and be as consistent as possible with the former 
  // get_scope() function which was only defined on the SgMemberFunctionDeclaration but is now defined on 
  // many different IR nodes (as a result of a major bug fix specific to scopes vs. parents handling).
  // SgClassDefinition *parentScope = isSgClassDefinition(get_scope());
     SgClassDefinition* parentScope = NULL;

  // DQ (10/12/2007): Modified to access the p_associatedClassDeclaration data member directly because
  // the get_associatedClassDeclaration() member function is more than an access function (no longer built be ROSETTA).
  // DQ (7/26/2007): Member function pointers don't require a SgClassDefinition so we have no scope 
  // for such cases, to make up for this, we explicitly store the class declaration.
  // SgClassDeclaration* classDeclaration = this->get_associatedClassDeclaration();
     SgClassDeclaration* classDeclaration = this->p_associatedClassDeclaration;
     if (classDeclaration != NULL)
        {
          parentScope = NULL;
          SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(classDeclaration->get_definingDeclaration());
          if (definingClassDeclaration != NULL)
               parentScope = definingClassDeclaration->get_definition();

          if (parentScope != NULL)
             {
               printf ("SgMemberFunctionDeclaration::get_class_scope(): memberFunction = %p = %s = %s classDeclaration = %p = %s = %s \n",
                    this,this->class_name().c_str(),SageInterface::get_name(this).c_str(),
                    classDeclaration,classDeclaration->class_name().c_str(),SageInterface::get_name(classDeclaration).c_str());
             }
       // ROSE_ASSERT(parentScope != NULL);
        }
       else
        {
       // DQ (7/26/2007): Moved from top of function
          ROSE_ASSERT(p_scope != NULL);

       // DQ (10/15/2007): Added assertion.
          ROSE_ASSERT(this->get_parent() != NULL);

       // SgClassDefinition *parentScope = isSgClassDefinition(get_scope());
          parentScope = isSgClassDefinition(get_scope());

       // The scope associated with a member function had better be a SgClassDefinition!
       // if (this->get_associatedClassDeclaration() != NULL || parentScope == NULL)
          if (parentScope == NULL)
             {
            // DQ (12/5/2004): Note that new member function declarations added from the rewrite system 
            // allow there scope to be derived from the parent node.  This results in incorrect information 
            // which is later discovered in the unparser!  Need to do a better job of setting the scope of
            // all statements when introduced from the rewrite mechanism.

               ROSE_ASSERT(get_name().is_null() == false);
               printf ("Error in $CLASSNAME::get_class_scope() member function name = %s (can be incorrect due to rewrite system) \n",get_name().str());
               printf ("     get_parent() = %p = %s \n",get_parent(),(get_parent() != NULL) ? get_parent()->sage_class_name() : "NULL");
               printf ("     p_scope      = %p = %s \n",p_scope,p_scope->sage_class_name());
             }
       // ROSE_ASSERT(parentScope != NULL);
        }

  // DQ (10/12/2007): It is OK for this to be NULL! If it is NULL, then the get_associatedClassDeclaration() has the class declaration!
  // ROSE_ASSERT(parentScope != NULL);
     return parentScope;
   }


// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgMemberFunctionDeclaration::get_symbol_from_symbol_table() const
   {
#if 0
     printf ("In SgMemberFunctionDeclaration::get_symbol_from_symbol_table(): this = %p = %s = %s scope = %p = %s scope->get_symbol_table() = %p \n",
          this,this->class_name().c_str(),SageInterface::get_name(this).c_str(),get_scope(),get_scope()->class_name().c_str(),get_scope()->get_symbol_table());
#endif

     SgSymbol* symbol = NULL;
     if (get_scope() == NULL)
        {
          printf ("In SgMemberFunctionDeclaration::get_symbol_from_symbol_table(): get_scope() == NULL for %p = %s \n",this,this->class_name().c_str());
          symbol = NULL;
        }
       else
        {
          ROSE_ASSERT(get_scope() != NULL);
          ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
          symbol = get_scope()->get_symbol_table()->find(this);
        }

     return symbol;
   }

SOURCE_MEMBER_FUNCTION_DECLARATION_STATEMENT_END


SOURCE_CTOR_INITIALIZER_LIST_START

void
SgCtorInitializerList::post_construction_initialization()
   {
     if (get_file_info() != NULL)
        {
          Sg_File_Info* endingPosition = new Sg_File_Info(*(get_file_info()));
          ROSE_ASSERT (endingPosition != NULL);

       // DQ (12/18/2006): Added to set all parents of Sg_File_Info objects.
          endingPosition->set_parent(this);

          set_endOfConstruct(endingPosition);
        }
   }

/* SgInitializedName tuple: (SgName, type, Initializer) */
void
SgCtorInitializerList::append_ctor_initializer( SgInitializedName* iName)
   {
     get_ctors().insert(get_ctors().end(), iName);
   }

void
SgCtorInitializerList::prepend_ctor_initializer( SgInitializedName* iName)
   {
     get_ctors().insert(get_ctors().begin(), iName);
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgCtorInitializerList::get_mangled_name(void) const
   {
  // printf ("In $CLASSNAME::get_mangled_name() name = %s \n",SageInterface::get_name(this).c_str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName memberNames;
     SgInitializedNamePtrList::const_iterator p = get_ctors().begin();
     while ( p != get_ctors().end() )
        {
       // DQ (2/22/2007): Added type to generated mangled name for each variable (supports AST merge generation of name for un-named classes)
       // memberNames += SgName("_variable_name_") + (*p)->get_mangled_name();
          memberNames += SgName("_variable_type_") + (*p)->get_type()->get_mangled() + SgName("_variable_name_") + (*p)->get_mangled_name();

          p++;
        }

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_constructor_initialization_list_") + memberNames;
     returnName = scope->get_mangled_name() + SgName("_constructor_initialization_list_") + memberNames;

  // printf ("Warning: mangled name for %s not yet defined (SgFunctionParameterList::get_mangled_name() called) \n",class_name().c_str());

     return returnName;
   }

SOURCE_CTOR_INITIALIZER_LIST_END


SOURCE_VARIABLE_DECLARATION_STATEMENT_START

SgVariableDeclaration::SgVariableDeclaration(Sg_File_Info *info, const SgName& var_name, SgType *type, SgInitializer *initializer)
   : SgDeclarationStatement(info)
   {
  // DQ (11/10/2006): Ultimately, i think this constructor should be eliminated since it will be
  // redundant with a higher level interface which is planned and it is not automatically generated.
     ROSE_ASSERT (this != NULL);

  // printf ("Inside of SgVariableDeclaration constructor taking all parameters \n");
     initializeData (info,var_name,type,initializer);
   }

SgVariableDeclaration::SgVariableDeclaration( const SgName& var_name, SgType *type, SgInitializer *initializer)
   {
  // DQ (11/10/2006): Ultimately, i think this constructor should be eliminated since it will be
  // redundant with a higher level interface which is planned and it is not automatically generated.
     ROSE_ASSERT (this != NULL);

  // printf ("Inside of SgVariableDeclaration constructor taking all parameters \n");
     initializeData (NULL,var_name,type,initializer);
   }

void
SgVariableDeclaration::initializeData(Sg_File_Info *info, const SgName& var_name, SgType *type, SgInitializer *initializer)
   {
     ROSE_ASSERT (this != NULL);

  // DQ (7/20/2006): Suggested by Peter to so that the initializer will be used.
  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // SgInitializedName c_item(var_name, type, 0, this);
  // SgInitializedName* c_item = new SgInitializedName(var_name, type, NULL, this);
     SgInitializedName* c_item = new SgInitializedName(var_name, type, initializer, this);
     ROSE_ASSERT (c_item != NULL);

  // DQ (10/10/2007): Added fix for Liao, this is required when using the alternative constructors.
  // DQ (10/10/2007): fixed the segmentation fault occurred in liaOutliner for class ::A this__ptr__ 
     p_variableDeclarationContainsBaseTypeDefiningDeclaration = false;

  // DQ(10/10/2007): Added initialization of another data member.
     p_baseTypeDefiningDeclaration = NULL; // non list case 

  // DQ(10/10/2007): Added initialization of another data member.
     p_specialization = SgDeclarationStatement::e_no_specialization;

  // DQ(10/10/2007): Added initialization of another data member.
     p_requiresGlobalNameQualificationOnType = false;

#if PRINT_DEVELOPER_WARNINGS
     printf ("Inside of SgVariableDeclaration::initializeData for constructor taking all parameters c_item = %p = %s \n",c_item,c_item->get_name().str());
#endif

  // DQ (6/8/2006): Need to set parent and scope of internally built variable
     c_item->set_parent(this);
  // c_item->set_scope();
  // ROSE_ASSERT(c_item->get_scope() != NULL);

#if 1
  // PC (7/14/2006): Set initializer's parent, as expected by inliner
  // DQ (7/20/2006): this would be better handled by the code calling this 
  // constructor since this is now a side-effect on "initializer".
     if (initializer != NULL)
        {
          initializer->set_parent(c_item);
        }
#endif

  // DQ (11/10/2006): Added support for null file info pointer so that this could could be used by both constructors.
     if (info != NULL)
        {
       // DQ (8/3/2004): Need to set the file info on this SgInitializedName object (use a copy)
          Sg_File_Info* copyOfFileInfo = new Sg_File_Info(*info);
          ROSE_ASSERT (copyOfFileInfo != NULL);

       // DQ (12/18/2006): Added to set all parents of Sg_File_Info objects.
          copyOfFileInfo->set_parent(c_item);

       // DQ (1/18/2006): Changed name to be consistent with SgNode::get_file_info()
       // c_item->set_fileInfo(copyOfFileInfo);
       // c_item->set_file_info(copyOfFileInfo);
          c_item->set_startOfConstruct(copyOfFileInfo);

        }

  // DQ (12/15/2006): We are using the initializer in both the SgInitializedName and the 
  // SgVariableDefinition.  We have to pass the initializer to append_variable() because
  // the SgVariableDefinition is built there and we we have removed the code below that 
  // used to reset it.  This implementation is better because we don't reset the initializer
  // and the SgVariableDefinition, however that means we have to set it correctly the first time!
  // So we pass the initializer into the append_variable() member function.
  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // SgInitializedName *decl_item=&(*(this->append_variable(c_item,0)));
  // SgInitializedName *decl_item = *(this->append_variable(c_item,NULL));
     /* SgInitializedName *decl_item = */ this->append_variable(c_item,initializer);

  // DQ (6/1/2004): Can we enforce this?
  // ROSE_ASSERT (decl_item == c_item);

  // DQ (10/6/2004): Adding documentation - this is to support the unparser and is always set to be true (so it seems).
  // A newer mechanism explicitly marks the variable declaration if it contains a class definition which must be output 
  // when unparsing.
  // Older comment: for class-P var, the definition part of class-P won't get printed
     this->setNameOnly();

  // DQ (11/18/2007): This should have been called anyway, but this adds support for Fortran declaration attributes.
     post_construction_initialization();
   }

void
SgVariableDeclaration::post_construction_initialization()
   {
  // DQ (11/18/2007): Added support for Fortran declaration attributes
  // p_fortran_attribute_spec = SgBitVector(SgAttributeSpecificationStatement::e_last_attribute_spec,false);
   }


#if 0
// This is now stored in the type modifier (I think this is a better implementation)

bool SgVariableDeclaration::isDefault() const { return checkBit(e_default,p_fortran_attribute_spec); }
void SgVariableDeclaration::setDefault()      { setBit(e_default,p_fortran_attribute_spec); }
void SgVariableDeclaration::unsetDefault()    { unsetBit(e_default,p_fortran_attribute_spec); }

// Fortran specific declaration attribute support
bool testAccess_private_Attribute() const { return checkBit(e_default,p_fortran_attribute_spec); }
void setAccess_private_Attribute()        { setBit(e_default,p_fortran_attribute_spec); }
void unsetAccess_private_Attribute()      { unsetBit(e_default,p_fortran_attribute_spec); }

bool testAccess_protected_Attribute() const;
void setAccess_protected_Attribute();
void unsetAccess_protected_Attribute();

bool testAccess_public_Attribute() const;
void setAccess_public_Attribute();
void unsetAccess_public_Attribute();

bool testAllocatableAttribute() const;
void setAllocatableAttribute();
void unsetAllocatableAttribute();

bool testAsynchronousAttribute() const;
void setAsynchronousAttribute();
void unsetAsynchronousAttribute();

bool testBindAttribute() const;
void setBindAttribute();
void unsetBindAttribute();

bool testDataAttribute() const;
void setDataAttribute();
void unsetDataAttribute();

bool testDimensionAttribute() const;
void setDimensionAttribute();
void unsetDimensionAttribute();

bool testExternalAttribute() const;
void setExternalAttribute();
void unsetExternalAttribute();

bool testIntent_in_Attribute() const;
void setIntent_in_Attribute();
void unsetIntent_in_Attribute();

bool testIntent_out_Attribute() const;
void setIntent_out_Attribute();
void unsetIntent_out_Attribute();

bool testIntent_inout_Attribute() const;
void setIntent_inout_Attribute();
void unsetIntent_inout_Attribute();

bool testIntrinsicAttribute() const;
void setIntrinsicAttribute();
void unsetIntrinsicAttribute();

bool testOptionalAttribute() const;
void setOptionalAttribute();
void unsetOptionalAttribute();

bool testParameterAttribute() const;
void setParameterAttribute();
void unsetParameterAttribute();

bool testPointerAttribute() const;
void setPointerAttribute();
void unsetPointerAttribute();

bool testProtectedAttribute() const;
void setProtectedAttribute();
void unsetProtectedAttribute();

bool testSaveAttribute() const;
void setSaveAttribute();
void unsetSaveAttribute();

bool testTargetAttribute() const;
void setTargetAttribute();
void unsetTargetAttribute();

bool testValueAttribute() const;
void setValueAttribute();
void unsetValueAttribute();

bool testVolatileAttribute() const;
void setVolatileAttribute();
void unsetVolatileAttribute();

#endif


// given a decl_item
SgVariableDefinition*
SgVariableDeclaration::get_definition(SgInitializedName *ditem)
   {
     SgVariableDefinition *defn_stmt = NULL;
     SgInitializedName    *defn_item = NULL;
#if 0
     printf ("In SgVariableDeclaration::get_definition(): ditem = %p \n",ditem);
#endif
     SgInitializedNamePtrList::iterator p = get_variables().begin();
     while ( p != get_variables().end() && ditem )
        {
       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
          ROSE_ASSERT ((*p) != NULL);
#if 0
          printf ("In SgVariableDeclaration::get_definition(): loop through variables *p = %p \n",*p);
#endif
          if (ditem == (*p))
             {
            // QY 11/2/04 set defn_item = *p
            //  defn_item = (*p)->get_named_item();
               defn_item = (*p);
               break;
             }
          p++;
        }

     if (ditem == NULL)
        {
       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
       // defn_item=(*p).get_named_item();
          ROSE_ASSERT ((*p) != NULL);
       // QY 11/2/04 set defn_item = *p
       //   defn_item=(*p)->get_named_item();
          defn_item = *p;
        }
       else 
        {
          return NULL;
        }
#if 0
     printf ("In SgVariableDeclaration::get_definition(): defn_item = %p \n",defn_item);
#endif

  // if (defn_item)
     if (defn_item != NULL)
        {
#if 0
          printf ("In SgVariableDeclaration::get_definition(): defn_item->get_definition() = %p \n",defn_item->get_definition());
          if (defn_item->get_definition() != NULL)
               printf ("In SgVariableDeclaration::get_definition(): defn_item->get_definition() = %s \n",defn_item->get_definition()->class_name().c_str());
#endif
       // DQ (9/9/2007): I think we can assert this for any SgInitializedName found in a SgVariableDeclaration, 
       // else perhaps we should have this function return a SgDeclarationStatement instead of a SgVariableDefinition.
          ROSE_ASSERT(defn_item->get_definition() == NULL || isSgVariableDefinition(defn_item->get_definition()) );

          defn_stmt = isSgVariableDefinition(defn_item->get_definition());
       // assert(defn_stmt);
        }

     return defn_stmt;
   }

SgUnsignedLongVal*
SgVariableDeclaration::get_bitfield()
   {
     assert(get_definition() != 0);
     return get_definition()->get_bitfield();
   }

void
SgVariableDeclaration::set_bitfield (SgUnsignedLongVal *bfield)
   {
     assert(get_definition() != 0);
     get_definition()->set_bitfield(bfield);
   }

void
SgVariableDeclaration::setStatic()
   {
     SgDeclarationStatement::setStatic();
  // if it is a static member data

     printf ("Error: SgVariableDeclaration::setStatic() is deprecated \n");

  // SgStatement* parentPointer = get_parent();
     SgStatement* parentPointer = isSgStatement(get_parent());
  // assert(parentPointer != NULL);
     bool isStaticDeclaration = (isSgClassDefinition(parentPointer) != NULL);
     
     if(isStaticDeclaration == true)
          setDeclarationOnly();
  // if(isSgClassDefinition(get_parent())) setDeclarationOnly();
   }

void
SgVariableDeclaration::setExtern() 
   {
     printf ("Error: SgVariableDeclaration::setExtern() is deprecated \n");

     SgDeclarationStatement::setExtern();
     setDeclarationOnly();
   }

int
SgVariableDeclaration::reset_initializer(SgInitializer *initializer)
   {
/*
     SgVariableDefinition *vdefn = get_definition();
     if ( vdefn != NULL )
        { 
          vdefn->set_initializer(initializer); // reset
          return true;
        }
     return false;
*/
    // QY 11/5/04
     if (get_variables().size()) {
        get_variables().front()->set_initializer(initializer);
        return true;
     } 
     return false;
   }

// setForward in class variable declaration
void
SgVariableDeclaration::setDeclarationOnly()
   {
     SgInitializedName *defn_item = NULL;

     SgInitializedNamePtrList::iterator p = get_variables().begin();
     while ( p != get_variables().end() )
        {
        // QY:11/3/04 removed get_named_item
       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
          ROSE_ASSERT ((*p) != NULL);
       //   defn_item = (*p)->get_named_item();
          defn_item = (*p);
          if (defn_item->get_definition())
             {
            // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
            // (*p).set_named_item(NULL);
            //   (*p)->set_named_item(NULL);
              (*p)->set_definition(NULL);
             }
          p++;
        }
     setForward();
   }

// DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
void
SgVariableDeclaration::append_variable( SgInitializedName* what, SgInitializer *initializer )
   {
     ROSE_ASSERT (what != NULL);

     get_variables().push_back(what);
     what->set_parent(this);

  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // SgInitializedName *decl_item = &(*new_item);
  // SgInitializedName *decl_item = *new_item;

  // printf ("Inside of SgVariableDeclaration::append_variable what = %p \n",what);
  // printf ("Inside of SgVariableDeclaration::append_variable decl_item = %p \n",decl_item);

  // DQ (6/1/2004): Can we assert this
  // ROSE_ASSERT (decl_item == what);

     assert(this != NULL);
     ROSE_ASSERT (what != NULL);

  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // if (!isSgFunctionType(what.get_type()))
     if (!isSgFunctionType(what->get_type()))
        {
#if 0
       // DQ (5/20/2006): Avoid sharing the Sg_File_Info object from the SgVariableDeclaration
          Sg_File_Info* copyOfFileInfo = new Sg_File_Info(*(this->get_file_info()));
          ROSE_ASSERT (copyOfFileInfo != NULL);
       // SgVariableDefinition *defn_stmt = new SgVariableDefinition(this->get_file_info(),decl_item,initializer);  
          SgVariableDefinition *defn_stmt = new SgVariableDefinition(copyOfFileInfo,decl_item,initializer);  
          assert (defn_stmt != NULL);
          copyOfFileInfo->set_parent(defn_stmt);
#endif
       // DQ (11/24/2006): This function is called from initializeData() which is required to work with or without a valid Sg_File_Info object.
          Sg_File_Info* copyOfFileInfo = NULL;
          SgVariableDefinition *defn_stmt = NULL;
          if (this->get_file_info() != NULL)
             {
               copyOfFileInfo = new Sg_File_Info(*(this->get_file_info()));
               ROSE_ASSERT (copyOfFileInfo != NULL);

               defn_stmt = new SgVariableDefinition(copyOfFileInfo,get_variables().back(),initializer);  
               assert (defn_stmt != NULL);
               copyOfFileInfo->set_parent(defn_stmt);

            // DQ (3/13/2007): We can't enforce that the endOfConstruct is set (if the interface using the startOfConstruct is used.
            // DQ (2/3/2007): Need to build the endOfConstruct position as well.
            // ROSE_ASSERT(this->get_endOfConstruct() != NULL);
               if (this->get_endOfConstruct() != NULL)
                  {
                    Sg_File_Info* copyOfEndOfConstruct = new Sg_File_Info(*(this->get_endOfConstruct()));
                    defn_stmt->set_endOfConstruct(copyOfEndOfConstruct);
                    copyOfEndOfConstruct->set_parent(defn_stmt);
                  }
             }
            else
             {
               defn_stmt = new SgVariableDefinition(get_variables().back(),initializer);
             }
        }
   }

// DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
void
SgVariableDeclaration::prepend_variable( SgInitializedName* what, SgInitializer *initializer )
   {
     ROSE_ASSERT (what != NULL);

     get_variables().insert(get_variables().begin(),what);
     what->set_parent(this);

  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // SgInitializedName *decl_item = &(*new_item);
  // SgInitializedName *decl_item = *new_item;

  // DQ (6/1/2004): Can we assert this
  // ROSE_ASSERT (decl_item == what);

  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // if (!isSgFunctionType(what.get_type()))
     if (!isSgFunctionType(what->get_type()))
        {
#if 0
       // DQ (5/20/2006): Avoid sharing the Sg_File_Info object from the SgVariableDeclaration
          Sg_File_Info* copyOfFileInfo = new Sg_File_Info(*(this->get_file_info()));
          ROSE_ASSERT (copyOfFileInfo != NULL);
       // SgVariableDefinition *defn_stmt = new SgVariableDefinition(this->get_file_info(),decl_item,initializer);
          SgVariableDefinition *defn_stmt = new SgVariableDefinition(copyOfFileInfo,decl_item,initializer);
          assert (defn_stmt != NULL);
          copyOfFileInfo->set_parent(defn_stmt);
#endif
       // DQ (11/24/2006): This function is called from initializeData() which is required to work with or without a valid Sg_File_Info object.
          Sg_File_Info* copyOfFileInfo = NULL;
          SgVariableDefinition *defn_stmt = NULL;
          if (this->get_file_info() != NULL)
             {
               copyOfFileInfo = new Sg_File_Info(*(this->get_file_info()));
               ROSE_ASSERT (copyOfFileInfo != NULL);

               defn_stmt = new SgVariableDefinition(copyOfFileInfo,get_variables().front(),initializer);  
               assert (defn_stmt != NULL);
               copyOfFileInfo->set_parent(defn_stmt);

            // DQ (2/3/2007): Need to build the endOfConstruct position as well.
               ROSE_ASSERT(this->get_endOfConstruct() != NULL);
               Sg_File_Info* copyOfEndOfConstruct = new Sg_File_Info(*(this->get_endOfConstruct()));
               copyOfEndOfConstruct->set_parent(defn_stmt);
               defn_stmt->set_endOfConstruct(copyOfEndOfConstruct);
             }
            else
             {
               defn_stmt = new SgVariableDefinition(get_variables().front(),initializer);
             }
        }
   }

#if 0
// DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
SgInitializedNamePtrList::iterator
SgVariableDeclaration::insert_variable( const SgInitializedNamePtrList::iterator& where, SgInitializedName* what)
   {
  // DQ (9/27/2004): This function contains a side-effect on its input. For now just output a warning message.

     ROSE_ASSERT (what != NULL);
  // if (what->get_declaration()) // set parent() of definition's declaration 
  //     what->get_declaration()->set_parent(this);
  // QY (11/3/04)
     what->set_parent(this);

     SgInitializedNamePtrList::iterator new_item = get_variables().insert(where,what);

  // DQ (6/1/2004): Can we assert this
     ROSE_ASSERT (*new_item == what);

  // this->setNameOnly();
     return new_item;
   }
#endif

//QY 11/5/04 not needed any more since removed named_item in SgInitializedName
#if 0
SgInitializedName*
SgVariableDeclaration::get_defn_item(const SgName& nm)
   {
     SgInitializedName *decl_item = NULL;

     SgInitializedNamePtrList::iterator p = get_variables().begin();
     while ( p != get_variables().end() )
        {
       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
       // if (nm.is_null() || (*p).get_name()==nm)
          if (nm.is_null() || (*p)->get_name() == nm)
             {
            // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
            // decl_item=&(*p);
               decl_item = (*p);
               break;
             }
          p++;
        }

    // QY : 11/2/04 removed p_named_item
     //if (decl_item && decl_item->get_named_item())
     //     return decl_item->get_named_item();
     if (decl_item && decl_item->get_definition())
          return decl_item;
       else
          return NULL;
   }
#endif
 
SgInitializedName*
SgVariableDeclaration::get_decl_item(const SgName& nm)
   {
     SgInitializedName *decl_item = NULL;

     SgInitializedNamePtrList::iterator p = get_variables().begin();
     while ( p != get_variables().end() )
        {
       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
       // if (nm.is_null() || (*p).get_name()==nm)
          if (nm.is_null() || (*p)->get_name() == nm)
             {
            // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
            // decl_item = &(*p);
               decl_item = *p;
               break;
             }
          p++;
        }
     return decl_item;
   }

SgStatement*
SgVariableDeclaration::get_next(int & n) const
   {
     if (isNameOnly()) return 0;
     if (n == 0)
        {
          n++;
       // special case if type of variable declaration pt to a tag Reference which
       // maybe a statement of some sort
       // only need to worry about first variable's decl
          SgInitializedNamePtrList::const_iterator p = get_variables().begin();

       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
       // SgType *tmp_type = (*p).get_type();
          ROSE_ASSERT ((*p) != NULL);
          SgType *tmp_type = (*p)->get_type();

          SgNamedType *ntype = isSgNamedType(tmp_type->findBaseType());
          SgDeclarationStatement* declStmt = 
               (ntype) ? ntype->get_declaration() : (SgDeclarationStatement*)0L;
          if ( declStmt && !declStmt->isForward() && 
               (isSgClassDeclaration(declStmt) || isSgEnumDeclaration(declStmt) ) )
             {
               return declStmt;
             } 
            else 
               return 0;
        }
       else
          return 0; 
   }

#if 0
// DQ (7/19/2005): SgVariableDeclaration should have a structural definition of its scope (based on position in 
// source code) while the variables declared should (and do) have a posible different scope (via name qualification).
// DQ (7/4/2005): implement get_scope to query the initialized names in the initialized name list (SgInitializedNamePtrList)
// without this function we evaluate the scope using a traversal of the parents!
SgScopeStatement*
SgVariableDeclaration::get_scope(void) const
   {
     ROSE_ASSERT(this != NULL);

  // This function looks at the first SgInitializedName for file the scope which is stored there explicitly
     const SgInitializedNamePtrList & variableList = get_variables();
     ROSE_ASSERT(variableList.size() > 0);
     const SgInitializedName* firstVariable = *(variableList.begin());
     ROSE_ASSERT(firstVariable != NULL);

  // Note that if this function is called before the SgInitializedName's explicitly stored scope is set the result may be NULL
     SgScopeStatement* scope = firstVariable->get_scope();
  // ROSE_ASSERT(scope != NULL);

     return scope;
   }
#endif

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgVariableDeclaration::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName variableNames;
     SgInitializedNamePtrList::const_iterator p = get_variables().begin();
     while ( p != get_variables().end() )
        {
       // DQ (2/22/2007): Added type to generated mangled name for each variable (supports AST merge generation of name for un-named classes)
       // variableNames += SgName("_variable_name_") + (*p)->get_mangled_name();
          variableNames += SgName("_variable_type_") + (*p)->get_type()->get_mangled() + SgName("_variable_name_") + (*p)->get_mangled_name();

          p++;
        }

#if 0
     printf ("In SgVariableDeclaration::get_mangled_name(void): scope = %p = %s scope->get_qualified_name() = %s \n",
          scope,scope->class_name().c_str(),scope->get_qualified_name().str());
#endif

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_variable_declaration_") + variableNames;
     returnName = scope->get_mangled_name() + SgName("_variable_declaration_") + variableNames;

     return returnName;
   }

// GB (09/25/2007): Added this function as part of the traversal island fix. If this variable declaration contains the
// definition of its base type, that defining declaration is returned (computed via the type of the first initialized
// name in the list).
SgDeclarationStatement *
SgVariableDeclaration::compute_baseTypeDefiningDeclaration() const
   {
  // DQ (10/17/2007): It is likely that this function could be replaced with just:
  // return p_baseTypeDefiningDeclaration;
  // in the future.

     if (p_variableDeclarationContainsBaseTypeDefiningDeclaration == true)
        {
#if 0
          ROSE_ASSERT(!p_variables.empty());
          SgInitializedName *var = p_variables.front();
          SgNamedType *baseType = isSgNamedType(var->get_type()->findBaseType());
       // GB (09/25/2007): Can we assert this? The flag above seems to tell us that we can.
          ROSE_ASSERT(baseType != NULL);
          return baseType->get_declaration()->get_definingDeclaration();
#else
       // DQ (10/17/2007): Modified to permit the declaration to be stored and accessed so that the AST COPY mechanism 
       // would not have to lookup the declaration through the type (which is a problem because types are shared and 
       // so the declaration in the original AST is returned instead of the declaration form the copy of the AST).
          ROSE_ASSERT(p_baseTypeDefiningDeclaration != NULL);
          return p_baseTypeDefiningDeclaration;
#endif
        }
       else
        {
          ROSE_ASSERT(p_baseTypeDefiningDeclaration == NULL);
          return NULL;
        }
   }

SgDeclarationStatement *
SgVariableDeclaration::get_baseTypeDefiningDeclaration() const
   {
  // DQ (10/14/2007): This provides an public (compute_baseTypeDefiningDeclaration() is private)
  // interface similar to that for SgVariableDeclaration and for the same purpose (types defined 
  // in the typedef or variable declaration).

     return compute_baseTypeDefiningDeclaration();
   }

void
SgVariableDeclaration::set_baseTypeDefiningDeclaration(SgDeclarationStatement* d)
   {
  // DQ (10/17/2007): This is a non ROSETTA generated function so that the get_baseTypeDefiningDeclaration()
  // version can be written to use the compute_baseTypeDefiningDeclaration() member function.  However, we
  // are changing the compute_baseTypeDefiningDeclaration() member function to return the explicitly stored
  // defining declaration in a SgVariableDeclaration (if such a thing is defined).  An example of where this
  // happens is in: "struct { int x; } y;", here the structure declaration is in the variable declaration for "y".

     ROSE_ASSERT(d != NULL);

     p_baseTypeDefiningDeclaration = d;
     ROSE_ASSERT(p_baseTypeDefiningDeclaration != NULL);

  // Mark the p_variableDeclarationContainsBaseTypeDefiningDeclaration as true so that the p_baseTypeDefiningDeclaration
  // declaration will be used (by compute_baseTypeDefiningDeclaration()).
     set_variableDeclarationContainsBaseTypeDefiningDeclaration(true);
   }


SOURCE_VARIABLE_DECLARATION_STATEMENT_END


SOURCE_VARIABLE_DEFINITION_STATEMENT_START
void
SgVariableDefinition::post_construction_initialization()
   {
   }

SgVariableDeclaration*
SgVariableDefinition::get_declaration()
   {
     assert(get_vardefn() != NULL);

     SgVariableDeclaration *rdecl = isSgVariableDeclaration(get_vardefn()->get_declaration());
     return rdecl;
   }

SgVariableDefinition::
SgVariableDefinition(Sg_File_Info *info, SgInitializedName *decl_item, SgInitializer *initializer)
   : $BASECLASS(info),
  // DQ (11/20/2004): Reordered pre-initialization list to avoid compiler warnings.
  // p_initializer_expr_root(new SgExpressionRoot(initializer == 0?New_File_Info(this) : new Sg_File_Info(*initializer->get_file_info()), initializer)),
  // QY:11/2/04 remove redundant coupled SgInitializedName nodes. 
  // p_vardefn ( new SgInitializedName(decl_item->get_name(),NULL,initializer,this,NULL,NULL))
     p_vardefn(decl_item),
     p_bitfield(0)

   {
  // In many places this constructor is called (via the new operator) with the resulting
  // pointer returned by operator::new UNUSED.  The reason why this works is because the
  // call to "set_parent()" at the base of the constructor attaches this object to the
  // program tree (I think this is inelegant (since it is the only class that works this
  // way in SAGE), but I will leave it as is for now).

     ROSE_ASSERT(decl_item != NULL);

#if 0
  // DQ (10/29/2006): This only resets the file info in the SgInitilaizedName object (a memory 
  // leak at least if it were not also an error, since now we set the source position more 
  // precisely and this overwrites the correct value!)

  // DQ (8/3/2004): Need to set the file info on this SgInitializedName object (use a copy)
     Sg_File_Info* copyOfFileInfo = new Sg_File_Info(*info);
     ROSE_ASSERT (copyOfFileInfo != NULL);

  // DQ (1/18/2006): Changed name to be consistent with SgNode::get_file_info()
  // get_vardefn()->set_fileInfo(copyOfFileInfo);
     get_vardefn()->set_file_info(copyOfFileInfo);

  // This should be NULL to to avoid a cycle (set to NULL in call to constructor, above)
  //   ROSE_ASSERT (get_vardefn()->get_itemptr() == NULL);

  // printf ("In SgVariableDefinition constructor: defn_item = %p \n",defn_item);
#endif

  // QY:11/2/04    do not create a new  SgInitializedName. set p_vardefn = decl_item, then set the initializer in decl_item instead
  // This resets the itemptr pointer in the declaration to the SgInitializedName object
  //   decl_item->set_named_item(get_vardefn());
      set_parent(decl_item);
      get_vardefn()->set_initializer(initializer);
      get_vardefn()->set_definition(this);

  // Sage 2 includes this code (the body of post_construction_initialization()
  // instead of calling post_construction_initialization() directly) (?)
     ROSE_ASSERT(decl_item != NULL);
     //ROSE_ASSERT(decl_item->get_declaration() != NULL);
     //ROSE_ASSERT(isSgVariableDeclaration(decl_item->get_declaration()) != NULL);
   }

SgVariableDefinition::
SgVariableDefinition( SgInitializedName *decl_item, SgInitializer *initializer)
   : p_vardefn(decl_item),
     p_bitfield(0)
   {
  // DQ (11/10/2006): This is a version of the constructor that is separated from the source position initialization.
     ROSE_ASSERT(decl_item != NULL);

     set_parent(decl_item);
     get_vardefn()->set_initializer(initializer);
     get_vardefn()->set_definition(this);

     ROSE_ASSERT(decl_item != NULL);
   }

SgType*
SgVariableDefinition::get_type()
   {
     return get_vardefn()->get_type();
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgVariableDefinition::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_variable_definition_") + get_vardefn()->get_mangled_name();
     returnName = scope->get_mangled_name() + SgName("_variable_definition_") + get_vardefn()->get_mangled_name();

     return returnName;
   }

SOURCE_VARIABLE_DEFINITION_STATEMENT_END


SOURCE_CLASS_DECLARATION_STATEMENT_START

void
SgClassDeclaration::post_construction_initialization()
   {
  // DQ (9/27/2004): This function should not modify the existing SgType which 
  // in some cases is shared with other IR nodes within Sage III.  This is a bug
  // which effects the handling of defining vs. non-defining declarations.
#if 0
     if (get_type())
          get_type()->set_declaration(this);
       else	
          set_type(SgClassType::createType(this)); 
#else
  // Only build a type if one does not exist
  // Liao, 10/30/2009. We should not create SgClassType during constructing
  // Since only the first nondefining class declaration should have a dedicated SgClassType node
  // the defining class declaration (and other nondefining declaration) just shared that SgClassType.
  // The constructor does not know if a defining or nondefining declaration is being built
  // so we have to let users to create SgClassType by themselves after calling the constructor
  // This will ultimately avoid duplicated SgClassType nodes in the AST
#if 0 
     if (get_type() == NULL)
        {
#if 0
#if PRINT_DEVELOPER_WARNINGS
          printf ("In $CLASSNAME::post_construction_initialization(): generating the SgClassType internally (from the declaration) \n");
#endif
#endif
          set_type(SgClassType::createType(this));
        }
#endif        
     
#endif
   }

// SgStatement *get_first() const;

bool
SgClassDeclaration::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
{
  return false;
}

SgName
SgClassDeclaration::get_qualified_name() const
   {
  //! \todo Find out why qualified name generation requires a special case for unions.

  // DQ (9/27/2004): This function calls get_scope() which uses the parent pointers, thus 
  // it should not be called before the parent pointers are set (within the AST fixup after 
  // the Sage III AST is fully constructed).

  // printf ("In SgClassDeclaration::get_qualified_name() name = %s isUnion = %s \n",get_name().str(),(isUnion == true) ? "true" : "false") ;

     SgName returnName;

#if 1
  // DQ (6/3/2006): I think we should handle unions uniformly with structs and classes.
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);
     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());
#else
  // Ignore case of a union (why?)
     bool isUnion = (get_class_type() == SgClassDeclaration::e_union);

     if (isUnion == true)
        {
       // DQ (8/28/2005): I'm not clear on why this is handles as a special case!
          printf ("In SgClassDeclaration::get_qualified_name(): Special case of union, does not include scope information! \n");
          returnName = get_name();
        }
       else
        {
       // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
          SgScopeStatement* scope = get_scope();
          ROSE_ASSERT(scope != NULL);

       // ROSE_ASSERT(get_name().is_null() == false);

       // returnName = scope->get_qualified_name() << "::" << get_name().str();
          returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());
        }
#endif

  // printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

  // ROSE_ASSERT(returnName.is_null() == false);

     return returnName;
   }

// RV (1/31/2006): Added mangler for class declarations.
SgName
SgClassDeclaration::get_mangled_name(void) const
   {
#if 0
  // return joinMangledQualifiers (mangleQualifiers(get_scope()),get_name());

     SgName name = get_name();

  // DQ (2/8/2007): See the note in the SgEnumDeclaration::get_mangled_name() function.
     bool specialCaseNameHandling = (name.getString().find("__rose_generated_structure_tag_name_") != std::string::npos);

  // Now that we reset empty name this should be true (unless fixup had not been called)
  // ROSE_ASSERT (name.is_null() == false);

  // DQ (6/1/2006): Added special handling for case where the class name is empty as in an 
  // printf ("In SgClassDeclaration::get_mangled_name(void): get_scope() = %p = %s \n",get_scope(),get_scope()->class_name().c_str());
  // if (name.is_null() == true)

  // DQ (2/22/2007): I think that we don't use this sort of name internally any more!
  // We generate more comlex names approporate to support the AST merge mechanism.
     ROSE_ASSERT(specialCaseNameHandling == false);

     return joinMangledQualifiers (mangleQualifiers(get_scope()),name);
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgClassDeclaration* classDeclaration = const_cast<SgClassDeclaration*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(classDeclaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgClassDeclaration*>(this));
     if (mangledNameString.empty() == false)
        {
       // printf ("In SgClassDeclaration::get_mangled_name(): (FOUND in cache) mangledNameString = %s \n",mangledNameString.c_str());
          return mangledNameString;
        }
       else
        {
          SgName mangledName = joinMangledQualifiers (mangleQualifiers(get_scope()),get_name());
       // printf ("In SgClassDeclaration::get_mangled_name(): (NOT found in cache) mangledName = %s \n",mangledName.str());

          if (mangledName.is_null() == true)
             {
            // printf ("In SgClassDeclaration::get_mangled_name(): (NOT found in cache) mangledName = %s get_name() = %s \n",mangledName.str(),get_name().str());
               mangledName = "unknown_scope_and_name";
             }
          ROSE_ASSERT(mangledName.is_null() == false);

#if 0
       // DQ (6/23/2010): Added support to make classes with the same name different when they are
       // different classes containing different members.
          SgName memberNames = "_class_members_";
          if (get_definition() != NULL)
             {
               SgDeclarationStatementPtrList::const_iterator p = get_definition()->get_members().begin();
               while ( p != get_definition()->get_members().end() )
                  {
                 // DQ (2/22/2007): Added type to generated mangled name for each variable (supports AST merge generation of name for un-named classes)
                 // memberNames += SgName("_member_type_") + (*p)->get_type()->get_mangled() + SgName("_member_name_") + (*p)->get_mangled_name();
                    memberNames += SgName("_member_name_") + SageInterface::get_name(*p);

                    p++;
                  }
             }

          mangledName += memberNames;
#endif
       // p_globalMangledNameMap[classDeclaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgClassDeclaration*>(this),mangledName);
          return mangledName;
        }
#endif
   }

SgName
SgClassDeclaration::get_mangled_qualified_name ( int & cnt )
   {
  // This function is called during the construction of the SAGE AST.  As a result 
  // it currently represents a dependence of the parent pointer.

  // Make sure that parents have been set already
  // (assume this means that all parents have been set)
  // ROSE_ASSERT (get_parent() != NULL);
  // ROSE_ASSERT (get_parent() == NULL);

     SgName nm;

  // if(isSgClassDefinition(get_parent()))
     SgNode* parentNode = get_parent();
     SgClassDefinition* parentDefinition = isSgClassDefinition(parentNode);
     if (parentDefinition != NULL)
        {
       // nm = (isSgClassDefinition(get_parent())->get_mangled_qualified_name(cnt));
          nm = (parentDefinition->get_mangled_qualified_name(cnt));
       // printf ("In $CLASSNAME::get_mangled_qualified_name(): nm = %s \n",nm.str());
        }
     cnt++;

  // DQ (4/28/2005): 
  // nm << strlen(get_name().str());
  // nm << get_name().str();

     const SgTemplateInstantiationDecl* templateClassDeclaration = isSgTemplateInstantiationDecl(this);
     if (templateClassDeclaration != NULL)
        {
       // Need to remove " < " and " > " from template name so that can support name mangling
       // SgName className = "_"; // Avoid leading character being a number
          SgName className;
          className << get_name().getString().size();
          className += get_name();
          nm << fixupTemplateNameForMangledNameSupport(className).str();
        }
       else
        {
          nm << get_name().getString().size();
          nm << get_name().str();
        }

#if 0
     if (parentDefinition != NULL)
        {
//        printf ("In $CLASSNAME::get_mangled_qualified_name(cnt = %d) nm = %s \n",cnt-1,nm.str());
//        get_file_info()->display("Called from $CLASSNAME::get_mangled_qualified_name()");
        }
#endif

     return nm;
   }

bool
SgClassDeclaration::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgClassDeclaration::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
   }

// GB (09/26/2007): Added this function as part of the move to index-based traversals: We only want the definition to be
// a traversal successor if isForward is false. This used to be handled in the AstSuccessorsSelectors code, but now it
// is isolated in this function (which is used by the traversal code generated by ROSETTA).
SgClassDefinition *
SgClassDeclaration::compute_classDefinition() const
   {
     if (isForward())
        {
          return NULL;
        }
     else
        {
          return p_definition;
        }
   }

SOURCE_CLASS_DECLARATION_STATEMENT_END

SOURCE_TEMPLATE_INSTANTIATION_DECLARATION_STATEMENT_START
void
SgTemplateInstantiationDecl::post_construction_initialization()
   {
  // DQ (9/27/2004): This function should not modify the existing SgType which 
  // in some cases is shared with other IR nodes within Sage III.  This is a bug
  // which effects the handling of defining vs. non-defining declarations.

  // printf ("p_templateArguments.size() = %zu \n",p_templateArguments.size());

  // DQ (2/17/2007): Set the parents of all template arguments to the template instantiation
  // JJW (8/6/2008): p_templateArguments is not a pointer anymore
     SgTemplateArgumentPtrList::iterator i = p_templateArguments.begin();
     while (i != p_templateArguments.end())
        {
          (*i)->set_parent(this);
          i++;
        }

  // DQ (7/29/2010): Build the type after setting the template aruments.
     if (get_type() == NULL)
        {
          set_type(SgClassType::createType(this));
        }
   }

SgName
SgTemplateInstantiationDecl::get_qualified_name() const
   {
  // This is a function called after the parents have been set.  It is not called by the
  // EDG/SAGE interface and is only called after the SAGE AST has been built and the parent
  // pointers set within a separate phase.

  // Some error checking!
     ROSE_ASSERT (get_parent() != NULL);

  // DQ (11/23/2004): This name should have been reset already (before it is used here)
     if (get_nameResetFromMangledForm() == false)
        {
       // DQ (6/26/2005): It is OK for the EDG/Sage III translation to reference the qualified names 
       // even before the names are properly set! As long as we consistently return EDG uniquely generated 
       // names.  This will allow the symbols to be built and shared, but afterward the symbols will have 
       // be in the wrong position in the hash table since the names used to place them will have changed.

       // printf ("Warning: In SgTemplateInstantiationDecl::get_qualified_name() (at %p) get_qualified_name() (get_nameResetFromMangledForm() == false) name = %s (skipping call to reset) \n",this,get_name().str());
        }
  // ROSE_ASSERT(get_nameResetFromMangledForm() == true);

  // DQ (8/28/2005): This function previously used the template declaration as a basis for 
  // its qualified name generation.  I think this is a mistake and that the templates scope 
  // should be used instead (same as for where qualified names are generated elsewhere).

#if 0
  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

  // Make sure that parents have been set already
  // (assume this means that all parents have been set)
     if (get_parent() == NULL)
        {
          printf ("In $CLASSNAME::get_qualified_name() this = %p at: \n",this);
          get_file_info()->display("Error at this location in source code!");
        }
     ROSE_ASSERT (get_parent() != NULL);

     SgName returnName;

     SgTemplateDeclaration* templateDeclaration = get_templateDeclaration();
     ROSE_ASSERT(templateDeclaration != NULL);

     returnName = SgName::assembleQualifiedName(templateDeclaration->get_qualified_name(),get_name());

     return returnName;
#else
  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

  // printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
#endif
   }

// RV (2/1/2006): Added mangler for template instantiations.
SgName
SgTemplateInstantiationDecl::get_mangled_name (void) const
   {
#if 0
     return mangleTemplate (get_templateName (),
                            get_templateArguments (),
                            get_scope ());
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgTemplateInstantiationDecl* declaration = const_cast<SgTemplateInstantiationDecl*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgTemplateInstantiationDecl*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
#if 0
          printf ("In SgTemplateInstantiationDecl::get_mangled_name(): (FOUND in cache) mangledNameString = %s get_name() = %s \n",mangledNameString.c_str(),get_name().str());
#endif
          return mangledNameString;
        }
       else
        {
       // DQ (7/24/2010): Added to support type tables (at an early stage in AST construction, the get_templateName() might not be known yet.
       // ROSE_ASSERT(get_templateName().is_null() == false);
          SgName template_name = get_templateName();
          if (template_name.is_null() == true)
             {
            // Use the name of the template (as defined by EDG) so that we can generate a unique string (later this is reset).
               template_name = get_name();
             }
          ROSE_ASSERT(template_name.is_null() == false);
#if 0
          printf ("template_name = %s \n",template_name.str());
#endif
       // SgName mangledName = mangleTemplate (get_templateName(),get_templateArguments(),get_scope());
          SgName mangledName = mangleTemplate(template_name,get_templateArguments(),get_scope());
#if 0
          printf ("After mangleTemplate(): get_templateArguments().size() = %zu mangledName = %s \n",get_templateArguments().size(),mangledName.str());
          ROSE_ASSERT(get_templateArguments().size() > 0);
#endif
#if 0
          printf ("In SgTemplateInstantiationDecl::get_mangled_name(): (NOT found in cache) mangledNameString = %s get_name() = %s get_templateName() = %s \n",mangledNameString.c_str(),get_name().str(),get_templateName().str());
#endif
       // DQ (7/24/2010): Added to support type tables.
          ROSE_ASSERT(mangledName.is_null() == false);

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgTemplateInstantiationDecl*>(this),mangledName);
#if 0
          printf ("After SageInterface::addMangledNameToCache(): mangledName = %s \n",mangledName.str());
#endif
          return mangledName;
        }
#endif
   }

void
SgTemplateInstantiationDecl::set_definition( SgTemplateInstantiationDefn* definition )
   {
  // DQ (9/23/2004): Implement this function to hide the base class one so that the interface
  // to set_definition takes a SgTemplateInstantiationDefn instead of a SgClassDefinition.
  // Implement using explicit call to the base class set_definition function.
     SgClassDeclaration::set_definition(definition);
   }

void
SgTemplateInstantiationDecl::resetTemplateName ()
   {
  // local version of function to support generation of template names
     resetTemplateNameSupport (p_nameResetFromMangledForm,p_name);
   }

// DQ (2/11/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgTemplateInstantiationDecl::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
   }

SOURCE_TEMPLATE_INSTANTIATION_DECLARATION_STATEMENT_END

SOURCE_TEMPLATE_INSTANTIATION_FUNCTION_DECLARATION_STATEMENT_START
void
SgTemplateInstantiationFunctionDecl::post_construction_initialization()
   {
  // DQ (4/19/2005): Removed since it is redundant with the define of the template support in ROSE
  // set_from_template(true);

  // DQ (2/17/2007): Set the parents of all template arguments to the template instantiation
  // JJW (8/6/2008): This is not a pointer anymore
#if 0
     if (p_templateArguments != NULL)
        {
#endif
          SgTemplateArgumentPtrList::iterator i = p_templateArguments.begin();
          while (i != p_templateArguments.end())
             {
               (*i)->set_parent(this);
               i++;
             }
#if 0
        }
       else
        {
          printf ("Warning (post_construction_initialization): p_templateArguments == NULL in SgTemplateInstantiationFunctionDecl = %p \n",this);
        }
#endif
   }

void
SgTemplateInstantiationFunctionDecl::resetTemplateName ()
   {
  // local version of function to support generation of template names
     resetTemplateNameSupport (p_nameResetFromMangledForm,p_name);
   }

// RV (2/1/2006): Added mangler for template function instantiations.
SgName
SgTemplateInstantiationFunctionDecl::get_mangled_name (void) const
  {
#if 0
    return mangleTemplateFunction (get_templateName().getString(),get_templateArguments(),get_type(),get_scope());
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgTemplateInstantiationFunctionDecl* declaration = const_cast<SgTemplateInstantiationFunctionDecl*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgTemplateInstantiationFunctionDecl*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName mangledName = mangleTemplateFunction (get_templateName().getString(),get_templateArguments(),get_type(),get_scope());

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgTemplateInstantiationFunctionDecl*>(this),mangledName);
          return mangledName;
        }
#endif
  }

// DQ (2/11/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgTemplateInstantiationFunctionDecl::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
   }

SOURCE_TEMPLATE_INSTANTIATION_FUNCTION_DECLARATION_STATEMENT_END

SOURCE_TEMPLATE_INSTANTIATION_MEMBER_FUNCTION_DECLARATION_STATEMENT_START
void
SgTemplateInstantiationMemberFunctionDecl::post_construction_initialization()
   {
  // DQ (4/19/2005): Removed since it is redundant with the define of the template support in ROSE
  // set_from_template(true);

  // DQ (2/17/2007): Set the parents of all template arguments to the template instantiation
  // JJW (8/6/2008): This is not a pointer anymore
#if 0
     if (p_templateArguments != NULL)
        {
#endif
          SgTemplateArgumentPtrList::iterator i = p_templateArguments.begin();
          while (i != p_templateArguments.end())
             {
               (*i)->set_parent(this);
               i++;
             }
#if 0
        }
       else
        {
          printf ("Warning (post_construction_initialization): p_templateArguments == NULL in SgTemplateInstantiationMemberFunctionDecl = %p \n",this);
        }
#endif
   }

void
SgTemplateInstantiationMemberFunctionDecl::resetTemplateName ()
   {
  // local version of function to support generation of template names
     resetTemplateNameSupport (p_nameResetFromMangledForm,p_name);
   }

// RV (2/1/2006): Added mangler for template member function instantiations.
SgName
SgTemplateInstantiationMemberFunctionDecl::get_mangled_name (void) const
  {
#if 0
    return mangleTemplateFunction (get_templateName().getString(),get_templateArguments(),get_type(),get_scope());
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgTemplateInstantiationMemberFunctionDecl* declaration = const_cast<SgTemplateInstantiationMemberFunctionDecl*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgTemplateInstantiationMemberFunctionDecl*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName mangledName = mangleTemplateFunction (get_templateName().getString(),get_templateArguments(),get_type(),get_scope());

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgTemplateInstantiationMemberFunctionDecl*>(this),mangledName);
          return mangledName;
        }
#endif
  }

// DQ (2/11/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgTemplateInstantiationMemberFunctionDecl::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
   }

SOURCE_TEMPLATE_INSTANTIATION_MEMBER_FUNCTION_DECLARATION_STATEMENT_END

SOURCE_TEMPLATE_INSTANTIATION_DEFINITION_STATEMENT_START

void
SgTemplateInstantiationDefn::post_construction_initialization()
   {
   }


// DQ (9/8/2004): overrides base class implementation
SgName
SgTemplateInstantiationDefn::get_qualified_name() const
   {
  // printf ("In $CLASSNAME::get_qualified_name() \n");

  // It is a little less trivial to obtain the SgTemplateInstatiationDecl from the SgTemplateInstatiationDefn
  // since get_declaration() returns a SgClassDeclaration pointer and not a SgTemplateInstantiationDecl pointer.
     SgClassDeclaration* classDeclaration = get_declaration();
     ROSE_ASSERT(classDeclaration != NULL);
     SgTemplateInstantiationDecl* templateInstantiationDeclaration = isSgTemplateInstantiationDecl(classDeclaration);
     ROSE_ASSERT(templateInstantiationDeclaration != NULL);

  // DQ (10/16/2004): Not sure why this is not set!
  // ROSE_ASSERT (get_parent() != NULL);
     if (templateInstantiationDeclaration->get_parent() == NULL)
        {
          printf ("templateInstantiationDeclaration->get_parent() == NULL SgTemplateInstantiationDecl = %p SgClassDefinition = %p \n",
               templateInstantiationDeclaration,this);
          get_file_info()->display("$CLASSNAME");
          templateInstantiationDeclaration->get_file_info()->display("templateInstantiationDeclaration");
        }
     ROSE_ASSERT (templateInstantiationDeclaration->get_parent() != NULL);

     return templateInstantiationDeclaration->get_qualified_name();
   }

SgTemplateInstantiationDefn::SgTemplateInstantiationDefn( Sg_File_Info *f, SgTemplateInstantiationDecl *decl)
   : SgClassDefinition(f,decl)
   {
   }

SgTemplateInstantiationDefn::SgTemplateInstantiationDefn( SgTemplateInstantiationDecl *decl)
   : SgClassDefinition(decl)
   {
   }

SOURCE_TEMPLATE_INSTANTIATION_DEFINITION_STATEMENT_END

SOURCE_CLASS_DEFINITION_STATEMENT_START

void
SgClassDefinition::post_construction_initialization()
   {
  // DQ (9/5/2006): I don't think that this is called, but if it is then packingAlignment initialization is required.
     p_packingAlignment = 0;
   }

void
SgClassDefinition::set_declaration(SgClassDeclaration* new_val)
   {
  // QY: 10-4-04 removed declaration pointer. use parent pointer instead
     ROSE_ASSERT(this != NULL);
     set_parent(new_val);
   }

SgClassDeclaration*
SgClassDefinition::get_declaration() const
   {
  // QY: 10-4-04 removed declaration pointer. use parent pointer instead
     ROSE_ASSERT(this != NULL);
     SgClassDeclaration *decl= isSgClassDeclaration(get_parent());
     assert( get_parent() == NULL || decl != NULL ); 
     return decl;
   }

SgClassDefinition::SgClassDefinition( Sg_File_Info *f, SgClassDeclaration *decl)
   : SgScopeStatement(f)
   {
     set_declaration(decl);
     decl->set_definition(this);

  // DQ (9/5/2006): Added initialization of packingAlignment (required to be explicit in this constructor)
     p_packingAlignment = 0;
   }

SgClassDefinition::SgClassDefinition( SgClassDeclaration *decl)
   : SgScopeStatement()
   {
     set_declaration(decl);
     decl->set_definition(this);

  // DQ (9/5/2006): Added initialization of packingAlignment (required to be explicit in this constructor)
     p_packingAlignment = 0;
   }

#if 0
void
SgClassDefinition::insert_member(const SgDeclarationStatementPtrList::iterator& where, SgDeclarationStatement * what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif
     get_members().insert(where,what);
   }
#endif

void
SgClassDefinition::append_member(SgDeclarationStatement * what) 
   {
     get_members().push_back(what);
     what->set_parent(this);
   }

void
SgClassDefinition::prepend_member(SgDeclarationStatement * what) 
   {
     get_members().insert(get_members().begin(), what);
     what->set_parent(this);
   }

void
// $CLASSNAME::append_inheritance(const SgBaseClass & what)
SgClassDefinition::append_inheritance(SgBaseClass* what)
   {
     get_inheritances().push_back(what);
     what->set_parent(this);
   }

void
// $CLASSNAME::prepend_inheritance(const SgBaseClass & what)
SgClassDefinition::prepend_inheritance(SgBaseClass* what)
   {
     get_inheritances().insert(get_inheritances().begin(), what);
   }

#if 0
void
// $CLASSNAME::insert_inheritance(const SgBaseClassList::iterator & where, const SgBaseClass & what)
SgClassDefinition::insert_inheritance(const SgBaseClassPtrList::iterator & where, SgBaseClass* what)
   { 
     get_inheritances().insert(where,what);
   }
#endif

SgName
SgClassDefinition::get_qualified_name() const
   {
  // printf ("In $CLASSNAME::get_qualified_name() \n");
     return get_declaration()->get_qualified_name();
   }

// DQ (2/7/2006): code added by Rich Vuduc
SgName
SgClassDefinition::get_mangled_name (void) const
   {
     return get_declaration()->get_mangled_name ();
   }

SgName
SgClassDefinition::get_mangled_qualified_name (int& i) 
   {
  // printf ("In $CLASSNAME::get_mangled_qualified_name(%d): Calling get_declaration()->get_mangled_qualified_name(%d) \n",i,i);
     return get_declaration()->get_mangled_qualified_name(i);
   }

bool
SgClassDefinition::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     return StatementListInsertChild(this, get_members(), target, newstmt, true, extractBasicBlock, true);
   }

bool
SgClassDefinition::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront,
                                 bool extractBasicBlock)
   {
     return StatementListInsertChild( this, get_members(), target, newstmt, inFront, extractBasicBlock, false);
   }

#if 0
// DQ (8/18/2004): removing this older pragma mechanism
/******  SgClassDeclaration ******/
int
get_suppress_global(SgClassDeclaration *node)
   {
     SgClassDecl_attr *attr= (SgClassDecl_attr *) Sgget_user_attribute(node->get_uattributes(),"SgClassDecl_attr");
     if(attr)
          return attr->get_suppress_global();

     return 0;
   }
#endif

SOURCE_CLASS_DEFINITION_STATEMENT_END




SOURCE_ENUM_DECLARATION_STATEMENT_START

void
SgEnumDeclaration::post_construction_initialization()
   {
  // DQ (9/27/2004): This should be conditional upon if the SgType was provided 
  // in the constructor argument list (as in SgClassDeclaration).
  // set_type(SgEnumType::createType(this));
     if (get_type() == NULL)
        {
#if 0
#if PRINT_DEVELOPER_WARNINGS
          printf ("In $CLASSNAME::post_construction_initialization(): setting the SgEnumType type internally (using the declaration) \n");
#endif
#endif
          set_type(SgEnumType::createType(this));
        }
   }

void
// $CLASSNAME::append_enumerator(const SgInitializedName & what)
SgEnumDeclaration::append_enumerator( SgInitializedName* what)
   {
     get_enumerators().push_back(what);
     what->set_parent(this);
   }

void
// $CLASSNAME::prepend_enumerator(const SgInitializedName & what)
SgEnumDeclaration::prepend_enumerator( SgInitializedName* what)
   {
     get_enumerators().insert(get_enumerators().begin(), what);
     what->set_parent(this);
   }

#if 0
SgInitializedNamePtrList::iterator
// $CLASSNAME::insert_enumerator(const SgInitializedNamePtrList::iterator& where, const SgInitializedName & what) 
SgEnumDeclaration::insert_enumerator(const SgInitializedNamePtrList::iterator& where, SgInitializedName* what) 
   {
  // DQ (9/27/2004): This function appears to have a side-effect on its input, not clear if this is appropriate.
     SgInitializedNamePtrList::iterator new_item = get_enumerators().insert(where,what);
     (*new_item)->set_parent(this);
     return new_item;
   }
#endif

SgName
SgEnumDeclaration::get_qualified_name() const
   {
  // DQ (10/15/2004): This function is similar to the one for SgClassDeclaration.
  // This function calls get_scope() which uses the parent pointers, thus 
  // it should not be called before the parent pointers are set (within the AST fixup after 
  // the Sage III AST is fully constructed).

  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

  // printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
   }

// RV (2/1/2006): Added mangler for enum declarations.
SgName
SgEnumDeclaration::get_mangled_name (void) const
   {
#if 0
     SgName mangled_name;
     SgName name = get_name();

#if 1
  // DQ (6/1/2006): Added special handling for case where the class name is empty as in an 
  // printf ("In SgEnumDeclaration::get_mangled_name(void): get_scope() = %p = %s \n",get_scope(),get_scope()->class_name().c_str());

  // If this was originally a un-named enum then the astPostProcessing/fixupNames.C updated the name to reflect
  // a compiler generated tag name that could be references (and would be required) when multiple variables
  // might be used and the normalization of the AST (EDG) is done to reflect the separation into indivual 
  // variable declarations.  This was a bug fix in response to a bug report from IBM (Fall 2006).
  // However the compiler generated names are inappropriate for the AST merge since they are not unique 
  // (by design) and so they don't share properly.  So we now detect the ROSE compiler generated name
  // and proceed as though the enum had never need assigneda tag and generate a unique name that will
  // match appropriately to allow sharing (when ODR is not violated).  Basicaly we use the compiler generated
  // name to trigger this mechanism which used to be triggered when no name was available (specifically when
  // case: name.is_null() == true).
     bool specialCaseNameHandling = (name.getString().find("__rose_generated_enum_tag_name_") != std::string::npos);

  // DQ (3/10/2007): If the enum is un-named in a typedef (as the base type) then it should not be given another name by ROSE.
  // This is because the declaration can only be referred to once (handling multiple references is why we sometimes have to
  // provide a generated name (e.g. a variable declaration which has multiple variables).
  // Now that we reset empty name this should be true (unless fixup had not been called)
  // ROSE_ASSERT (name.is_null() == false);

  // DQ (8/20/2006): This will be a valid name for all C++ programs, but not for C programs (see Cxx_tests/math.C).
  // if (name.is_null() == true)

  // DQ (2/22/2007): I think that we don't use this sort of name internally any more!
  // We generate more comlex names approporate to support the AST merge mechanism.
     ROSE_ASSERT(specialCaseNameHandling == false);

     if (specialCaseNameHandling == true)
        {
       // DQ (8/20/2006): Using the parent can cause endless recursion for the code "typedef enum { enum_field } enum_typedef_type;"
       // so we have to assemble a unique name without resorting to the parent.
       // name = SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration(parent);
       // It the enum is unnamed then use the name of the first enum field (since it can't be redefied in the same scope, it is unique)
       // printf ("Using the parent of the enum to generate a name: parent = %p = %s \n",parent,parent->class_name().c_str());
       // This should be true for C but maybe not for C++!
       // name = SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration(parent);
          const SgInitializedNamePtrList & fieldList = p_enumerators;
       // printf ("In SgEnumDeclaration::get_mangled_name(): fieldList.size() = %ld \n",fieldList.size());
       // ROSE_ASSERT(fieldList.empty() == false);
          if (fieldList.empty() == true)
             {
               printf ("WARNING in SgEnumDeclaration::get_mangled_name(): fieldList.empty() == true \n");
             }
          SgInitializedNamePtrList::const_iterator i = fieldList.begin();
          name = "__unnamed_enum__";
          while(i != fieldList.end())
             {
               name += (*i)->get_name();
               i++;
               if (i != fieldList.end())
                  {
                    name += "__COMMA__";
                  }
             }
        }

  // DQ (3/10/2007): Modified to let this pass. mangled names for enums would not be
  // used in so critial a situation as class declarations which are more complex.
  // ROSE_ASSERT(name.is_null() == false);
     mangled_name = joinMangledQualifiers (mangleQualifiers(get_scope()),name);
#else
     if (name.get_length () == 0) // Is an anonymous enum in C
          mangled_name = SgName ("i"); // Treat like an integer
       else // Return a fully qualified mangled type name
          mangled_name = joinMangledQualifiers (mangleQualifiers(get_scope()),name);
#endif

     return mangled_name;
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgEnumDeclaration* declaration = const_cast<SgEnumDeclaration*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgEnumDeclaration*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
       // DQ (5/11/2007): If this is an enum type in a function definition then the mangled name for the type will
       // atempt to include the mangled name of the function definition (the scope of the function parameter) which
       // will cause infinit recursion in the evaluation of the mangled name of the function declaration which must 
       // include the function parameter, and so on.  However, this only appears to be a problem for C and not C++.
#if 0
          printf ("In SgEnumDeclaration::get_mangled_name(void): get_scope() = %p = %s \n",get_scope(),get_scope()->class_name().c_str());

          static int counter = 0;
          counter++;
          ROSE_ASSERT(counter < 10);
#endif

          string mangleQualifiersString;
          if (isSgFunctionDefinition(get_scope()) != NULL)
             {
            // printf ("This is a parameter to a function and will cause infinite recursion in its evaluation \n");
               mangleQualifiersString = "_function_parameter_";
             }
            else
             {
               mangleQualifiersString = mangleQualifiers(get_scope());
             }

       // SgName mangledName = joinMangledQualifiers (mangleQualifiers(get_scope()),get_name());
          SgName mangledName = joinMangledQualifiers (mangleQualifiersString,get_name());

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgEnumDeclaration*>(this),mangledName);
          return mangledName;
        }
#endif
   }

bool
SgEnumDeclaration::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgEnumDeclaration::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
#if 0
  // DQ (5/30/2007): We might want to look for either the symbol for the defining or the non-defining declaration.
  // SgSymbol* returnSymbol = get_scope()->get_symbol_table()->find(this);
     SgSymbol* returnSymbol = NULL;
     if (returnSymbol == NULL)
        {
       // The symbol appears to be typically associated with the defining declaration (perhaps because forward enums are non-standard).  
       // Though it might be that we should treat enums uniformly with other declarations now that we have recently added forward 
       // enum declarations as a supported non-standard feature (because most frontends do (except for GNU curiously enough)).
          if (this->get_definingDeclaration() != NULL)
             {
               returnSymbol = get_scope()->get_symbol_table()->find(this->get_definingDeclaration());
             }
            else
             {
               if (this->get_firstNondefiningDeclaration() != NULL)
                  {
                    returnSymbol = get_scope()->get_symbol_table()->find(this->get_firstNondefiningDeclaration());
                  }
                 else
                  {
                 // This is an error!
                    ROSE_ASSERT(false);
                  }
             }          
        }

     return returnSymbol;
#else
  // DQ (5/31/2007): This is the version that we want, it is consistent with the implementation elsewhere
  // and the correct fix was to handle the case where this is NULL (in src/frontend/SageIII/astMerge/collectAssocitateNodes.C).
     return get_scope()->get_symbol_table()->find(this);
#endif
   }


SOURCE_ENUM_DECLARATION_STATEMENT_END


SOURCE_EXPRESSION_STATEMENT_START
// QY: 9/30/2004   removed the expr_i pointer in exprStatement. Use exprRoot directly as constructor parameter
void
SgExprStatement::post_construction_initialization() 
   {
  // DQ (11/7/2006): removed use of expression root
  // if (get_expression_root() != NULL)
  //      get_expression_root()->set_statement(this);

  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.
     if (get_expression() != NULL)
          get_expression()->set_parent(this);
   }

// DQ (12/6/2006): We need this sort of function now that we have removed the expression root node!
// The requirement of not being able to do operations uniformly on expressions may be the disadvantage
// of not having used the SgExpressionRoot IR node as a concept.
int
SgExprStatement::replace_expression(SgExpression * original_expression, SgExpression * new_expression )
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(original_expression != NULL);
     ROSE_ASSERT(new_expression != NULL);

     ROSE_ASSERT(original_expression == p_expression);

     set_expression(new_expression);

     new_expression->set_parent(this);

  // DQ: Let this be a memory leak for now to avoid initial problems.
     ROSE_ASSERT(original_expression != NULL);
  // delete original_expression;

     return 0;
   }

SOURCE_EXPRESSION_STATEMENT_END


SOURCE_LABEL_STATEMENT_START

bool
SgLabelStatement::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }

void
SgLabelStatement::post_construction_initialization()
   {
   }

SgName
SgLabelStatement::get_name() const 
   {
     return get_label();
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgLabelStatement::get_symbol_from_symbol_table() const
   {
#if 0
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
#else
  // DQ (12/9/2007): The label's symbol is stored in the function definition, so we need to look for it there.
  // printf ("What is the scope of a label:%s scope = %s \n",get_name().str(),get_scope()->class_name().c_str());
  // SgFunctionDeclaration* functionDeclaration = TransformationSupport::getFunctionDeclaration(this);
     SgScopeStatement* tempScope = get_scope();
     ROSE_ASSERT(tempScope != NULL);
     while (tempScope != NULL && isSgFunctionDefinition(tempScope) == NULL)
        {
          tempScope = tempScope->get_scope();
        }

     SgFunctionDefinition* functionDefinition = isSgFunctionDefinition(tempScope);
     if (functionDefinition == NULL)
        {
          printf ("Labels are stored in the SgFunctionDefinition (function scope), could not locate associated function scope \n");
        }
     ROSE_ASSERT(functionDefinition != NULL);
     return functionDefinition->get_symbol_table()->find(this);
#endif
   }

SOURCE_LABEL_STATEMENT_END


SOURCE_WHILE_STATEMENT_START
void
SgWhileStmt::post_construction_initialization()
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(get_condition()) get_condition()->set_parent(this);
     if(get_body()) get_body()->set_parent(this);
#endif
   }

bool
SgWhileStmt::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_condition, target, newstmt) == true )
          return true;
     else return ( StatementReplace(this, p_body, target, newstmt) == true );
   }

#if 0
SgStatement*
SgWhileStmt::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          return get_condition();
        }
       else
          if(n==1)
             {
               n++;
               return get_body();
             }
     return 0; 
   }
#endif

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgWhileStmt::get_mangled_name(void) const
   {
     return SgName ("");
   }

SOURCE_WHILE_STATEMENT_END


SOURCE_DO_WHILE_STATEMENT_START
void
SgDoWhileStmt::post_construction_initialization()
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(get_condition()) get_condition()->set_parent(this);
     if(get_body()) get_body()->set_parent(this);
#endif
   }

bool
SgDoWhileStmt::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_condition, target, newstmt) == true )
          return true;
     else return ( StatementReplace(this, p_body, target, newstmt) == true );
}

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgDoWhileStmt::get_mangled_name(void) const
   {
     return SgName ("");
   }

SOURCE_DO_WHILE_STATEMENT_END


SOURCE_SWITCH_STATEMENT_START
void
SgSwitchStatement::post_construction_initialization()
   {
  // if (get_item_selector_root() != 0)
  //      get_item_selector_root()->set_parent(this);
     if (get_item_selector() != NULL)
          get_item_selector()->set_parent(this);

  // DQ (11/2/2007): Reset the scope of any variables declared in the item_selector
     SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(get_item_selector());
     if (variableDeclaration != NULL)
        {
       // Check the scopes of the SgInitializedName objects
          SgInitializedNamePtrList & variableList = variableDeclaration->get_variables();
          SgInitializedNamePtrList::iterator i = variableList.begin();
          while ( i != variableList.end() )
             {
               SgInitializedName* variable = *i;
               ROSE_ASSERT(variable != NULL);

               if (variable->get_scope() != this)
                  {
                 // printf ("In SgSwitchStatement::post_construction_initialization() variable = %p not placed into SgSwitchStatement scope = %p (correcting by moving the symbol) \n",variable,this);

                 // Remove the SgVariableSymbol from the switch body and put it into the SgSwitchStatement scope!
                    SgVariableSymbol* variableSymbol = isSgVariableSymbol(variable->get_symbol_from_symbol_table());

                 // The AST copy mechanism can cause this to fail because the scope has not been reset at this point.
                 // ROSE_ASSERT(variableSymbol != NULL);

                    if (variableSymbol != NULL)
                       {
                      // Reset the scope in the variable (only do this if variableSymbol != NULL so that it is not 
                      // set prematurely in the AST copy mechanism (else the pointer to the SgVariableDefinition 
                      // will not be copied properly).
                         variable->set_scope(this);

                         this->insert_symbol(variable->get_name(),variableSymbol);
                       }
                  }

               i++;
             }

        }
   }

bool
SgSwitchStatement::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {

     if ( StatementReplace(this, p_body, target, newstmt) )
         return true;
     if ( StatementReplace(this, p_item_selector, target, newstmt) )
         return true;
     return false;
   }

#include "sageBuilder.h"

void
SgSwitchStatement::append_case(SgCaseOptionStmt *& what)
   {
     assert(this != NULL);
     if(!get_body())
        {
       // set_body(new SgBasicBlock(this->get_file_info()));
          SgBasicBlock* newBlock = new SgBasicBlock ( this->get_file_info() );
          assert(newBlock != NULL);
          set_body(newBlock);
        }
     if (!isSgBasicBlock(get_body())) {
       set_body(SageBuilder::buildBasicBlock(get_body()));
       get_body()->set_parent(this);
     }
     ROSE_ASSERT (isSgBasicBlock(get_body()));
     SageInterface::appendStatement(what, isSgBasicBlock(get_body()));

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

void
SgSwitchStatement::prepend_case(SgCaseOptionStmt *& what)
   {
     assert(this != NULL);
     if(!get_body())
        {
       // set_body(new SgBasicBlock(this->get_file_info()));
          SgBasicBlock* newBlock = new SgBasicBlock ( this->get_file_info() );
          assert(newBlock != NULL);
          set_body(newBlock);
        }
     if (!isSgBasicBlock(get_body())) {
       set_body(SageBuilder::buildBasicBlock(get_body()));
       get_body()->set_parent(this);
     }
     ROSE_ASSERT (isSgBasicBlock(get_body()));
     SageInterface::prependStatement(what, isSgBasicBlock(get_body()));

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

void
SgSwitchStatement::append_default(SgDefaultOptionStmt *& what)
   {
  // if(!get_body()) set_body(new SgBasicBlock(this->get_file_info()));
     assert(this != NULL);
     if(!get_body())
        {
       // set_body(new SgBasicBlock(this->get_file_info()));
          SgBasicBlock* newBlock = new SgBasicBlock ( this->get_file_info() );
          assert(newBlock != NULL);
          set_body(newBlock);
        }
     if (!isSgBasicBlock(get_body())) {
       set_body(SageBuilder::buildBasicBlock(get_body()));
       get_body()->set_parent(this);
     }
     ROSE_ASSERT (isSgBasicBlock(get_body()));
     SageInterface::appendStatement(what, isSgBasicBlock(get_body()));

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgSwitchStatement::get_mangled_name(void) const
   {
     return SgName ("");
   }

SOURCE_SWITCH_STATEMENT_END


SOURCE_CASE_OPTION_STATEMENT_START

void
SgCaseOptionStmt::post_construction_initialization() 
   {
  // if (get_key_root() != 0)
  //      get_key_root()->set_statement(this);
   }

bool
SgCaseOptionStmt::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     return ( StatementReplace(this, p_body, target, newstmt) == true );
   }

SOURCE_CASE_OPTION_STATEMENT_END


SOURCE_TRY_STATEMENT_START

void
SgTryStmt::post_construction_initialization()
   {
  // MS: C++98: compound-statement (SgBasicBlock in SAGE)
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(get_body())
          get_body()->set_parent(this);
#endif

     // MS: moved catch_statement_seq to CatchStatementSeq, therefore we need to init it here now
     if (get_catch_statement_seq_root() == NULL)
        {
          Sg_File_Info* fileInfo = NULL;
          if (this->get_file_info() != NULL)
             {
            // Get a copy of this to avoid sharing!
               fileInfo = new Sg_File_Info( *(this->get_file_info()) );
             }
       // assert (fileInfo != NULL);
          SgCatchStatementSeq* catchStatement = NULL;
          if (fileInfo != NULL)
             {
            // DQ (10/16/2007): This appears to be set to the wrong parent.
            // DQ (12/18/2006): Added to set all parents of Sg_File_Info objects.
               fileInfo->set_parent(this);

            // DQ (10/31/2006): Set the end of source for the SgCatchStatementSeq
            // set_catch_statement_seq_root( new SgCatchStatementSeq(fileInfo));
               catchStatement = new SgCatchStatementSeq(fileInfo);

            // DQ (10/16/2007): Set the parent of the fileInfo used for the SgCatchStatementSeq to the catchStatement
               fileInfo->set_parent(catchStatement);

               catchStatement->set_endOfConstruct(New_File_Info(catchStatement));

            // DQ (10/16/2007): Set the parent
               catchStatement->get_endOfConstruct()->set_parent(catchStatement);
             }
            else
             {
               catchStatement = new SgCatchStatementSeq();
             }

          set_catch_statement_seq_root( catchStatement );
          // Liao, 10/29/2009, missing parent pointer
          catchStatement->set_parent(this); 
        }
   }

bool
SgTryStmt::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_body, target, newstmt) == true )
          return true;
       else
          return ( StatementReplace( this, p_catch_statement_seq_root, target, newstmt) == true );
   }


// MS: C++98: handler_seq (catch_statement_seq in SAGE)
SgStatementPtrList &
SgTryStmt::get_catch_statement_seq() {
     return get_catch_statement_seq_root()->get_catch_statement_seq();
}

// MS: C++98: handler_seq (catch_statement_seq in SAGE)
const SgStatementPtrList &
SgTryStmt::get_catch_statement_seq() const {
     return get_catch_statement_seq_root()->get_catch_statement_seq();
}

// MS: C++98: handler (catch_statement in SAGE)
void
SgTryStmt::append_catch_statement(SgStatement * what)
   {
  // DQ (6/4/2008): The SgCatchOptionStmt should have a parent pointing to 
  // the SgCatchStatementSeq in order for the Virtual CFG to work properly.

  // get_catch_statement_seq_root()->append_catch_statement(what);
  // what->set_parent(this);
  // get_catch_statement_seq_root()->append_catch_statement(what);
     SgCatchStatementSeq* catchStatementList = get_catch_statement_seq_root();
     ROSE_ASSERT(catchStatementList != NULL);
     catchStatementList->append_catch_statement(what);
     what->set_parent(catchStatementList);
   }

// MS: C++98: handler (catch_statement in SAGE)
void
SgTryStmt::prepend_catch_statement(SgStatement * what)
   {
     get_catch_statement_seq_root()->prepend_catch_statement(what);
     what->set_parent(this);
   }


#if 0
// MS: C++98: handler (catch_statement in SAGE)
void
SgTryStmt::insert_catch_statement(const SgStatementPtrList::iterator& where, SgStatement * what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif
     get_catch_statement_seq_root()->insert_catch_statement(where,what);
   }
#endif

SOURCE_TRY_STATEMENT_END

SOURCE_CATCH_STATEMENT_SEQ_START

// MS: C++98: handler (catch_statement in SAGE)
void
SgCatchStatementSeq::post_construction_initialization() {
  SgStatementPtrList::iterator p = get_catch_statement_seq().begin();
  for (p = get_catch_statement_seq().begin(); p != get_catch_statement_seq().end(); p++)
    {
      ROSE_ASSERT((*p) != NULL);
      delete (*p);
      (*p) = NULL;
    }
}

// MS: C++98: handler (catch_statement in SAGE)
void
SgCatchStatementSeq::append_catch_statement(SgStatement * what)
   {
     get_catch_statement_seq().push_back(what);
     what->set_parent(this);
   }

// MS: C++98: handler (catch_statement in SAGE)
void
SgCatchStatementSeq::prepend_catch_statement(SgStatement * what)
   {
     get_catch_statement_seq().insert(get_catch_statement_seq().begin(), what);
     what->set_parent(this);
   }

#if 0
// MS: C++98: handler (catch_statement in SAGE)
void
SgCatchStatementSeq::insert_catch_statement(const SgStatementPtrList::iterator& where, SgStatement * what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif
     get_catch_statement_seq().insert(where,what);
   }
#endif

SOURCE_CATCH_STATEMENT_SEQ_END



SOURCE_CATCH_OPTION_STATEMENT_START

void
SgCatchOptionStmt::post_construction_initialization()
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(get_condition()) get_condition()->set_parent(this);
     if(get_body()) get_body()->set_parent(this);
#endif
   }

// SgStatement* get_next(int&) const;

bool
SgCatchOptionStmt::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_condition, target, newstmt) == true )
         return true;
     else if ( StatementReplace(this, p_body, target, newstmt) == true )
         return true;
     else
         return false;
   }

#if 0
SgStatement*
SgCatchOptionStmt::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          if(get_condition())
               return get_condition();
            else
             {
               n++;
               return get_body();
             }
        }
       else
          if(n==1)
             {
               n++;
               get_body();
             }
     return 0;
   }
#endif

SgName
SgCatchOptionStmt::get_mangled_name(void) const
   {
  // DQ (2/22/2007): This function is added to prevent "::" substrings in mangled names of other declarations.
     return SgName("");
   }

SOURCE_CATCH_OPTION_STATEMENT_END


SOURCE_DEFAULT_OPTION_STATEMENT_START

void
SgDefaultOptionStmt::post_construction_initialization()
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     if (get_body()) get_body()->set_parent(this);
#endif
   }

// SgStatement* get_next(int&) const;

bool
SgDefaultOptionStmt::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     return ( StatementReplace(this, p_body, target, newstmt) == true );
   }

#if 0
SgStatement*
SgDefaultOptionStmt::get_next(int& n) const
   {
     if(n)
          return 0;
       else
        {
          n++;
          return get_body();
        }
   }
#endif

SOURCE_DEFAULT_OPTION_STATEMENT_END


SOURCE_BREAK_STATEMENT_START
void
SgBreakStmt::post_construction_initialization()
   {
   }

SOURCE_BREAK_STATEMENT_END


SOURCE_CONTINUE_STATEMENT_START

void
SgContinueStmt::post_construction_initialization()
   {
   }

SOURCE_CONTINUE_STATEMENT_END


SOURCE_RETURN_STATEMENT_START

void
SgReturnStmt::post_construction_initialization()
   {
  // DQ (11/7/2006): removed use of expression root
  // if (get_expression_root() != 0)
  //    get_expression_root()->set_statement(this);
   }

// DQ (12/15/2006): We need this sort of function now that we have removed the expression root node!
// The requirement of not being able to do operations uniformly on expressions may be the disadvantage
// of not having used the SgExpressionRoot IR node as a concept.
int
SgReturnStmt::replace_expression(SgExpression * original_expression, SgExpression * new_expression )
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(original_expression != NULL);
     ROSE_ASSERT(new_expression != NULL);

     ROSE_ASSERT(original_expression == p_expression);

     set_expression(new_expression);

     new_expression->set_parent(this);

  // DQ: Let this be a memory leak for now to avoid initial problems.
     ROSE_ASSERT(original_expression != NULL);
  // delete original_expression;

     return 0;
   }

SOURCE_RETURN_STATEMENT_END


SOURCE_GOTO_STATEMENT_START

void
SgGotoStatement::post_construction_initialization()
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(get_label())
        {
          get_label()->set_parent(this);
        }
#endif
   }

bool
SgGotoStatement::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     return ( StatementReplace(this, p_label, target, newstmt) == true );
   }

SOURCE_GOTO_STATEMENT_END


SOURCE_ASM_STATEMENT_START

void
SgAsmStmt::post_construction_initialization()
   {}

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgAsmStmt::get_mangled_name(void) const
   {
#if 0
     SgName returnName;

  // This is a poor way to handle the generation of unique strings (it also 
  // connects the unparser to the fronend handling which is not a great idea).
  // returnName = get_expr_root()->unparseToString();

  // DQ (7/22/2006): This IR node has been changed to have a list of SgAsmOp IR nodes
     SgExpressionPtrList::const_iterator i = p_operands.begin();
     while (i != p_operands.end())
        {
          returnName += (*i)->get_type()->get_mangled();
          i++;
        }

     return returnName;
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgAsmStmt* declaration = const_cast<SgAsmStmt*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgAsmStmt*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName mangledName;

       // This is a poor way to handle the generation of unique strings (it also 
       // connects the unparser to the frontend handling which is not a great idea).
       // returnName = get_expr_root()->unparseToString();

       // DQ (7/22/2006): This IR node has been changed to have a list of SgAsmOp IR nodes
          SgExpressionPtrList::const_iterator i = p_operands.begin();
          while (i != p_operands.end())
             {
               mangledName += (*i)->get_type()->get_mangled();
               i++;
             }

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgAsmStmt*>(this),mangledName);
          return mangledName;
        }
#endif
   }

// DQ (7/22/2006): We need these to be explicit since we can't support reference parameter passing within ROSETTA.
SgExpressionPtrList &
SgAsmStmt::get_operands()
   { return p_operands; }

const SgExpressionPtrList &
SgAsmStmt::get_operands() const
   { return p_operands; }

// DQ (7/27/2006): We need these to be explicit since we can't support reference parameter passing within ROSETTA.
SgAsmStmt::AsmRegisterNameList &
SgAsmStmt::get_clobberRegisterList()
   { return p_clobberRegisterList; }

const SgAsmStmt::AsmRegisterNameList &
SgAsmStmt::get_clobberRegisterList() const
   { return p_clobberRegisterList; }

SOURCE_ASM_STATEMENT_END


SOURCE_SPAWN_STATEMENT_START

void
SgSpawnStmt::post_construction_initialization()
   {}

SOURCE_SPAWN_STATEMENT_END


SOURCE_NULL_STATEMENT_START

void
SgNullStatement::post_construction_initialization()
   {}

SOURCE_NULL_STATEMENT_END


SOURCE_VARIANT_STATEMENT_START

void
SgVariantStatement::post_construction_initialization()
   {}

SOURCE_VARIANT_STATEMENT_END


SOURCE_TYPEDEF_DECLARATION_STATEMENT_START

void
SgTypedefDeclaration::post_construction_initialization()
   {
  // DQ (10/6/2004): I think this should be dependent upon if the type was provided as an input in 
  // the constructor parameter list (else why bother specifying it in the constructor parameter list!)
#if 0
#if PRINT_DEVELOPER_WARNINGS
     printf ("In $CLASSNAME::post_construction_initialization(): generating SgTypedefType internally! \n");
#endif
#endif
     set_type(SgTypedefType::createType(this));

     ROSE_ASSERT (get_base_type() != NULL);
     ROSE_ASSERT (get_base_type()->get_typedefs() != NULL);
     ROSE_ASSERT (get_base_type()->get_typedefs()->get_typedefs().size() > 0);
   }

// SgStatement *get_next(int&) const;

bool
SgTypedefDeclaration::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     return ( StatementReplace(this, p_declaration, target, newstmt) == true );
   }

#if 0
SgStatement*
SgTypedefDeclaration::get_next(int& n) const
   {
     if(n)
          return 0;
       else
        {
          n++;
          return get_declaration();
        }
   }
#endif

SgName
SgTypedefDeclaration::get_qualified_name() const
   {
  // DQ (10/15/2004): This function is similar to the one for SgClassDeclaration.
  // This function calls get_scope() which uses the parent pointers, thus 
  // it should not be called before the parent pointers are set (within the AST fixup after 
  // the Sage III AST is fully constructed).

  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

  // printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
   }

// RV (1/30/2006): Revised to follow typedef chains to their base types.
SgName
SgTypedefDeclaration::get_mangled_name (void) const
   {
#if 0
  // Ask for a mangled name from the base type
     SgType* baseType = get_base_type();
     SgName mangledName;
#if 0
     if (baseType)
        {
          mangledName = baseType->get_mangled();
        }

  // When no name is available, use the qualified typedef name.
  // Example: 'namespace N { typedef struct { int a; } foo_t; }'
  // becomes the mangled form of 'N::foo_t'.
     if (mangledName.is_null() == true)
          mangledName = joinMangledQualifiers (mangleQualifiers(get_scope()), get_name());
#else
  // DQ (6/3/2006): I think this is a better implementation of name mangling for a typedef 
  // (need to include the name and the type) but I'm not clear if we want the scope.
     ROSE_ASSERT(baseType != NULL);
     mangledName = joinMangledQualifiers (mangleQualifiers(get_scope()), get_name()) + baseType->get_mangled();

  // DQ (1/29/2007): We need to make this more specific to this IR nodes so that a typedef of an unnamed struct does not be mangled to be the same name
     mangledName += "__typedef_declaration";
#endif

  // printf ("In SgTypedefDeclaration::get_mangled_name(): mangledName = %s \n",mangledName.str());
    
     ROSE_ASSERT (mangledName.get_length () > 0);
     return mangledName;
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgTypedefDeclaration* declaration = const_cast<SgTypedefDeclaration*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgTypedefDeclaration*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName mangledName;

          SgType* baseType = get_base_type();

       // DQ (6/3/2006): I think this is a better implementation of name mangling for a typedef 
       // (need to include the name and the type) but I'm not clear if we want the scope.
          ROSE_ASSERT(baseType != NULL);
          mangledName = joinMangledQualifiers (mangleQualifiers(get_scope()), get_name()) + baseType->get_mangled();

       // DQ (1/29/2007): We need to make this more specific to this IR nodes so that a typedef of an unnamed struct does not be mangled to be the same name
          mangledName += "__typedef_declaration";

       // printf ("In SgTypedefDeclaration::get_mangled_name(): mangledName = %s \n",mangledName.str());
    
          ROSE_ASSERT (mangledName.get_length () > 0);

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgTypedefDeclaration*>(this),mangledName);
          return mangledName;
        }
#endif
   }

bool
SgTypedefDeclaration::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgTypedefDeclaration::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
   }

// GB (09/25/2007): Added this function as part of the traversal island fix. It returns the p_declaration data member,
// but only if this typedef statement is actually the place where the base type is defined.
SgDeclarationStatement *
SgTypedefDeclaration::compute_baseTypeDefiningDeclaration() const
   {
     if (p_typedefBaseTypeContainsDefiningDeclaration == true)
        {
          return p_declaration;
        }
     else
        {
          return NULL;
        }
   }

SgDeclarationStatement *
SgTypedefDeclaration::get_baseTypeDefiningDeclaration() const
   {
  // DQ (10/14/2007): This provides an public (compute_baseTypeDefiningDeclaration() is private)
  // interface similar to that for SgVariableDeclaration and for the same purpose (types defined 
  // in the typedef or variable declaration).

     return compute_baseTypeDefiningDeclaration();
   }

SOURCE_TYPEDEF_DECLARATION_STATEMENT_END


SOURCE_TEMPLATE_DECLARATION_STATEMENT_START
void
SgTemplateDeclaration::post_construction_initialization()
   {
   }

// DQ (9/8/2004): added support for qualified names
SgName
SgTemplateDeclaration::get_qualified_name() const
   {
  // DQ (8/28/2005): Modified to make this function consistent other get_qualified_name functions
  // It previously only returned the name of the scope.
#if 0
  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;
     string returnNameString;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // DQ (9/8/2004): Don't use the template name as is stored (which is a mangled name from EDG)
  // returnName = scope->get_qualified_name() << "::" << get_name().str();
     returnName = scope->get_qualified_name();
  // printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
#else
  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

  // printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
#endif
   }

bool
SgTemplateDeclaration::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgTemplateDeclaration::get_mangled_name(void) const
   {
#if 0
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = get_qualified_name() + SgName("_template_declaration_") + get_name();
     returnName = scope->get_mangled_name() + SgName("_template_declaration_") + get_name();

     return returnName;
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgTemplateDeclaration* declaration = const_cast<SgTemplateDeclaration*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgTemplateDeclaration*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName mangledName = get_scope()->get_mangled_name() + SgName("_template_declaration_") + get_name();

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgTemplateDeclaration*>(this),mangledName);
          return mangledName;
        }
#endif
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgTemplateDeclaration::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
   }

SOURCE_TEMPLATE_DECLARATION_STATEMENT_END


SOURCE_PRAGMA_STATEMENT_START
void
SgPragmaDeclaration::post_construction_initialization()
   {
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgPragmaDeclaration::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
  // SgScopeStatement* scope = get_scope();
  // ROSE_ASSERT(scope != NULL);

  // This is a poor way to handle the generation of a mangled name (will be improved)
     returnName = "pragma_statement";

     return returnName;
   }

SOURCE_PRAGMA_STATEMENT_END

SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT_START
void
$CLASSNAME::post_construction_initialization()
   {
   }

SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT_END



SOURCE_NAMESPACE_DECLARATION_STATEMENT_START

bool
SgNamespaceDeclarationStatement::isSameNamespace( const SgNamespaceDeclarationStatement* n ) const
   {
  // DQ (6/5/2007): Since namespaces are re-entrant we define a simple function to test if two namespaces 
  // are the same (not the same SgNamespaceDeclarationStatement, but the same namespace).
     ROSE_ASSERT(get_firstNondefiningDeclaration() != NULL);
     ROSE_ASSERT(n != NULL);
     ROSE_ASSERT(n->get_firstNondefiningDeclaration() != NULL);

     return ( get_firstNondefiningDeclaration() == n->get_firstNondefiningDeclaration() );
   }

// DQ (9/8/2004): Added to support qualified name generation
SgName
SgNamespaceDeclarationStatement::get_qualified_name() const
   {
     SgName returnName;

  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope!= NULL);

  // DQ (8/24/2006): Need to test for unnamed namespaces since we have to ignore the extra "::" that would be generated in this case!
  // returnName = scope->get_qualified_name() << "::" << get_name().str();
  // returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());
     if (get_name().is_null() == true)
        {
       // DQ (10/12/2006): Return and empty name instead of the qualified name 
       // of the current scope (see test2004_33.C using un-named namespaces).

       // Ignore the namespace name if it is a unnamed namespace
       // returnName = scope->get_qualified_name();

       // DQ (10/14/2006): Correction for un-named namespaces in nested scopes!
          if (isSgGlobal(scope) != NULL)
             {
            // If this is an un-named namespace in global scope then we are finished and the qualifier is empty.
               returnName = "";
             }
            else
             {
            // If we are not yet in global scope then go further!
               returnName = scope->get_qualified_name();
             }
        }
       else
        {
          returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());
        }

  // printf ("In SgNamespaceDeclarationStatement::get_qualified_name() : get_name().is_null == %s for name '%s'\n",get_name().is_null() ? "true" : "false", get_name().str());

     return returnName;
   }

// RV (2/1/2006): Added mangler for namespace declarations.
SgName
SgNamespaceDeclarationStatement::get_mangled_name (void) const
   {
#if 0
     return joinMangledQualifiers (mangleQualifiers(get_scope()), get_name());
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgNamespaceDeclarationStatement* declaration = const_cast<SgNamespaceDeclarationStatement*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgNamespaceDeclarationStatement*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName mangledName = joinMangledQualifiers (mangleQualifiers(get_scope()), get_name());

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgNamespaceDeclarationStatement*>(this),mangledName);
          return mangledName;
        }
#endif
   }

#if 0
// DQ (2/19/2006): Added to handle case destribed in the header file.
bool
SgNamespaceDeclarationStatement::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }
#endif

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgNamespaceDeclarationStatement::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
   }

SOURCE_NAMESPACE_DECLARATION_STATEMENT_END

SOURCE_NAMESPACE_ALIAS_DECLARATION_STATEMENT_START

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgNamespaceAliasDeclarationStatement::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_namespace_alias_") + get_name();
     returnName = scope->get_mangled_name() + SgName("_namespace_alias_") + get_name();

     return returnName;
   }

SgSymbol*
SgNamespaceAliasDeclarationStatement::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
   }

SOURCE_NAMESPACE_ALIAS_DECLARATION_STATEMENT_END

SOURCE_NAMESPACE_DEFINITION_STATEMENT_START

bool
SgNamespaceDefinitionStatement::isSameNamespace(const SgNamespaceDefinitionStatement* n ) const
   {
     ROSE_ASSERT(this != NULL);
     ROSE_ASSERT(n != NULL);
     ROSE_ASSERT(this->get_namespaceDeclaration() != NULL);
     ROSE_ASSERT(n->get_namespaceDeclaration() != NULL);

     return this->get_namespaceDeclaration()->isSameNamespace(n->get_namespaceDeclaration());
   }

void
SgNamespaceDefinitionStatement::append_declaration(SgDeclarationStatement * what) 
   {
     get_declarations().push_back(what);
     what->set_parent(this);
   }

void
SgNamespaceDefinitionStatement::prepend_declaration(SgDeclarationStatement * what) 
   {
     get_declarations().insert(get_declarations().begin(), what);
     what->set_parent(this);
   }

#if 0
void
SgNamespaceDefinitionStatement::insert_declaration ( const SgDeclarationStatementPtrList::iterator& where, 
                                 SgDeclarationStatement* what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif
     get_declarations().insert(where,what);
   }
#endif

// DQ (8/27/2004): Turn this back on!
#if 1
bool
SgNamespaceDefinitionStatement::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, get_declarations(), target, newstmt, inFront, extractBasicBlock, false);
   }

bool 
SgNamespaceDefinitionStatement::replace_child(SgStatement *target ,SgStatement * newstmt, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, get_declarations(), target, newstmt, true, extractBasicBlock, true);
   }
#endif

// DQ (9/8/2004): Added to support qualified name generation
SgName
SgNamespaceDefinitionStatement::get_qualified_name() const
   {
  // printf ("In $CLASSNAME::get_qualified_name() \n");

     ROSE_ASSERT(get_namespaceDeclaration() != NULL);
     return get_namespaceDeclaration()->get_qualified_name();
   }

// RV (2/1/2006): Added mangler for namespace definitions.
SgName
SgNamespaceDefinitionStatement::get_mangled_name (void) const
  {
    ROSE_ASSERT (get_namespaceDeclaration());
    return get_namespaceDeclaration()->get_mangled_name ();
  }

SOURCE_NAMESPACE_DEFINITION_STATEMENT_END

SOURCE_USING_DIRECTIVE_STATEMENT_START

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgUsingDirectiveStatement::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_using_directive_") + get_namespaceDeclaration()->get_mangled_name();
     returnName = scope->get_mangled_name() + SgName("_using_directive_") + get_namespaceDeclaration()->get_mangled_name();

     return returnName;
   }

SOURCE_USING_DIRECTIVE_STATEMENT_END

SOURCE_USING_DECLARATION_STATEMENT_START

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgUsingDeclarationStatement::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName name;
     if (get_declaration() != NULL)
          name = get_declaration()->get_mangled_name();
       else
        {
          ROSE_ASSERT(get_initializedName() != NULL);
          name = get_initializedName()->get_mangled_name();
        }

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_using_declaration_") + name;
     returnName = scope->get_mangled_name() + SgName("_using_declaration_") + name;

     return returnName;
   }

SOURCE_USING_DECLARATION_STATEMENT_END

SOURCE_TEMPLATE_INSTANTIATION_DIRECTIVE_STATEMENT_START

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgTemplateInstantiationDirectiveStatement::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_template_instantiation_directive_") + get_declaration()->get_mangled_name();
     returnName = scope->get_mangled_name() + SgName("_template_instantiation_directive_") + get_declaration()->get_mangled_name();

     return returnName;
   }

SOURCE_TEMPLATE_INSTANTIATION_DIRECTIVE_STATEMENT_END



// DQ (3/19/2007): Fortran IR node support
SOURCE_PROGRAM_HEADER_STATEMENT_START
void
SgProgramHeaderStatement::post_construction_initialization()
   {
   }

SgName
SgProgramHeaderStatement::get_mangled_name() const
   {
  // DQ (8/17/2007): This Fortran specific IR node can be as simple a mangled name as we like, I think.

  // printf ("SgProgramHeaderStatement::get_mangled_name() not implemented \n");
  // ROSE_ASSERT(false);
  // return get_name();
     return SgFunctionDeclaration::get_mangled_name();
   }


bool
SgProgramHeaderStatement::replace_child(SgStatement *target, SgStatement *newstmt, bool extractBasicBlock)
   {
     if(StatementReplace(this, p_definition, target, newstmt))
          return true;
     else
          return (StatementReplace(this, p_parameterList, target, newstmt));
   }

SOURCE_PROGRAM_HEADER_STATEMENT_END

SOURCE_PROCEDURE_HEADER_STATEMENT_START

void
SgProcedureHeaderStatement::post_construction_initialization()
   {
   }

SgName
SgProcedureHeaderStatement::get_mangled_name() const
   {
  // DQ (8/23/2007): Use the get_mangled_name() member function from the base class.
  // printf ("SgProcedureHeaderStatement::get_mangled_name() not implemented \n");
  // ROSE_ASSERT(false);
     return SgFunctionDeclaration::get_mangled_name();
   }

bool
SgProcedureHeaderStatement::isFunction() const
   {
     bool result = false;
     if (p_subprogram_kind == e_function_subprogram_kind)
        result = true;

     return result;
   }

bool
SgProcedureHeaderStatement::isSubroutine() const
   {
     bool result = false;
     if (p_subprogram_kind == e_subroutine_subprogram_kind)
        result = true;

     return result;
   }

bool
SgProcedureHeaderStatement::isBlockData() const
   {
     bool result = false;
     if (p_subprogram_kind == e_block_data_subprogram_kind)
        result = true;

     return result;
   }

SOURCE_PROCEDURE_HEADER_STATEMENT_END


SOURCE_ENTRY_STATEMENT_START

void
SgEntryStatement::post_construction_initialization()
   {
   }

SgName
SgEntryStatement::get_mangled_name() const
   {
     return SgFunctionDeclaration::get_mangled_name();
   }

SOURCE_ENTRY_STATEMENT_END


SOURCE_TYPEDEF_DECLARATION_STATEMENT_START

void
$CLASSNAME::post_construction_initialization()
   {
  // DQ (10/6/2004): I think this should be dependent upon if the type was provided as an input in 
  // the constructor parameter list (else why bother specifying it in the constructor parameter list!)
#if PRINT_DEVELOPER_WARNINGS
     printf ("In $CLASSNAME::post_construction_initialization(): generating SgTypedefType internally! \n");
#endif
     set_type($GRAMMAR_PREFIX_$GRAMMAR_X_MARKER_TypedefType::createType(this));

     ROSE_ASSERT (get_base_type() != NULL);
     ROSE_ASSERT (get_base_type()->get_typedefs() != NULL);
     ROSE_ASSERT (get_base_type()->get_typedefs()->get_typedefs().size() > 0);
   }

// $GRAMMAR_PREFIX_Statement *get_next(int&) const;

bool
$CLASSNAME::replace_child($GRAMMAR_PREFIX_Statement *target,$GRAMMAR_PREFIX_Statement *newstmt, bool extractBasicBlock)
{
    return StatementReplace(this, p_declaration, target, newstmt);
}

#if 0
$GRAMMAR_PREFIX_Statement*
$CLASSNAME::get_next(int& n) const
   {
     if(n)
          return 0;
       else
        {
          n++;
          return get_declaration();
        }
   }
#endif

$GRAMMAR_PREFIX_Name
$CLASSNAME::get_qualified_name() const
   {
  // DQ (10/15/2004): This function is similar to the one for SgClassDeclaration.
  // This function calls get_scope() which uses the parent pointers, thus 
  // it should not be called before the parent pointers are set (within the AST fixup after 
  // the Sage III AST is fully constructed).

     printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

     printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
   }

SOURCE_TYPEDEF_DECLARATION_STATEMENT_END


SOURCE_TEMPLATE_DECLARATION_STATEMENT_START
void
$CLASSNAME::post_construction_initialization()
   {
   }

// DQ (9/8/2004): added support for qualified names
SgName
$CLASSNAME::get_qualified_name() const
   {
  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;
     string returnNameString;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // DQ (9/8/2004): Don't use the template name as is stored (which is a mangled name from EDG)
  // returnName = scope->get_qualified_name() << "::" << get_name().str();
     returnName = scope->get_qualified_name();
  // printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
   }

#if 0
SgName
$CLASSNAME::get_name() const
   {
     
   }
#endif

SOURCE_TEMPLATE_DECLARATION_STATEMENT_END


SOURCE_PRAGMA_STATEMENT_START
void
$CLASSNAME::post_construction_initialization()
   {
   }

SOURCE_PRAGMA_STATEMENT_END

SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT_START
void
$CLASSNAME::post_construction_initialization()
   {
   }

SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT_END



SOURCE_NAMESPACE_DECLARATION_STATEMENT_START

// DQ (9/8/2004): Added to support qualified name generation
SgName
$CLASSNAME::get_qualified_name() const
   {
     SgName returnName;

  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope!= NULL);

  // returnName = scope->get_qualified_name() << "::" << get_name().str();
     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

     return returnName;
   }

SOURCE_NAMESPACE_DECLARATION_STATEMENT_END

// DQ (8/30/2009): These are redundant, it seems.
// SOURCE_  NAMESPACE_ALIAS_DECLARATION_STATEMENT_START
// SOURCE_  NAMESPACE_ALIAS_DECLARATION_STATEMENT_END

SOURCE_NAMESPACE_DEFINITION_STATEMENT_START

void
$CLASSNAME::append_declaration(SgDeclarationStatement * what) 
   {
     insert_declaration(get_declarations().end(),what);
   }

void
$CLASSNAME::prepend_declaration(SgDeclarationStatement * what) 
   {
     insert_declaration(get_declarations().begin(),what);
   }

void
$CLASSNAME::insert_declaration ( const SgDeclarationStatementPtrList::iterator& where, 
                                 SgDeclarationStatement* what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif
     get_declarations().insert(where,what);
   }

// DQ (8/27/2004): Turn this back on!
#if 1
bool
$CLASSNAME::insert_child($GRAMMAR_PREFIX_Statement* target, $GRAMMAR_PREFIX_Statement* newstmt, bool inFront, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, get_declarations(), target, newstmt, inFront, extractBasicBlock, false);
   }

bool 

$CLASSNAME::replace_child($GRAMMAR_PREFIX_Statement *target ,$GRAMMAR_PREFIX_Statement * newstmt, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, get_declarations(), target, newstmt, true, extractBasicBlock, true);
   }
#endif

// DQ (9/8/2004): Added to support qualified name generation
SgName
$CLASSNAME::get_qualified_name() const
   {
  // printf ("In $CLASSNAME::get_qualified_name() \n");

     ROSE_ASSERT(get_namespaceDeclaration() != NULL);
     return get_namespaceDeclaration()->get_qualified_name();
   }

SOURCE_NAMESPACE_DEFINITION_STATEMENT_END

SOURCE_COMMON_BLOCK_STATEMENT_START

void
SgCommonBlock::post_construction_initialization()
   {
   }

SgName
SgCommonBlock::get_mangled_name() const
   {
  // printf ("Sorry, SgCommonBlock::get_mangled_name() not implemented! \n");
     return SgName("");
   }

const SgCommonBlockObjectPtrList &
SgCommonBlock::get_block_list() const
   {
     return p_block_list;
   }

SgCommonBlockObjectPtrList &
SgCommonBlock::get_block_list()
   {
     return p_block_list;
   }

SOURCE_COMMON_BLOCK_STATEMENT_END

SOURCE_MODULE_STATEMENT_START

void
SgModuleStatement::post_construction_initialization()
   {}

SgName
SgModuleStatement::get_mangled_name() const
   {
  // printf ("Sorry, SgModuleStatement::get_mangled_name() not implemented! \n");
     return SgName("_module_");
   }

#if 0
const SgDeclarationStatementPtrList &
SgModuleStatement::get_members() const
   {
     return p_members;
   }

SgDeclarationStatementPtrList &
SgModuleStatement::get_members()
   {
     return p_members;
   }

void
$CLASSNAME::append_declaration(SgDeclarationStatement * what) 
   {
     insert_declaration(get_declarations().end(),what);
   }

void
$CLASSNAME::prepend_declaration(SgDeclarationStatement * what) 
   {
     insert_declaration(get_declarations().begin(),what);
   }

void
$CLASSNAME::insert_declaration ( const SgDeclarationStatementPtrList::iterator& where, 
                                 SgDeclarationStatement* what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif
     get_declarations().insert(where,what);
   }

// DQ (8/27/2004): Turn this back on!
#if 1
bool
$CLASSNAME::insert_child($GRAMMAR_PREFIX_Statement* target, $GRAMMAR_PREFIX_Statement* newstmt, bool inFront, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, get_declarations(), target, newstmt, inFront, extractBasicBlock, false);
   }

bool 
$CLASSNAME::replace_child($GRAMMAR_PREFIX_Statement *target ,$GRAMMAR_PREFIX_Statement * newstmt, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, get_declarations(), target, newstmt, true, extractBasicBlock, true);
   }
#endif
#endif

SOURCE_MODULE_STATEMENT_END

SOURCE_CONTAINS_STATEMENT_START

void
SgContainsStatement::post_construction_initialization()
   {
   }

SgName
SgContainsStatement::get_mangled_name() const
   {
  // printf ("Sorry, SgContainsStatement::get_mangled_name() not implemented! \n");
     return SgName("_contains_");
   }

SOURCE_CONTAINS_STATEMENT_END

SOURCE_USE_STATEMENT_START

void
SgUseStatement::post_construction_initialization()
   {}

SgName
SgUseStatement::get_mangled_name() const
   {
  // printf ("Sorry, SgUseStatement::get_mangled_name() not implemented! \n");
     return SgName("_use_");
   }

SOURCE_USE_STATEMENT_END

SOURCE_STOP_OR_PAUSE_STATEMENT_START

void
SgStopOrPauseStatement::post_construction_initialization()
   {
  // Set the parent of any input expression.
     if (p_code != NULL)
        {
          p_code->set_parent(this);
        }
   }

SOURCE_STOP_OR_PAUSE_STATEMENT_END

SOURCE_IO_STATEMENT_START

void
SgIOStatement::post_construction_initialization()
   {}

SOURCE_IO_STATEMENT_END


SOURCE_PRINT_STATEMENT_START

void
SgPrintStatement::post_construction_initialization()
   {}

SOURCE_PRINT_STATEMENT_END


SOURCE_READ_STATEMENT_START

void
SgReadStatement::post_construction_initialization()
   {}

SOURCE_READ_STATEMENT_END


SOURCE_WRITE_STATEMENT_START

void
SgWriteStatement::post_construction_initialization()
   {}

SOURCE_WRITE_STATEMENT_END


SOURCE_OPEN_STATEMENT_START

void
SgOpenStatement::post_construction_initialization()
   {}

SOURCE_OPEN_STATEMENT_END


SOURCE_CLOSE_STATEMENT_START

void
SgCloseStatement::post_construction_initialization()
   {}

SOURCE_CLOSE_STATEMENT_END


SOURCE_INQUIRE_STATEMENT_START

void
SgInquireStatement::post_construction_initialization()
   {}

SOURCE_INQUIRE_STATEMENT_END


SOURCE_FLUSH_STATEMENT_START

void
SgFlushStatement::post_construction_initialization()
   {}

SOURCE_FLUSH_STATEMENT_END


SOURCE_REWIND_STATEMENT_START

void
SgRewindStatement::post_construction_initialization()
   {}

SOURCE_REWIND_STATEMENT_END


SOURCE_BACKSPACE_STATEMENT_START

void
SgBackspaceStatement::post_construction_initialization()
   {}

SOURCE_BACKSPACE_STATEMENT_END


SOURCE_ENDFILE_STATEMENT_START

void
SgEndfileStatement::post_construction_initialization()
   {}

SOURCE_ENDFILE_STATEMENT_END


SOURCE_WAIT_STATEMENT_START

void
SgWaitStatement::post_construction_initialization()
   {}

SOURCE_WAIT_STATEMENT_END


SOURCE_FORTRAN_DO_STATEMENT_START
void
SgFortranDo::post_construction_initialization()
   {
   }

// Liao (3/11/2009): Added to provide uniform support of mangle names for all scopes
SgName
SgFortranDo::get_mangled_name(void) const
   {
     return SgName ("");
   }

SOURCE_FORTRAN_DO_STATEMENT_END


SOURCE_FORTRAN_NONBLOCKED_DO_STATEMENT_START
void
SgFortranNonblockedDo::post_construction_initialization()
   {
   }

SOURCE_FORTRAN_NONBLOCKED_DO_STATEMENT_END


SOURCE_INTERFACE_STATEMENT_START
void
SgInterfaceStatement::post_construction_initialization()
   {
#if 0
     if (p_function != NULL)
        {
          p_function->set_parent(this);
        }
#endif
   }

SgName
SgInterfaceStatement::get_mangled_name() const
   {
  // printf ("Sorry, SgInterfaceStatement::get_mangled_name() not implemented! \n");
     return SgName("_interface_");
   }

SOURCE_INTERFACE_STATEMENT_END


SOURCE_PARAMETER_STATEMENT_START
void
SgParameterStatement::post_construction_initialization()
   {
   }

SOURCE_PARAMETER_STATEMENT_END


SOURCE_BLOCK_DATA_STATEMENT_START
void
SgBlockDataStatement::post_construction_initialization()
   {}
SOURCE_BLOCK_DATA_STATEMENT_END


SOURCE_IMPLICIT_STATEMENT_START
void
SgImplicitStatement::post_construction_initialization()
   {}

SgName
SgImplicitStatement::get_mangled_name() const
   {
  // printf ("Sorry, SgImplicitStatement::get_mangled_name() not implemented! \n");
     return SgName("");
   }
SOURCE_IMPLICIT_STATEMENT_END


SOURCE_STATEMENT_FUNCTION_STATEMENT_START
void
SgStatementFunctionStatement::post_construction_initialization()
   {}

SgName
SgStatementFunctionStatement::get_mangled_name() const
   {
  // printf ("Sorry, SgStatementFunctionStatement::get_mangled_name() not implemented! \n");
     return SgName("");
   }
SOURCE_STATEMENT_FUNCTION_STATEMENT_END


SOURCE_WHERE_STATEMENT_START
void
SgWhereStatement::post_construction_initialization()
   {}
SOURCE_WHERE_STATEMENT_END


SOURCE_ELSE_WHERE_STATEMENT_START
void
SgElseWhereStatement::post_construction_initialization()
   {}
SOURCE_ELSE_WHERE_STATEMENT_END


SOURCE_NULLIFY_STATEMENT_START
void
SgNullifyStatement::post_construction_initialization()
   {}
SOURCE_NULLIFY_STATEMENT_END


SOURCE_EQUIVALENCE_STATEMENT_START

void
SgEquivalenceStatement::post_construction_initialization()
   {}

SgName
SgEquivalenceStatement::get_mangled_name() const
   {
  // printf ("Sorry, SgEquivalenceStatement::get_mangled_name() not implemented! \n");
     return SgName("");
   }
SOURCE_EQUIVALENCE_STATEMENT_END


SOURCE_DERIVED_TYPE_STATEMENT_START
void
SgDerivedTypeStatement::post_construction_initialization()
   {}

SgName
SgDerivedTypeStatement::get_mangled_name() const
   {
  // DQ (12/27/2010): This causes endless recursion when the type is defined locally to the 
  // function and the function uses the type as a return type (which seems like a language 
  // design mistake). Testcode test2010_179.f90 demonstrates this and it is actually a part
  // of the gfortran test suite, so I gather it is legal code.
  // To address this complexity I will make the fix in this IR node (which is fortran specific)
  // to use only the name plus the function and qualified name of the function's scope instead
  // of the generated function definition's mangled name which causes the endless recursion.
  // This will be done only for the case were we detect that the type is used as the return type of
  // the function.  I don't think that modules can be defined in functions, so I think this is OK.
  // return SgClassDeclaration::get_mangled_name();
     SgName mangleName;
     ROSE_ASSERT(this->get_parent() != NULL);
     SgFunctionDeclaration* functionDeclaration = TransformationSupport::getFunctionDeclaration(this->get_parent());

     bool defineShorterName = false;
     if (functionDeclaration != NULL)
        {
          SgFunctionType* functionType = isSgFunctionType(functionDeclaration->get_type());
          ROSE_ASSERT(functionType != NULL);
       // printf ("functionType = %p = %s \n",functionType,functionType->class_name().c_str());

          SgType* returnType = functionType->get_return_type();
          ROSE_ASSERT(returnType != NULL);
          if (returnType == this->get_type())
             {
               defineShorterName = true;
             }
        }

     if (defineShorterName == true)
        {
       // This defines a short (none endlessly recursive name) for the derived type mangled name.
          mangleName = "__NESTED_TYPE_USED_IN_FUNCTION_RETURN_TYPE_" + functionDeclaration->get_name() + "__" + this->get_name() + "__";
        }
       else
        {
          mangleName = SgClassDeclaration::get_mangled_name();
        }

     return mangleName;
   }
SOURCE_DERIVED_TYPE_STATEMENT_END


SOURCE_ATTRIBUTE_SPECIFICATION_STATEMENT_START
void
SgAttributeSpecificationStatement::post_construction_initialization()
   {}

SgName
SgAttributeSpecificationStatement::get_mangled_name(void) const
   {
  // printf ("Sorry, SgAttributeSpecificationStatement::get_mangled_name() not implemented! \n");
     return SgName ("__attribute_specification_statement__");
   }

const SgStringList &
SgAttributeSpecificationStatement::get_name_list() const
   {
     return p_name_list;
   }

SgStringList &
SgAttributeSpecificationStatement::get_name_list()
   {
     return p_name_list;
   }

const SgDataStatementGroupPtrList &
SgAttributeSpecificationStatement::get_data_statement_group_list() const
   {
     return p_data_statement_group_list;
   }

SgDataStatementGroupPtrList &
SgAttributeSpecificationStatement::get_data_statement_group_list()
   {
     return p_data_statement_group_list;
   }

const SgDimensionObjectPtrList &
SgAttributeSpecificationStatement::get_dimension_object_list() const
   {
     return p_dimension_object_list;
   }

SgDimensionObjectPtrList &
SgAttributeSpecificationStatement::get_dimension_object_list()
   {
     return p_dimension_object_list;
   }

SgSymbol*
SgAttributeSpecificationStatement::search_for_symbol_from_symbol_table() const
   {
#if 0
     SgDeclarationStatement* declaration = get_declaration_associated_with_symbol();
     if (declaration == NULL)
        {
          printf ("Error: in SgDeclarationStatement::search_for_symbol_from_symbol_table(): declaration == NULL \n");
          printf ("     this = %p = %s = %s \n",this,this->class_name().c_str(),SageInterface::get_name(this).c_str());
        }
     ROSE_ASSERT(declaration != NULL);
     SgSymbol* symbol = declaration->get_symbol_from_symbol_table();
     ROSE_ASSERT(symbol != NULL);
     return symbol;
#else
  // If we are searching for a symbol associated with this declaration, then it could only be a numeric label
  // in which case we have to search for it in the function scope (SgFunctionDefinition).

     SgScopeStatement* tempScope = get_scope();
     ROSE_ASSERT(tempScope != NULL);
     while (tempScope != NULL && isSgFunctionDefinition(tempScope) == NULL)
        {
          tempScope = tempScope->get_scope();
        }

     SgFunctionDefinition* functionDefinition = isSgFunctionDefinition(tempScope);
     if (functionDefinition == NULL)
        {
          printf ("Labels are stored in the SgFunctionDefinition (function scope), could not locate associated function scope \n");
        }
     ROSE_ASSERT(functionDefinition != NULL);
     return functionDefinition->get_symbol_table()->find(this);

  // printf ("In SgAttributeSpecificationStatement::search_for_symbol_from_symbol_table(): returning NULL \n");
  // return NULL;
#endif
   }

SOURCE_ATTRIBUTE_SPECIFICATION_STATEMENT_END


SOURCE_ALLOCATE_STATEMENT_START
void
SgAllocateStatement::post_construction_initialization()
   {}
SOURCE_ALLOCATE_STATEMENT_END


SOURCE_DEALLOCATE_STATEMENT_START
void
SgDeallocateStatement::post_construction_initialization()
   {}
SOURCE_DEALLOCATE_STATEMENT_END


SOURCE_CONTAINS_STATEMENT_START
void
SgContainsStatement::post_construction_initialization()
   {}
SOURCE_CONTAINS_STATEMENT_END


SOURCE_SEQUENCE_STATEMENT_START
void
SgSequenceStatement::post_construction_initialization()
   {}
SOURCE_SEQUENCE_STATEMENT_END



SOURCE_ARITHMETIC_IF_STATEMENT_START
void
SgArithmeticIfStatement::post_construction_initialization()
   {}
SOURCE_ARITHMETIC_IF_STATEMENT_END


SOURCE_ASSIGN_STATEMENT_START
void
SgAssignStatement::post_construction_initialization()
   {}
SOURCE_ASSIGN_STATEMENT_END


SOURCE_COMPUTED_GOTO_STATEMENT_START

void
SgComputedGotoStatement::post_construction_initialization()
   {}

#if 0
// DQ (12/30/2007): This list is no longer requires since we ave build the IR node for a SgLabelRefExp
// and we can hold this information using an more common ExprListExp instead.
const SgLabelSymbolPtrList & 
SgComputedGotoStatement::get_labelList() const
   {
     return p_labelList;
   }

SgLabelSymbolPtrList & 
SgComputedGotoStatement::get_labelList()
   {
     return p_labelList;
   }

void
SgComputedGotoStatement::set_labelList(const SgLabelSymbolPtrList & labelList)
   {
     p_labelList = labelList;
   }
#endif

SOURCE_COMPUTED_GOTO_STATEMENT_END


SOURCE_ASSIGNED_GOTO_STATEMENT_START
void
SgAssignedGotoStatement::post_construction_initialization()
   {}
SOURCE_ASSIGNED_GOTO_STATEMENT_END


SOURCE_NAMELIST_STATEMENT_START
void
SgNamelistStatement::post_construction_initialization()
   {}

SgName
SgNamelistStatement::get_mangled_name(void) const
   {
  // printf ("Sorry, SgNamelistStatement::get_mangled_name() not implemented! \n");
     return SgName ("__namelist__");
   }

const SgNameGroupPtrList &
SgNamelistStatement::get_group_list() const
   {
     return p_group_list;
   }

SgNameGroupPtrList &
SgNamelistStatement::get_group_list()
   {
     return p_group_list;
   }

SOURCE_NAMELIST_STATEMENT_END



SOURCE_IMPORT_STATEMENT_START
void
SgImportStatement::post_construction_initialization()
   {}

SgName
SgImportStatement::get_mangled_name(void) const
   {
  // printf ("Sorry, SgImportStatement::get_mangled_name() not implemented! \n");
     return SgName ("__import__");
   }

const SgExpressionPtrList &
SgImportStatement::get_import_list() const
   {
     return p_import_list;
   }

SgExpressionPtrList &
SgImportStatement::get_import_list()
   {
     return p_import_list;
   }

SOURCE_IMPORT_STATEMENT_END

SOURCE_ASSOCIATE_STATEMENT_START
void
SgAssociateStatement::post_construction_initialization()
   {}

SgName
SgAssociateStatement::get_mangled_name(void) const
   {
     return SgName ("__associate__");
   }

SOURCE_ASSOCIATE_STATEMENT_END


SOURCE_FORMAT_STATEMENT_START

void
SgFormatStatement::post_construction_initialization()
   {}

SgName
SgFormatStatement::get_mangled_name(void) const
   {
  // printf ("Sorry, SgFormatStatement::get_mangled_name() not implemented! \n");
     return SgName ("__format__");
   }

#if 0
const SgFormatItemPtrList & 
SgFormatStatement::get_format_item_list() const
   {
     return p_format_item_list;
   }

SgFormatItemPtrList & 
SgFormatStatement::get_format_item_list()
   {
     return p_format_item_list;
   }

void
SgFormatStatement::set_format_item_list(const SgFormatItemPtrList & format_item_list)
   {
     p_format_item_list = format_item_list;
   }
#endif

SOURCE_FORMAT_STATEMENT_END


SOURCE_FORTRAN_INCLUDE_LINE_START
       // Not sure if we need these...
       // virtual unsigned int cfgIndexForEnd() const;
       // virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
       // virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

SgName
SgFortranIncludeLine::get_mangled_name(void) const
   {
     return SgName ("__fortran_include_line__");
   }
SOURCE_FORTRAN_INCLUDE_LINE_END


SOURCE_PREPROCESSOR_DIRECTIVE_STATEMENT_START
void
SgC_PreprocessorDirectiveStatement::post_construction_initialization()
   {
   }

// DQ (11/29/2008): Added for uniform support of mangled names
SgName SgC_PreprocessorDirectiveStatement::get_mangled_name() const
   {
     return "__c_language_preprocessor_directive__";
   }

SOURCE_PREPROCESSOR_DIRECTIVE_STATEMENT_END


SOURCE_LINEMARKER_PREPROCESSOR_DIRECTIVE_STATEMENT_START
SOURCE_LINEMARKER_PREPROCESSOR_DIRECTIVE_STATEMENT_END

HEADER_OMP_PARALLEL_STATEMENT_START

HEADER_OMP_PARALLEL_STATEMENT_END

SOURCE_OMP_PARALLEL_STATEMENT_START
void
SgOmpParallelStatement::post_construction_initialization()
   {}
SOURCE_OMP_PARALLEL_STATEMENT_END

SOURCE_OMP_MASTER_STATEMENT_START
void
SgOmpMasterStatement::post_construction_initialization()
   {}
SOURCE_OMP_MASTER_STATEMENT_END


SOURCE_OMP_FLUSH_STATEMENT_START
void
SgOmpFlushStatement::post_construction_initialization()
   {}
SOURCE_OMP_FLUSH_STATEMENT_END


SOURCE_OMP_DO_STATEMENT_START
void
SgOmpDoStatement::post_construction_initialization()
   {}
SOURCE_OMP_DO_STATEMENT_END


SOURCE_OMP_SINGLE_STATEMENT_START
void
SgOmpSingleStatement::post_construction_initialization()
   {}
SOURCE_OMP_SINGLE_STATEMENT_END


SOURCE_OMP_CRITICAL_STATEMENT_START
void
SgOmpCriticalStatement::post_construction_initialization()
   {}
SOURCE_OMP_CRITICAL_STATEMENT_END

HEADER_OMP_THREADPRIVATE_STATEMENT_START
  //! Required for any declaration statement
  virtual SgName get_mangled_name(void) const;
HEADER_OMP_THREADPRIVATE_STATEMENT_END

SOURCE_OMP_THREADPRIVATE_STATEMENT_START
void
SgOmpThreadprivateStatement::post_construction_initialization()
   {}

SgName
SgOmpThreadprivateStatement::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName variableNames;
     SgVarRefExpPtrList::const_iterator p = get_variables().begin();
     while ( p != get_variables().end() )
        {
          ROSE_ASSERT ((*p)->get_symbol() != NULL);
          SgVariableSymbol * sym = isSgVariableSymbol ((*p)->get_symbol());
          ROSE_ASSERT (sym != NULL);
          ROSE_ASSERT (sym->get_declaration() != NULL);
          variableNames += SgName("_variable_type_") + (*p)->get_symbol()->get_type()->get_mangled() + 
                        SgName("_variable_name_") + sym->get_declaration()->get_mangled_name();

          p++;
        }
     returnName = scope->get_mangled_name() + SgName("_omp_threadprivate_declaration_") + variableNames;

     return returnName;
   }
   
SOURCE_OMP_THREADPRIVATE_STATEMENT_END


SOURCE_OMP_SECTIONS_STATEMENT_START
void
SgOmpSectionsStatement::post_construction_initialization()
   {}
SOURCE_OMP_SECTIONS_STATEMENT_END


SOURCE_OMP_TASKWAIT_STATEMENT_START
void
SgOmpTaskwaitStatement::post_construction_initialization()
   {}
SOURCE_OMP_TASKWAIT_STATEMENT_END

SOURCE_OMP_ATOMIC_STATEMENT_START
void
SgOmpAtomicStatement::post_construction_initialization()
   {}
SOURCE_OMP_ATOMIC_STATEMENT_END



SOURCE_OMP_ORDERED_STATEMENT_START
void
SgOmpOrderedStatement::post_construction_initialization()
   {}
SOURCE_OMP_ORDERED_STATEMENT_END


SOURCE_OMP_WORKSHARE_STATEMENT_START
void
SgOmpWorkshareStatement::post_construction_initialization()
   {}
SOURCE_OMP_WORKSHARE_STATEMENT_END


SOURCE_OMP_FOR_STATEMENT_START
void
SgOmpForStatement::post_construction_initialization()
   {}
SOURCE_OMP_FOR_STATEMENT_END


SOURCE_OMP_SECTION_STATEMENT_START
void
SgOmpSectionStatement::post_construction_initialization()
   {}
SOURCE_OMP_SECTION_STATEMENT_END


SOURCE_OMP_TASK_STATEMENT_START
void
SgOmpTaskStatement::post_construction_initialization()
   {}
SOURCE_OMP_TASK_STATEMENT_END

HEADER_OMP_BODY_STATEMENT_START
      virtual bool replace_child(SgStatement *,SgStatement *,
                                   bool extractListFromBasicBlock = false);
      public:

      virtual unsigned int cfgIndexForEnd() const;
      virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
      virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

HEADER_OMP_BODY_STATEMENT_END

SOURCE_OMP_BODY_STATEMENT_START
void
SgOmpBodyStatement::post_construction_initialization()
   {}

bool
SgOmpBodyStatement::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     return ( StatementReplace(this, p_body, target, newstmt) == true );
   }
SOURCE_OMP_BODY_STATEMENT_END


HEADER_OMP_CLAUSEBODY_STATEMENT_START
      public:

      virtual unsigned int cfgIndexForEnd() const;
      virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
      virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

HEADER_OMP_CLAUSEBODY_STATEMENT_END

SOURCE_OMP_CLAUSEBODY_STATEMENT_START
void
SgOmpClauseBodyStatement::post_construction_initialization()
   {}
SOURCE_OMP_CLAUSEBODY_STATEMENT_END


SOURCE_OMP_BARRIER_STATEMENT_START
void
SgOmpBarrierStatement::post_construction_initialization()
   {}
SOURCE_OMP_BARRIER_STATEMENT_END

// FMZ (2/3/2009): Added for co-array fortran "withteam" stmt
HEADER_WITH_TEAM_STATEMENT_START

HEADER_WITH_TEAM_STATEMENT_END

SOURCE_WITH_TEAM_STATEMEMT_START
void
SgCAFWithTeamStatement::post_construction_initialization()
{
}

SOURCE_WITH_TEAM_STATEMEMT_END



