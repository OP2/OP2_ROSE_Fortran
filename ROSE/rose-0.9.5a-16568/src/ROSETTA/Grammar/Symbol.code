// #########################################################
// #########################################################
//                      HEADER CODE
// #########################################################
// #########################################################

HEADER_START
          virtual SgName  get_name() const = 0;
          virtual SgType* get_type() const = 0;
          virtual SgNode* get_symbol_basis() const; // from HEADER

       // DQ (6/10/007): supports test of symbol declaration scope against symbol table's associated scope
          virtual SgScopeStatement* get_scope() const;
HEADER_END

HEADER_X_SYMBOL_START
          virtual SgName  get_name() const = 0;
          virtual SgType* get_type() const = 0;
          virtual SgNode* get_symbol_basis() const; // from X_SYMBOL
HEADER_X_SYMBOL_END

HEADER_NON_X_SYMBOL_START
HEADER_NON_X_SYMBOL_END


HEADER_GET_TYPE_START
          SgType* get_type() const;
       // SgNode* get_symbol_basis() const; // from GET_TYPE
HEADER_GET_TYPE_END

HEADER_GET_NAME_START
          SgName get_name() const;
          SgNode* get_symbol_basis() const; // from GET_NAME
HEADER_GET_NAME_END


HEADER_DECLARATION_START
          SgMemberFunctionDeclaration *get_declaration() const;

       // DQ (6/10/2007): This is now depricated in favor of a more uniform implementation for all symbols.
          SgClassDefinition *get_scope() const ROSE_DEPRECATED_FUNCTION;

       // SgNode* get_symbol_basis() const; // from DECLARATION
HEADER_DECLARATION_END

HEADER_TEMPLATE_INSTANTIATION_DECLARATION_START
          ** This code is not used by ROSETTA! **
          SgTemplateInstantiationDecl *get_declaration() const;
HEADER_TEMPLATE_INSTANTIATION_DECLARATION_END


HEADER_LABEL_SYMBOL_START

      //! Type of label used (fortran only)
          enum label_type_enum
             {
               e_unknown_label_type      = 0,
               e_non_numeric_label_type  = 1,
               e_start_label_type        = 2,
               e_else_label_type         = 3,
               e_end_label_type          = 4,
            // DQ (2/1/2011): Added support for Fortran specific alternative return labels.
               e_alternative_return_type = 5,
               e_last_label_type         = 6
             };

       // DQ (2/1/2011): Added support for named lable to handle arternative return parameters in Fortran.
       // SgLabelSymbol ( const SgName & name );
          SgLabelSymbol ( SgInitializedName* initializedName );

HEADER_LABEL_SYMBOL_END


HEADER_JAVA_LABEL_SYMBOL_START
// DQ (9/9/2011): Not clear yet what member functions we might require.
HEADER_JAVA_LABEL_SYMBOL_END


HEADER_ALIAS_SYMBOL_START
       // SgName  get_name() const;
       // SgType* get_type() const;
       // SgNode* get_symbol_basis() const;

      //! For a chain of aliased symbols, this function returns the last (non-aliased) symbol.
          SgSymbol* get_base() const;

      //! Where possible extract the declaration from the aliased symbol
          SgDeclarationStatement* get_declaration() const;
HEADER_ALIAS_SYMBOL_END

HEADER_RENAME_SYMBOL_START

      //! For a chain of aliased symbols the last link may be a SgRenameSymbol, this 
      //! function returns the declaration in the last (non-aliased and not renamed) symbol.
      //  SgSymbol* get_base() const;

HEADER_RENAME_SYMBOL_END

HEADER_NAMESPACE_SYMBOL_START
          void post_construction_initialization();
HEADER_NAMESPACE_SYMBOL_END


HEADER_ASM_BINARY_ADDRESS_SYMBOL_START
HEADER_ASM_BINARY_ADDRESS_SYMBOL_END

HEADER_ASM_BINARY_DATA_SYMBOL_START
HEADER_ASM_BINARY_DATA_SYMBOL_END

// #########################################################
// #########################################################
//                      SOURCE CODE
// #########################################################
// #########################################################

SOURCE_START
#if 1
// DQ (2/6/2007): This returns the basis for SgSymbol
SgNode*
SgSymbol::get_symbol_basis() const
   {
     return NULL;
   }
#endif

// This function has been implement to support testing of the scope of 
// the declartion with the scope of where the symbols are placed 
// (within the inserion and checking og symbol tables).
SgScopeStatement*
SgSymbol::get_scope() const
   {
     SgScopeStatement* scope = NULL;
     const SgNode* basis = get_symbol_basis();

     ROSE_ASSERT(basis != NULL);
  // printf ("In SgSymbol::get_scope(): basis = %p = %s \n",basis,basis->class_name().c_str());

     const SgInitializedName* initializedName = isSgInitializedName(basis);
     if (initializedName != NULL)
        {
          scope = initializedName->get_scope();
        }

     const SgStatement* statement = isSgStatement(basis);
     if (statement != NULL)
        {
          scope = statement->get_scope();
        }

     ROSE_ASSERT(scope != NULL);
     return scope;
   }

SOURCE_END

SOURCE_X_SYMBOL_START
SOURCE_X_SYMBOL_END


SOURCE_NON_X_SYMBOL_START

SgType*
$CLASSNAME::get_type() const 
   {
     return NULL;
   }

SgName
$CLASSNAME::get_name() const
   {
     return SgName("undefined_non_X_symbol");
   }

SgNode*
$CLASSNAME::get_symbol_basis() const
   {
     return NULL;
   }
SOURCE_NON_X_SYMBOL_END


SOURCE_LONG_GET_NAME_START
SgName 
SgVariableSymbol::get_name() const
   {
#if 0
   // (original note from Sage II) this is less efficient but it does avoid a bug in Sun C++
      SgName theName;

      if (get_declaration() != NULL) 
         {
           theName = get_declaration()->get_name();
         } 
        else 
         {
           theName = SgName("undefined");
         }

      return theName;
#else
      return (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");
#endif
   }

#if 1
// DQ (2/6/2007): This returns the basis for the SgVariableSymbol (an SgInitializedName object)
SgNode*
SgVariableSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }
#endif

SOURCE_LONG_GET_NAME_END


SOURCE_GET_TYPE_START
SgType*
$CLASSNAME::get_type() const
   {
     return (get_declaration() != NULL) ? get_declaration()->get_type() : NULL;
   }

#if 0
// DQ (2/6/2007): This returns the basis for the type based symbol (get_type for the SgFunctionTypeSymbol)
SgNode*
$CLASSNAME::get_symbol_basis() const
   {
     return get_type();
   }
#endif
SOURCE_GET_TYPE_END


SOURCE_EMPTY_GET_TYPE_START
SgType*
$CLASSNAME::get_type() const 
   {
     return NULL;
   }

#if 0
// DQ (2/6/2007): This returns the basis for the EMPTY_GET_TYPE
SgNode*
$CLASSNAME::get_symbol_basis() const
   {
     return NULL;
   }
#endif
SOURCE_EMPTY_GET_TYPE_END


SOURCE_SHORT_GET_NAME_START
SgName
$CLASSNAME::get_name() const 
   {
     return (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");
   }

// DQ (2/6/2007): This returns the basis for the SHORT_GET_NAME
SgNode*
$CLASSNAME::get_symbol_basis() const
   {
     return get_declaration();
   }
SOURCE_SHORT_GET_NAME_END

SOURCE_SHORT_EMPTY_GET_NAME_START
SgName
$CLASSNAME::get_name() const 
   {
     return NULL;
   }

#if 1
// DQ (2/6/2007): This returns the basis for the SHORT_EMPTY_GET_NAME
SgNode*
$CLASSNAME::get_symbol_basis() const
   {
     return NULL;
   }
#endif
SOURCE_SHORT_EMPTY_GET_NAME_END

SOURCE_SHORT_DEFAULT_GET_NAME_START
SgName
$CLASSNAME::get_name() const 
   {
     return "Default_Symbol_Name";
   }

// DQ (2/6/2007): This returns the basis for the SHORT_DEFAULT_GET_NAME
SgNode*
$CLASSNAME::get_symbol_basis() const
   {
     return NULL;
   }
SOURCE_SHORT_DEFAULT_GET_NAME_END


SOURCE_LABEL_SYMBOL_START
SgName
SgLabelSymbol::get_name() const
   {
  // DQ (12/9/2007): This IR node has been modified to hold a SgStatement in addition 
  // to a SgLabelStatement. by leaving the pointer to a SgLabelStatement I don't change
  // anything about how the C/C++ case works, but I have added a pointer to a SgStatement
  // so that the Fortran support can reference any statement (to support numeric labels
  // and non-numeric labels as well, though this is not yet implemented).  I plan to
  // merge the support for C/C++ and fortran a bit later after I am sure that this 
  // approach will work.

  // This handles the general case where for C/C++ the declaration statement is not set, 
  // but I think this should be an error.  Except that we have to handle the case of a 
  // label with unassociated statement in C.  So maybe we need to handle this case!

  // Previous implementation.
  // return (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");

     SgName name;
     if (get_declaration() != NULL)
        {
          name = get_declaration()->get_name();
        }
       else
        {
          SgStatement* fortranStatement = get_fortran_statement();
#if 0
          ROSE_ASSERT(fortranStatement != NULL);

       // int numericLabel = fortranStatement->get_numeric_label();
          int numericLabel = get_numeric_label_value();
       // printf ("SgLabelSymbol::get_name(): numericLabel = %d \n",numericLabel);

          name = StringUtility::numberToString(numericLabel);
#else
          if (fortranStatement != NULL)
             {
               int numericLabel = get_numeric_label_value();
               name = StringUtility::numberToString(numericLabel);
             }
            else
             {
            // DQ (2/2/2011): Fortran specific code.
               SgInitializedName* alternativeReturnDeclaration = get_fortran_alternate_return_parameter();
               if (alternativeReturnDeclaration != NULL)
                  {
                    name = alternativeReturnDeclaration->get_name();
                  }
             }
#endif
        }

     return name;
   }

// DQ (2/1/2011): This function has the wrong semantics for the case of labels.
// DQ (2/6/2007): This returns the basis for the SHORT_GET_NAME
SgNode*
SgLabelSymbol::get_symbol_basis() const
   {
  // DQ (12/9/2007): Modified (see comment above).
  // return get_declaration();

#if 0
  // DQ (2/2/2011): This is OK since this is the C/C++ semantics.
  // DQ (2/1/2011): This function has the wrong semantics for the case of labels.
  // I am not clear how to handle this function, but I think it is required to support 
  // internal testing of the symbol tables.  If we supported a pointer to the
  // SgInitializedName object used in the function declaration's parameter list,
  // then we could use that as a concept of declaration (similar to the semantics of 
  // a SgVariableSymbol).

     printf ("Error: This function has the wrong semantics for the case of labels. \n");
     ROSE_ASSERT(false);
#endif

  // SgStatement* returnStatement = get_declaration();
     SgLocatedNode* returnStatement = get_declaration();
     if (returnStatement == NULL)
        {
          SgStatement* fortranStatement = get_fortran_statement();
#if 0
          ROSE_ASSERT(fortranStatement != NULL);
          returnStatement = fortranStatement;
#else
          if (fortranStatement != NULL)
             {
               returnStatement = fortranStatement;
             }
            else
             {
               SgInitializedName* alternativeReturnDeclaration = get_fortran_alternate_return_parameter();
               if (alternativeReturnDeclaration != NULL)
                  {
                    returnStatement = alternativeReturnDeclaration;
                  }
             }
#endif
        }

     return returnStatement;
   }

SgType*
SgLabelSymbol::get_type() const 
   {
  // DQ (2/1/2011): Label symbols can only have a label type.
     return SgTypeLabel::createType();
   }

// DQ (2/1/2011): Added support for named lable to handle arternative return parameters in Fortran.
SgLabelSymbol::SgLabelSymbol ( SgInitializedName* initializedName )
   : SgSymbol()
   {
  // This constructor is used to support Fortran alternative return parameters in the function declaration.
  // Note that we don't really use the name but I didn't want to make this a default constructor.

  // We could support a pointer to the SgInitializedName object used in the function declaration's parameter list.
     ROSE_ASSERT(initializedName != NULL);

  // Verify that this is used correctly.
     ROSE_ASSERT(initializedName->get_name() == "*");

  // Set the internal mode to support analysis...
     p_label_type = e_alternative_return_type;

     set_fortran_alternate_return_parameter(initializedName);
   }

SOURCE_LABEL_SYMBOL_END


SOURCE_JAVA_LABEL_SYMBOL_START

// DQ (9/9/2011): Not clear yet what member functions we might require.

SgName
SgJavaLabelSymbol::get_name() const
   {
     ROSE_ASSERT(get_declaration() != NULL);

  // Calling get_label() is the perfered API.
  // SgName name = get_declaration()->get_name();
     SgName name = get_declaration()->get_label();

     return name;
   }

SgNode*
SgJavaLabelSymbol::get_symbol_basis() const
   {
     SgLocatedNode* returnStatement = get_declaration();
     ROSE_ASSERT(returnStatement != NULL);
     return returnStatement;
   }

SgType*
SgJavaLabelSymbol::get_type() const 
   {
  // DQ (9/9/2011): Use the common SgLabelType for both SgLableStatment and SgJavaLabelStatment.
  // At least until we can reason about why this is a bad idea.
     return SgTypeLabel::createType();
   }

SOURCE_JAVA_LABEL_SYMBOL_END


SOURCE_DECLARATION_START

SgMemberFunctionDeclaration*
SgMemberFunctionSymbol::get_declaration() const
   {
     SgFunctionDeclaration* funcionDeclaration = SgFunctionSymbol::get_declaration();
     if (funcionDeclaration == NULL)
          return NULL;
     SgMemberFunctionDeclaration* memberFuncionDeclaration = isSgMemberFunctionDeclaration(funcionDeclaration);
     ROSE_ASSERT(memberFuncionDeclaration != NULL);
     return memberFuncionDeclaration; 
   }

#if 1
// DQ (6/10/2007): This is now depricated in favor of a more uniform implementation for all symbols.
// This is used in the hidden list intersection code: 
//      astHiddenTypeAndDeclarationLists/HiddenList_Intersection.C
// and maybe else where as well.
SgClassDefinition*
SgMemberFunctionSymbol::get_scope() const
   {
  // DQ (7/28/2007): Call the base class instead
  // ROSE_ASSERT(get_declaration() != NULL);
  // return get_declaration()->get_class_scope();
     SgScopeStatement* scope = SgSymbol::get_scope();
     ROSE_ASSERT(scope != NULL);
     SgClassDefinition* classDefinition = isSgClassDefinition(scope);

     if (classDefinition == NULL)
        {
#if PRINT_DEVELOPER_WARNINGS
          printf ("In SgMemberFunctionSymbol::get_scope() (scope is not a SgClassDefinition, likely a pointer to member function): scope = %p = %s \n",scope,scope->class_name().c_str());
#endif
        }
  // ROSE_ASSERT(classDefinition != NULL);

     return classDefinition;
   }
#endif
#if 0
// DQ (2/6/2007): This returns the basis for the DECLARATION
SgNode*
SgMemberFunctionSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }
#endif
SOURCE_DECLARATION_END

SOURCE_TEMPLATE_INSTANTIATION_DECLARATION_START

 *** This case of ROSETTA test is not used! ***

SgTemplateInstantiationDecl*
#if 0
// DQ (12/23/2005): Not sure why this was eliminated a lot time ago.
$CLASSNAME::get_declaration() const
   {
     SgFunctionDeclaration* r = SgFunctionSymbol::get_declaration();
     if (r == 0)
          return 0;
     SgTemplateInstantiationDecl* r1 = isSgTemplateInstantiationDecl(r);
     ROSE_ASSERT(r1 != 0);
     return r1;
   }
#endif

SOURCE_TEMPLATE_INSTANTIATION_DECLARATION_END

SOURCE_MODULE_GET_NAME_START
SgName 
SgModuleSymbol::get_name() const
   {
#if 1 
   // (original note from Sage II) this is less efficient but it does avoid a bug in Sun C++
      $GRAMMAR_PREFIX_Name theName;

      if (get_declaration()) 
         {
           theName = get_declaration()->get_name();
         } 
        else 
         {
           theName = $GRAMMAR_PREFIX_Name("undefined");
         }

      return theName;
#else
      return (get_declaration) ? get_declaration()->get_name() : $GRAMMAR_PREFIX_Name("undefined");
#endif
   }

// DQ (2/6/2007): This returns the basis for the SgModuleSymbol
SgNode*
SgModuleSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }

SOURCE_MODULE_GET_NAME_END

SOURCE_COMMON_GET_NAME_START
SgName 
SgCommonSymbol::get_name() const
   {
#if 1 
   // (original note from Sage II) this is less efficient but it does avoid a bug in Sun C++
      $GRAMMAR_PREFIX_Name theName;

      if (get_declaration()) 
         {
           theName = get_declaration()->get_name();
         } 
        else 
         {
           theName = $GRAMMAR_PREFIX_Name("undefined");
         }

      return theName;
#else
      return (get_declaration) ? get_declaration()->get_name() : $GRAMMAR_PREFIX_Name("undefined");
#endif
   }

SgNode*
SgCommonSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }

SOURCE_COMMON_GET_NAME_END

SOURCE_INTRIN_GET_NAME_START
SgName 
SgIntrinsicSymbol::get_name() const
   {
#if 1 
   // (original note from Sage II) this is less efficient but it does avoid a bug in Sun C++
      $GRAMMAR_PREFIX_Name theName;

      if (get_declaration()) 
         {
           theName = get_declaration()->get_name();
         } 
        else 
         {
           theName = $GRAMMAR_PREFIX_Name("undefined");
         }

      return theName;
#else
      return (get_declaration) ? get_declaration()->get_name() : $GRAMMAR_PREFIX_Name("undefined");
#endif
   }

SgNode*
SgIntrinsicSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }

SOURCE_INTRIN_GET_NAME_END

SOURCE_INTERFACE_GET_NAME_START
SgName
SgInterfaceSymbol::get_name() const
   {
#if 1 
   // (original note from Sage II) this is less efficient but it does avoid a bug in Sun C++
      $GRAMMAR_PREFIX_Name theName;

      if (get_declaration()) 
         {
           theName = get_declaration()->get_name();
         } 
        else 
         {
           theName = $GRAMMAR_PREFIX_Name("undefined");
         }

      return theName;
#else
      return (get_declaration) ? get_declaration()->get_name() : $GRAMMAR_PREFIX_Name("undefined");
#endif
   }

SgNode*
SgInterfaceSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }

SOURCE_INTERFACE_GET_NAME_END



SOURCE_ALIAS_SYMBOL_START
SgName
SgAliasSymbol::get_name() const
   {
     ROSE_ASSERT(p_alias != NULL);

     SgName name;
     if (get_isRenamed() == true)
        {
          name = get_new_name();
        }
       else
        {
          name = get_alias()->get_name();
        }

     return name;
   }

SgNode*
SgAliasSymbol::get_symbol_basis() const
   {
     ROSE_ASSERT(p_alias != NULL);
     return get_alias()->get_symbol_basis();
   }

SgType*
SgAliasSymbol::get_type() const 
   {
     ROSE_ASSERT(p_alias != NULL);
     return get_alias()->get_type();
   }

SgSymbol*
SgAliasSymbol::get_base() const
   {
  // DQ (10/9/2008): For a chain of aliased symbols, this function returns the last (non-aliased) symbol.
     SgSymbol* nonAliasedSymbol = get_alias();
     ROSE_ASSERT(nonAliasedSymbol != NULL);

     SgAliasSymbol* aliasSymbol = isSgAliasSymbol(get_alias());
     while (aliasSymbol != NULL)
        {
       // This may be any symbol (even a SgAliasSymbol)
          nonAliasedSymbol = aliasSymbol->get_alias();

       // Advance in the chain to the next SgAliasSymbol symbol
          aliasSymbol = isSgAliasSymbol(aliasSymbol->get_alias());
        }

  // Every chain of aliased symbols should have a non-aliased symbol at the end!
     ROSE_ASSERT(nonAliasedSymbol != NULL);
     return nonAliasedSymbol;
   }


SgDeclarationStatement*
SgAliasSymbol::get_declaration() const
   {
  // DQ (4/14/2010): Added support for getting declarations from the alias symbols.

     ROSE_ASSERT(get_alias() != NULL);

     SgDeclarationStatement* returnValue = NULL;
     switch (get_alias()->variantT())
        {
          case V_SgNamespaceSymbol:
             {
               SgNamespaceSymbol* symbol = isSgNamespaceSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

          case V_SgVariableSymbol:
             {
            // This case is a bit special since the SgInitializedName is not a declaration
            // and thus the get_declaration() function does not return a SgDeclarationStatement.
               SgVariableSymbol* symbol = isSgVariableSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               SgInitializedName* initializedName = isSgInitializedName(symbol->get_declaration());
               ROSE_ASSERT(initializedName != NULL);
               SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(initializedName->get_parent());
               ROSE_ASSERT(variableDeclaration != NULL);
               returnValue = variableDeclaration;
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

          case V_SgFunctionSymbol:
             {
               SgFunctionSymbol* symbol = isSgFunctionSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

           case V_SgClassSymbol:
             {
               SgClassSymbol* symbol = isSgClassSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

           case V_SgEnumSymbol:
             {
               SgEnumSymbol* symbol = isSgEnumSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

           case V_SgEnumFieldSymbol:
             {
               SgEnumFieldSymbol* symbol = isSgEnumFieldSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               SgInitializedName* initializedName = isSgInitializedName(symbol->get_declaration());
               ROSE_ASSERT(initializedName != NULL);

            // DQ (5/20/2010): Call the SgInitializedName::get_declaration() function directly instead.
            // SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(initializedName->get_parent());
            // ROSE_ASSERT(variableDeclaration != NULL);
            // returnValue = variableDeclaration;
               returnValue = initializedName->get_declaration();

               ROSE_ASSERT(returnValue != NULL);
               break;
             }
#if 0
        // I don't think we want to handle this case (at least not as part of alias support)!
           case V_SgLabelSymbol:
             {
               SgLabelSymbol* symbol = isSgLabelSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }
#endif
           case V_SgTemplateSymbol:
             {
               SgTemplateSymbol* symbol = isSgTemplateSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

           case V_SgTypedefSymbol:
             {
               SgTypedefSymbol* symbol = isSgTypedefSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

           case V_SgAliasSymbol:
             {
               SgAliasSymbol* symbol = isSgAliasSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

          default:
             {
               printf ("Error: default reached in switch inside of SgAliasSymbol::get_declaration() get_alias() = %p = %s \n",get_alias(),get_alias()->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }

     return returnValue;
   }

SOURCE_ALIAS_SYMBOL_END

SOURCE_RENAME_SYMBOL_START
SgName
SgRenameSymbol::get_name() const
   {
     ROSE_ASSERT(p_original_symbol != NULL);

#if 0
     ROSE_ASSERT(get_isRenamed() == true);

     SgName name;
     if (get_isRenamed() == true)
        {
          name = get_new_name();
        }
       else
        {
          name = get_original_symbol()->get_name();
        }
#else
  // This is a difference between SgAliasSymbol and SgRenameSymbol
     SgName name = get_new_name();
#endif

     return name;
   }

SgNode*
SgRenameSymbol::get_symbol_basis() const
   {
     ROSE_ASSERT(p_original_symbol != NULL);
     return get_original_symbol()->get_symbol_basis();
   }

SgType*
SgRenameSymbol::get_type() const 
   {
     ROSE_ASSERT(p_original_symbol != NULL);
     return get_original_symbol()->get_type();
   }

#if 0
// DQ (10/11/2008): This is derived from SgFunctionSymbol and so we don't require this member function?

SgSymbol*
SgRenameSymbol::get_base() const
   {
  // DQ (10/9/2008): For a chain of aliased symbols, this function returns the last (non-aliased) symbol.
     SgSymbol* nonAliasedSymbol = get_alias();
     ROSE_ASSERT(nonAliasedSymbol != NULL);

XXXXX

This is not FINISHED!!!

XXXXX

     SgAliasSymbol*  aliasSymbol  = isSgAliasSymbol (get_alias());
     SgRenameSymbol* renameSymbol = isSgRenameSymbol(get_alias());
     while (aliasSymbol != NULL || renameSymbol != NULL)
        {
       // This may be any symbol (even a SgAliasSymbol)
          if (aliasSymbol != NULL)
             {
               nonAliasedSymbol = aliasSymbol->get_alias();
             }
            else
             {
               if (renameSymbol != NULL)
                  {
                    nonAliasedSymbol = renameSymbol->get_alias();
                  }
                 else
                  {
                    printf ("Error: aliasSymbol == NULL and renameSymbol == NULL \n");
                    ROSE_ASSERT(false);
                  }
             }

       // Advance in the chain to the next SgAliasSymbol symbol
          aliasSymbol = isSgAliasSymbol(aliasSymbol->get_alias());
        }

  // Every chain of aliased symbols should have a non-aliased symbol at the end!
     ROSE_ASSERT(nonAliasedSymbol != NULL);
     return nonAliasedSymbol;
   }
#endif

SOURCE_RENAME_SYMBOL_END


SOURCE_NAMESPACE_SYMBOL_START

SgName
SgNamespaceSymbol::get_name() const 
   {
  // DQ (8/30/2009): Added support for SgNamespaceAliasDeclarationStatement
     SgName n;
     if (p_isAlias == true)
        {
          n = (get_aliasDeclaration() != NULL) ? get_aliasDeclaration()->get_name() : SgName("undefined");
        }
       else
        {
          n = (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");
        }

  // return (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");
     return n;
   }

// DQ (2/6/2007): This returns the basis for the SHORT_GET_NAME
SgNode*
SgNamespaceSymbol::get_symbol_basis() const
   {
  // DQ (8/30/2009): Added support for SgNamespaceAliasDeclarationStatement
     SgNode* declaration = NULL;
     if (p_isAlias == true)
        {
          declaration = get_aliasDeclaration();
        }
       else
        {
          declaration = get_declaration();
        }

  // return get_declaration();
     return declaration;
   }

void
SgNamespaceSymbol::post_construction_initialization()
   {
  // DQ (8/30/2009): Added support for namespace alias in the SgNamespaceSymbol

     ROSE_ASSERT(p_declaration != NULL || p_aliasDeclaration != NULL);
     ROSE_ASSERT(p_declaration == NULL || p_aliasDeclaration == NULL);

  // Mark this symbol as representing a namespace alias
     if (p_aliasDeclaration != NULL)
          set_isAlias(true);
   }

SOURCE_NAMESPACE_SYMBOL_END


SOURCE_ASM_BINARY_ADDRESS_SYMBOL_START

SgType*
$CLASSNAME::get_type() const 
   {
     return NULL;
   }

SgName
$CLASSNAME::get_name() const
   {
     return SgName("undefined_binary_address_symbol");
   }

SgNode*
$CLASSNAME::get_symbol_basis() const
   {
     return NULL;
   }

SOURCE_ASM_BINARY_ADDRESS_SYMBOL_END

SOURCE_ASM_BINARY_DATA_SYMBOL_START

SgType*
$CLASSNAME::get_type() const 
   {
     return NULL;
   }

SgName
$CLASSNAME::get_name() const
   {
     return SgName("undefined_binary_data_variable_symbol");
   }

SgNode*
$CLASSNAME::get_symbol_basis() const
   {
     return NULL;
   }

SOURCE_ASM_BINARY_DATA_SYMBOL_END










