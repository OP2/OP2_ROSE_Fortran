// DO NOT EDIT -- This file was generated by ../../../scripts/stringify.pl.

#include "stringify.h"
#include <cassert>
#include <cstdio>
#include <cstring>

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// AST_Graph::pointerHandling is defined at src/frontend/SageIII/astVisualization/astGraph.h:13
/** Converts an enum of type AST_Graph::pointerHandling to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAST_Graph_pointerHandling(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "graph_NULL"; break;
        case 1: retval = "do_not_graph_NULL"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(AST_Graph::pointerHandling)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AST_Graph::pointerHandling::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// AST_Graph::traversalType is defined at src/frontend/SageIII/astVisualization/astGraph.h:20
/** Converts an enum of type AST_Graph::traversalType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAST_Graph_traversalType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "memory_pool_traversal"; break;
        case 1: retval = "whole_graph_AST"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(AST_Graph::traversalType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AST_Graph::traversalType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// ArmInstructionCondition is defined at src/frontend/BinaryDisassembly/armInstructionEnum.h:124
/** Converts an enum of type ArmInstructionCondition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyArmInstructionCondition(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "arm_cond_unknown"; break;
        case 1: retval = "arm_cond_eq"; break;
        case 2: retval = "arm_cond_ne"; break;
        case 3: retval = "arm_cond_hs"; break;
        case 4: retval = "arm_cond_lo"; break;
        case 5: retval = "arm_cond_mi"; break;
        case 6: retval = "arm_cond_pl"; break;
        case 7: retval = "arm_cond_vs"; break;
        case 8: retval = "arm_cond_vc"; break;
        case 9: retval = "arm_cond_hi"; break;
        case 10: retval = "arm_cond_ls"; break;
        case 11: retval = "arm_cond_ge"; break;
        case 12: retval = "arm_cond_lt"; break;
        case 13: retval = "arm_cond_gt"; break;
        case 14: retval = "arm_cond_le"; break;
        case 15: retval = "arm_cond_al"; break;
        case 16: retval = "arm_cond_nv"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(ArmInstructionCondition)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ArmInstructionCondition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// ArmInstructionKind is defined at src/frontend/BinaryDisassembly/armInstructionEnum.h:19
/** Converts an enum of type ArmInstructionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyArmInstructionKind(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "arm_unknown_instruction"; break;
        case 1: retval = "arm_adc"; break;
        case 2: retval = "arm_adcs"; break;
        case 3: retval = "arm_add"; break;
        case 4: retval = "arm_adds"; break;
        case 5: retval = "arm_and"; break;
        case 6: retval = "arm_ands"; break;
        case 7: retval = "arm_b"; break;
        case 8: retval = "arm_bic"; break;
        case 9: retval = "arm_bics"; break;
        case 10: retval = "arm_bkpt"; break;
        case 11: retval = "arm_bl"; break;
        case 12: retval = "arm_blx"; break;
        case 13: retval = "arm_bx"; break;
        case 14: retval = "arm_bxj"; break;
        case 15: retval = "arm_clz"; break;
        case 16: retval = "arm_cmn"; break;
        case 17: retval = "arm_cmp"; break;
        case 18: retval = "arm_eor"; break;
        case 19: retval = "arm_eors"; break;
        case 20: retval = "arm_ldm"; break;
        case 21: retval = "arm_ldmda"; break;
        case 22: retval = "arm_ldmdb"; break;
        case 23: retval = "arm_ldmia"; break;
        case 24: retval = "arm_ldmib"; break;
        case 25: retval = "arm_ldr"; break;
        case 26: retval = "arm_ldrb"; break;
        case 27: retval = "arm_ldrbt"; break;
        case 28: retval = "arm_ldrd"; break;
        case 29: retval = "arm_ldrsb"; break;
        case 30: retval = "arm_ldrsh"; break;
        case 31: retval = "arm_ldrt"; break;
        case 32: retval = "arm_ldruh"; break;
        case 33: retval = "arm_mla"; break;
        case 34: retval = "arm_mlas"; break;
        case 35: retval = "arm_mov"; break;
        case 36: retval = "arm_movs"; break;
        case 37: retval = "arm_mrs"; break;
        case 38: retval = "arm_msr"; break;
        case 39: retval = "arm_mul"; break;
        case 40: retval = "arm_muls"; break;
        case 41: retval = "arm_mvn"; break;
        case 42: retval = "arm_mvns"; break;
        case 43: retval = "arm_orr"; break;
        case 44: retval = "arm_orrs"; break;
        case 45: retval = "arm_qadd"; break;
        case 46: retval = "arm_qdadd"; break;
        case 47: retval = "arm_qdsub"; break;
        case 48: retval = "arm_qsub"; break;
        case 49: retval = "arm_rsb"; break;
        case 50: retval = "arm_rsbs"; break;
        case 51: retval = "arm_rsc"; break;
        case 52: retval = "arm_rscs"; break;
        case 53: retval = "arm_sbc"; break;
        case 54: retval = "arm_sbcs"; break;
        case 55: retval = "arm_setend"; break;
        case 56: retval = "arm_smlabb"; break;
        case 57: retval = "arm_smlabt"; break;
        case 58: retval = "arm_smlal"; break;
        case 59: retval = "arm_smlalbb"; break;
        case 60: retval = "arm_smlalbt"; break;
        case 61: retval = "arm_smlals"; break;
        case 62: retval = "arm_smlaltb"; break;
        case 63: retval = "arm_smlaltt"; break;
        case 64: retval = "arm_smlatb"; break;
        case 65: retval = "arm_smlatt"; break;
        case 66: retval = "arm_smlawb"; break;
        case 67: retval = "arm_smlawt"; break;
        case 68: retval = "arm_smluwb"; break;
        case 69: retval = "arm_smluwt"; break;
        case 70: retval = "arm_smulbb"; break;
        case 71: retval = "arm_smulbt"; break;
        case 72: retval = "arm_smull"; break;
        case 73: retval = "arm_smulls"; break;
        case 74: retval = "arm_smultb"; break;
        case 75: retval = "arm_smultt"; break;
        case 76: retval = "arm_stm"; break;
        case 77: retval = "arm_stmda"; break;
        case 78: retval = "arm_stmdb"; break;
        case 79: retval = "arm_stmia"; break;
        case 80: retval = "arm_stmib"; break;
        case 81: retval = "arm_str"; break;
        case 82: retval = "arm_strb"; break;
        case 83: retval = "arm_strbt"; break;
        case 84: retval = "arm_strd"; break;
        case 85: retval = "arm_strh"; break;
        case 86: retval = "arm_strt"; break;
        case 87: retval = "arm_sub"; break;
        case 88: retval = "arm_subs"; break;
        case 89: retval = "arm_swi"; break;
        case 90: retval = "arm_swp"; break;
        case 91: retval = "arm_teq"; break;
        case 92: retval = "arm_tst"; break;
        case 93: retval = "arm_umaal"; break;
        case 94: retval = "arm_umlal"; break;
        case 95: retval = "arm_umlals"; break;
        case 96: retval = "arm_umull"; break;
        case 97: retval = "arm_umulls"; break;
        case 98: retval = "arm_undefined"; break;
        case 99: retval = "arm_last_instruction"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(ArmInstructionKind)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ArmInstructionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// ArmProgramStatusRegister is defined at src/frontend/BinaryDisassembly/armInstructionEnum.h:13
/** Converts an enum of type ArmProgramStatusRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyArmProgramStatusRegister(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "arm_psr_current"; break;
        case 1: retval = "arm_psr_saved"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(ArmProgramStatusRegister)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ArmProgramStatusRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// ArmRegisterClass is defined at src/frontend/BinaryDisassembly/armInstructionEnum.h:7
/** Converts an enum of type ArmRegisterClass to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyArmRegisterClass(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "arm_regclass_gpr"; break;
        case 1: retval = "arm_regclass_psr"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(ArmRegisterClass)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ArmRegisterClass::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// ArmSignForExpressionUnparsing is defined at src/backend/asmUnparser/AsmUnparser_compat.h:39
/** Converts an enum of type ArmSignForExpressionUnparsing to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyArmSignForExpressionUnparsing(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "arm_sign_none"; break;
        case 1: retval = "arm_sign_plus"; break;
        case 2: retval = "arm_sign_minus"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(ArmSignForExpressionUnparsing)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ArmSignForExpressionUnparsing::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// Assembler::EncodingType is defined at src/frontend/Disassemblers/Assembler.h:73
/** Converts an enum of type Assembler::EncodingType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAssemblerEncodingType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ET_SHORTEST"; break;
        case 1: retval = "ET_LONGEST"; break;
        case 2: retval = "ET_MATCHES"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(Assembler::EncodingType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Assembler::EncodingType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// AssemblerX86::MemoryReferencePattern is defined at src/frontend/Disassemblers/AssemblerX86.h:383
/** Converts an enum of type AssemblerX86::MemoryReferencePattern to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAssemblerX86MemoryReferencePattern(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "mrp_unknown"; break;
        case 1: retval = "mrp_disp"; break;
        case 2: retval = "mrp_index"; break;
        case 3: retval = "mrp_index_disp"; break;
        case 4: retval = "mrp_base"; break;
        case 5: retval = "mrp_base_disp"; break;
        case 6: retval = "mrp_base_index"; break;
        case 7: retval = "mrp_base_index_disp"; break;
    }
    if (retval.empty()) {
        char buf[100];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(AssemblerX86::MemoryReferencePattern)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AssemblerX86::MemoryReferencePattern::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// AssemblerX86::OperandDefn is defined at src/frontend/Disassemblers/AssemblerX86.h:142
/** Converts an enum of type AssemblerX86::OperandDefn to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAssemblerX86OperandDefn(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "od_none"; break;
        case 1: retval = "od_AL"; break;
        case 2: retval = "od_AX"; break;
        case 3: retval = "od_EAX"; break;
        case 4: retval = "od_RAX"; break;
        case 5: retval = "od_DX"; break;
        case 6: retval = "od_CS"; break;
        case 7: retval = "od_DS"; break;
        case 8: retval = "od_ES"; break;
        case 9: retval = "od_FS"; break;
        case 10: retval = "od_GS"; break;
        case 11: retval = "od_SS"; break;
        case 12: retval = "od_rel8"; break;
        case 13: retval = "od_rel16"; break;
        case 14: retval = "od_rel32"; break;
        case 15: retval = "od_rel64"; break;
        case 16: retval = "od_ptr16_16"; break;
        case 17: retval = "od_ptr16_32"; break;
        case 18: retval = "od_ptr16_64"; break;
        case 19: retval = "od_r8"; break;
        case 20: retval = "od_r16"; break;
        case 21: retval = "od_r32"; break;
        case 22: retval = "od_r64"; break;
        case 23: retval = "od_imm8"; break;
        case 24: retval = "od_imm16"; break;
        case 25: retval = "od_imm32"; break;
        case 26: retval = "od_imm64"; break;
        case 27: retval = "od_r_m8"; break;
        case 28: retval = "od_r_m16"; break;
        case 29: retval = "od_r_m32"; break;
        case 30: retval = "od_r_m64"; break;
        case 31: retval = "od_m"; break;
        case 32: retval = "od_m8"; break;
        case 33: retval = "od_m16"; break;
        case 34: retval = "od_m32"; break;
        case 35: retval = "od_m64"; break;
        case 36: retval = "od_m128"; break;
        case 37: retval = "od_m16_16"; break;
        case 38: retval = "od_m16_32"; break;
        case 39: retval = "od_m16_64"; break;
        case 40: retval = "od_m16a16"; break;
        case 41: retval = "od_m16a32"; break;
        case 42: retval = "od_m32a32"; break;
        case 43: retval = "od_m16a64"; break;
        case 44: retval = "od_moffs8"; break;
        case 45: retval = "od_moffs16"; break;
        case 46: retval = "od_moffs32"; break;
        case 47: retval = "od_moffs64"; break;
        case 48: retval = "od_sreg"; break;
        case 49: retval = "od_m32fp"; break;
        case 50: retval = "od_m64fp"; break;
        case 51: retval = "od_m80fp"; break;
        case 52: retval = "od_st0"; break;
        case 53: retval = "od_st1"; break;
        case 54: retval = "od_st2"; break;
        case 55: retval = "od_st3"; break;
        case 56: retval = "od_st4"; break;
        case 57: retval = "od_st5"; break;
        case 58: retval = "od_st6"; break;
        case 59: retval = "od_st7"; break;
        case 60: retval = "od_sti"; break;
        case 61: retval = "od_mm"; break;
        case 62: retval = "od_mm_m32"; break;
        case 63: retval = "od_mm_m64"; break;
        case 64: retval = "od_xmm"; break;
        case 65: retval = "od_xmm_m16"; break;
        case 66: retval = "od_xmm_m32"; break;
        case 67: retval = "od_xmm_m64"; break;
        case 68: retval = "od_xmm_m128"; break;
        case 69: retval = "od_XMM0"; break;
        case 70: retval = "od_0"; break;
        case 71: retval = "od_1"; break;
        case 72: retval = "od_m80"; break;
        case 73: retval = "od_dec"; break;
        case 74: retval = "od_m80bcd"; break;
        case 75: retval = "od_m2byte"; break;
        case 76: retval = "od_m14_28byte"; break;
        case 77: retval = "od_m94_108byte"; break;
        case 78: retval = "od_m512byte"; break;
        case 79: retval = "od_r16_m16"; break;
        case 80: retval = "od_r32_m8"; break;
        case 81: retval = "od_r32_m16"; break;
        case 82: retval = "od_r64_m16"; break;
        case 83: retval = "od_CR0"; break;
        case 84: retval = "od_CR7"; break;
        case 85: retval = "od_CR8"; break;
        case 86: retval = "od_CR0CR7"; break;
        case 87: retval = "od_DR0DR7"; break;
        case 88: retval = "od_reg"; break;
        case 89: retval = "od_CL"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(AssemblerX86::OperandDefn)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AssemblerX86::OperandDefn::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// AstAttributeDOT::DOTStyles is defined at src/frontend/SageIII/astVisualization/AstAttributeDOT.h:22
/** Converts an enum of type AstAttributeDOT::DOTStyles to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAstAttributeDOT_DOTStyles(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementDOTStyles"; break;
        case 1: retval = "filled"; break;
        case 2: retval = "not_filled"; break;
        case 3: retval = "END_OF_NODE_TYPE_LIST_DOTStyles"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(AstAttributeDOT::DOTStyles)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AstAttributeDOT::DOTStyles::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// AstDisplayInfo::NodeType is defined at src/roseExtensions/qtWidgets/util/AstDisplayInfo.h:15
/** Converts an enum of type AstDisplayInfo::NodeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAstDisplayInfoNodeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ROOT"; break;
        case 1: retval = "INCLUDE_ROOT"; break;
        case 2: retval = "SRC_FILE"; break;
        case 3: retval = "INCLUDE_FILE"; break;
        case 4: retval = "NAMESPACE"; break;
        case 5: retval = "CLASS"; break;
        case 6: retval = "FUNCTION"; break;
        case 7: retval = "LOOP"; break;
        case 8: retval = "UNKNOWN"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(AstDisplayInfo::NodeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AstDisplayInfo::NodeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// AstQueryNamespace::QueryDepth is defined at src/midend/astQuery/astQuery.h:97
/** Converts an enum of type AstQueryNamespace::QueryDepth to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAstQueryNamespaceQueryDepth(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementTypeQueryDepth"; break;
        case 1: retval = "ChildrenOnly"; break;
        case 2: retval = "AllNodes"; break;
        case 3: retval = "ExtractTypes"; break;
        case 4: retval = "END_OF_NODE_TYPE_LIST_QUERY_DEPTH"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(AstQueryNamespace::QueryDepth)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AstQueryNamespace::QueryDepth::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// AstUnparseAttribute::RelativePositionType is defined at src/backend/unparser/astUnparseAttribute.h:34
/** Converts an enum of type AstUnparseAttribute::RelativePositionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAstUnparseAttributeRelativePositionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_defaultValue"; break;
        case 1: retval = "e_undef"; break;
        case 2: retval = "e_before"; break;
        case 3: retval = "e_after"; break;
        case 4: retval = "e_inside"; break;
        case 5: retval = "e_replace"; break;
        case 6: retval = "e_before_syntax"; break;
        case 7: retval = "e_after_syntax"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(AstUnparseAttribute::RelativePositionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AstUnparseAttribute::RelativePositionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// BaseGraph::BiDirNodesIterator::dirType is defined at src/midend/programAnalysis/OpenAnalysis/Utils/BaseGraph.h:261
/** Converts an enum of type BaseGraph::BiDirNodesIterator::dirType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBaseGraphBiDirNodesIterator_dirType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Forward"; break;
        case 1: retval = "Reverse"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(BaseGraph::BiDirNodesIterator::dirType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BaseGraph::BiDirNodesIterator::dirType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// BinaryLoader::ConflictResolution is defined at src/frontend/BinaryLoader/BinaryLoader.h:59
/** Converts an enum of type BinaryLoader::ConflictResolution to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryLoaderConflictResolution(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "RESOLVE_THROW"; break;
        case 1: retval = "RESOLVE_OVERMAP"; break;
        case 2: retval = "RESOLVE_REMAP"; break;
        case 3: retval = "RESOLVE_REMAP_ABOVE"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(BinaryLoader::ConflictResolution)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryLoader::ConflictResolution::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// BinaryLoader::MappingContribution is defined at src/frontend/BinaryLoader/BinaryLoader.h:51
/** Converts an enum of type BinaryLoader::MappingContribution to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryLoaderMappingContribution(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "CONTRIBUTE_NONE"; break;
        case 1: retval = "CONTRIBUTE_ADD"; break;
        case 2: retval = "CONTRIBUTE_SUB"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(BinaryLoader::MappingContribution)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryLoader::MappingContribution::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// BooleanQuery::TypeOfQueryType is defined at src/midend/astQuery/booleanQuery.h:44
/** Converts an enum of type BooleanQuery::TypeOfQueryType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBooleanQueryTypeOfQueryType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementType"; break;
        case 1: retval = "VariableDeclaration"; break;
        case 2: retval = "Type"; break;
        case 3: retval = "FunctionDeclaration"; break;
        case 4: retval = "MemberFunctionDeclaration"; break;
        case 5: retval = "ClassDeclaration"; break;
        case 6: retval = "Argument"; break;
        case 7: retval = "Field"; break;
        case 8: retval = "UnionedField"; break;
        case 9: retval = "Struct"; break;
        case 10: retval = "ContainedInSubtreeOfType"; break;
        case 11: retval = "END_OF_BOOLEAN_QUERY_TYPE"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(BooleanQuery::TypeOfQueryType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BooleanQuery::TypeOfQueryType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// BuildAccess_EnumX is defined at src/ROSETTA/src/ROSETTA_macros.h:38
/** Converts an enum of type BuildAccess_EnumX to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBuildAccess_EnumX(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "TAG_NO_ACCESS_FUNCTIONS"; break;
        case 1: retval = "TAG_BUILD_ACCESS_FUNCTIONS"; break;
        case 2: retval = "TAG_BUILD_FLAG_ACCESS_FUNCTIONS"; break;
        case 3: retval = "TAG_BUILD_LIST_ACCESS_FUNCTIONS"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(BuildAccess_EnumX)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BuildAccess_EnumX::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// CFG::EdgeType is defined at src/midend/programAnalysis/OpenAnalysis/CFG/CFG.h:84
/** Converts an enum of type CFG::EdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCFG_EdgeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "TRUE_EDGE"; break;
        case 1: retval = "FALLTHROUGH_EDGE"; break;
        case 2: retval = "FALSE_EDGE"; break;
        case 3: retval = "BACK_EDGE"; break;
        case 4: retval = "MULTIWAY_EDGE"; break;
        case 5: retval = "BREAK_EDGE"; break;
        case 6: retval = "CONTINUE_EDGE"; break;
        case 7: retval = "RETURN_EDGE"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(CFG::EdgeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "CFG::EdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// CallGraph::EdgeType is defined at src/midend/programAnalysis/OpenAnalysis/CallGraph/CallGraph.h:73
/** Converts an enum of type CallGraph::EdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCallGraphEdgeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NORMAL_EDGE"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(CallGraph::EdgeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "CallGraph::EdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// ClassHierarchyWrapper::EdgeDirection is defined at src/midend/programAnalysis/CallGraphAnalysis/ClassHierarchyGraph.h:15
/** Converts an enum of type ClassHierarchyWrapper::EdgeDirection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyClassHierarchyWrapperEdgeDirection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "EdgeOut"; break;
        case 1: retval = "EdgeIn"; break;
    }
    if (retval.empty()) {
        char buf[100];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(ClassHierarchyWrapper::EdgeDirection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ClassHierarchyWrapper::EdgeDirection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// Compare_Rel is defined at src/midend/astUtil/symbolicVal/SymbolicVal.h:313
/** Converts an enum of type Compare_Rel to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCompare_Rel(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "REL_NONE"; break;
        case 1: retval = "REL_EQ"; break;
        case 2: retval = "REL_LT"; break;
        case 3: retval = "REL_LE"; break;
        case 4: retval = "REL_GT"; break;
        case 5: retval = "REL_GE"; break;
        case 6: retval = "REL_NE"; break;
        case 8: retval = "REL_UNKNOWN"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(Compare_Rel)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Compare_Rel::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// CompilerOutputWidget::PatternType is defined at src/roseExtensions/qtWidgets/TaskSystem/CompilerOutputWidget.h:25
/** Converts an enum of type CompilerOutputWidget::PatternType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCompilerOutputWidgetPatternType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Unknown"; break;
        case 1: retval = "Warning"; break;
        case 2: retval = "Error"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(CompilerOutputWidget::PatternType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "CompilerOutputWidget::PatternType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// ConstructParam_EnumX is defined at src/ROSETTA/src/ROSETTA_macros.h:23
/** Converts an enum of type ConstructParam_EnumX to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyConstructParam_EnumX(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "TAG_NO_CONSTRUCTOR_PARAMETER"; break;
        case 1: retval = "TAG_CONSTRUCTOR_PARAMETER"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(ConstructParam_EnumX)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ConstructParam_EnumX::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// CopyConfig_EnumX is defined at src/ROSETTA/src/ROSETTA_macros.h:55
/** Converts an enum of type CopyConfig_EnumX to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCopyConfig_EnumX(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "TAG_NO_COPY_DATA"; break;
        case 1: retval = "TAG_COPY_DATA"; break;
        case 2: retval = "TAG_CLONE_PTR"; break;
        case 3: retval = "TAG_CLONE_TREE"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(CopyConfig_EnumX)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "CopyConfig_EnumX::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// Cxx_GrammarVariants is defined at frontend/SageIII/Cxx_Grammar.h:18
/** Converts an enum of type Cxx_GrammarVariants to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCxx_GrammarVariants(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "AccessModifierTag"; break;
        case 2: retval = "ACTUAL_ARGUMENT_EXPRESSION"; break;
        case 3: retval = "ADD_OP"; break;
        case 4: retval = "ADDRESS_OP"; break;
        case 5: retval = "AGGREGATE_INIT"; break;
        case 6: retval = "ALIAS_SYMBOL"; break;
        case 7: retval = "TEMP_Allocate_Statement"; break;
        case 8: retval = "AND_ASSIGN_OP"; break;
        case 9: retval = "AND_OP"; break;
        case 10: retval = "TEMP_Arithmetic_If_Statement"; break;
        case 11: retval = "T_ARRAY"; break;
        case 12: retval = "POINTST_OP"; break;
        case 13: retval = "ARROWSTAR_OP"; break;
        case 14: retval = "AsmArmInstructionTag"; break;
        case 15: retval = "AsmArmRegisterReferenceExpressionTag"; break;
        case 16: retval = "AsmBasicStringTag"; break;
        case 17: retval = "AsmBinaryAddTag"; break;
        case 18: retval = "AsmBinaryAddPostupdateTag"; break;
        case 19: retval = "AsmBinaryAddPreupdateTag"; break;
        case 20: retval = "AsmBinaryAsrTag"; break;
        case 21: retval = "AsmBinaryDivideTag"; break;
        case 22: retval = "AsmBinaryExpressionTag"; break;
        case 23: retval = "AsmBinaryLslTag"; break;
        case 24: retval = "AsmBinaryLsrTag"; break;
        case 25: retval = "AsmBinaryModTag"; break;
        case 26: retval = "AsmBinaryMultiplyTag"; break;
        case 27: retval = "AsmBinaryRorTag"; break;
        case 28: retval = "AsmBinarySubtractTag"; break;
        case 29: retval = "AsmBinarySubtractPostupdateTag"; break;
        case 30: retval = "AsmBinarySubtractPreupdateTag"; break;
        case 31: retval = "AsmBlockTag"; break;
        case 32: retval = "AsmByteValueExpressionTag"; break;
        case 33: retval = "AsmCoffStrtabTag"; break;
        case 34: retval = "AsmCoffSymbolTag"; break;
        case 35: retval = "AsmCoffSymbolListTag"; break;
        case 36: retval = "AsmCoffSymbolTableTag"; break;
        case 37: retval = "AsmCommonSubExpressionTag"; break;
        case 38: retval = "AsmControlFlagsExpressionTag"; break;
        case 39: retval = "AsmDOSExtendedHeaderTag"; break;
        case 40: retval = "AsmDOSFileHeaderTag"; break;
        case 41: retval = "AsmDataStructureDeclarationTag"; break;
        case 42: retval = "AsmDeclarationTag"; break;
        case 43: retval = "AsmDoubleFloatValueExpressionTag"; break;
        case 44: retval = "AsmDoubleWordValueExpressionTag"; break;
        case 45: retval = "AsmDwarfAccessDeclarationTag"; break;
        case 46: retval = "AsmDwarfArrayTypeTag"; break;
        case 47: retval = "AsmDwarfBaseTypeTag"; break;
        case 48: retval = "AsmDwarfCatchBlockTag"; break;
        case 49: retval = "AsmDwarfClassTemplateTag"; break;
        case 50: retval = "AsmDwarfClassTypeTag"; break;
        case 51: retval = "AsmDwarfCommonBlockTag"; break;
        case 52: retval = "AsmDwarfCommonInclusionTag"; break;
        case 53: retval = "AsmDwarfCompilationUnitTag"; break;
        case 54: retval = "AsmDwarfCompilationUnitListTag"; break;
        case 55: retval = "AsmDwarfConditionTag"; break;
        case 56: retval = "AsmDwarfConstTypeTag"; break;
        case 57: retval = "AsmDwarfConstantTag"; break;
        case 58: retval = "AsmDwarfConstructTag"; break;
        case 59: retval = "AsmDwarfConstructListTag"; break;
        case 60: retval = "AsmDwarfDwarfProcedureTag"; break;
        case 61: retval = "AsmDwarfEntryPointTag"; break;
        case 62: retval = "AsmDwarfEnumerationTypeTag"; break;
        case 63: retval = "AsmDwarfEnumeratorTag"; break;
        case 64: retval = "AsmDwarfFileTypeTag"; break;
        case 65: retval = "AsmDwarfFormalParameterTag"; break;
        case 66: retval = "AsmDwarfFormatLabelTag"; break;
        case 67: retval = "AsmDwarfFriendTag"; break;
        case 68: retval = "AsmDwarfFunctionTemplateTag"; break;
        case 69: retval = "AsmDwarfImportedDeclarationTag"; break;
        case 70: retval = "AsmDwarfImportedModuleTag"; break;
        case 71: retval = "AsmDwarfImportedUnitTag"; break;
        case 72: retval = "AsmDwarfInformationTag"; break;
        case 73: retval = "AsmDwarfInheritanceTag"; break;
        case 74: retval = "AsmDwarfInlinedSubroutineTag"; break;
        case 75: retval = "AsmDwarfInterfaceTypeTag"; break;
        case 76: retval = "AsmDwarfLabelTag"; break;
        case 77: retval = "AsmDwarfLexicalBlockTag"; break;
        case 78: retval = "AsmDwarfLineTag"; break;
        case 79: retval = "AsmDwarfLineListTag"; break;
        case 80: retval = "AsmDwarfMacroTag"; break;
        case 81: retval = "AsmDwarfMacroListTag"; break;
        case 82: retval = "AsmDwarfMemberTag"; break;
        case 83: retval = "AsmDwarfModuleTag"; break;
        case 84: retval = "AsmDwarfMutableTypeTag"; break;
        case 85: retval = "AsmDwarfNamelistTag"; break;
        case 86: retval = "AsmDwarfNamelistItemTag"; break;
        case 87: retval = "AsmDwarfNamespaceTag"; break;
        case 88: retval = "AsmDwarfPackedTypeTag"; break;
        case 89: retval = "AsmDwarfPartialUnitTag"; break;
        case 90: retval = "AsmDwarfPointerTypeTag"; break;
        case 91: retval = "AsmDwarfPtrToMemberTypeTag"; break;
        case 92: retval = "AsmDwarfReferenceTypeTag"; break;
        case 93: retval = "AsmDwarfRestrictTypeTag"; break;
        case 94: retval = "AsmDwarfSetTypeTag"; break;
        case 95: retval = "AsmDwarfSharedTypeTag"; break;
        case 96: retval = "AsmDwarfStringTypeTag"; break;
        case 97: retval = "AsmDwarfStructureTypeTag"; break;
        case 98: retval = "AsmDwarfSubprogramTag"; break;
        case 99: retval = "AsmDwarfSubrangeTypeTag"; break;
        case 100: retval = "AsmDwarfSubroutineTypeTag"; break;
        case 101: retval = "AsmDwarfTemplateTypeParameterTag"; break;
        case 102: retval = "AsmDwarfTemplateValueParameterTag"; break;
        case 103: retval = "AsmDwarfThrownTypeTag"; break;
        case 104: retval = "AsmDwarfTryBlockTag"; break;
        case 105: retval = "AsmDwarfTypedefTag"; break;
        case 106: retval = "AsmDwarfUnionTypeTag"; break;
        case 107: retval = "AsmDwarfUnknownConstructTag"; break;
        case 108: retval = "AsmDwarfUnspecifiedParametersTag"; break;
        case 109: retval = "AsmDwarfUnspecifiedTypeTag"; break;
        case 110: retval = "AsmDwarfUpcRelaxedTypeTag"; break;
        case 111: retval = "AsmDwarfUpcSharedTypeTag"; break;
        case 112: retval = "AsmDwarfUpcStrictTypeTag"; break;
        case 113: retval = "AsmDwarfVariableTag"; break;
        case 114: retval = "AsmDwarfVariantTag"; break;
        case 115: retval = "AsmDwarfVariantPartTag"; break;
        case 116: retval = "AsmDwarfVolatileTypeTag"; break;
        case 117: retval = "AsmDwarfWithStmtTag"; break;
        case 118: retval = "AsmElfDynamicEntryTag"; break;
        case 119: retval = "AsmElfDynamicEntryListTag"; break;
        case 120: retval = "AsmElfDynamicSectionTag"; break;
        case 121: retval = "AsmElfEHFrameEntryCITag"; break;
        case 122: retval = "AsmElfEHFrameEntryCIListTag"; break;
        case 123: retval = "AsmElfEHFrameEntryFDTag"; break;
        case 124: retval = "AsmElfEHFrameEntryFDListTag"; break;
        case 125: retval = "AsmElfEHFrameSection"; break;
        case 126: retval = "AsmElfFileHeaderTag"; break;
        case 127: retval = "AsmElfNoteEntryTag"; break;
        case 128: retval = "AsmElfNoteEntryListTag"; break;
        case 129: retval = "AsmElfNoteSection"; break;
        case 130: retval = "AsmElfRelocEntryTag"; break;
        case 131: retval = "AsmElfRelocEntryListTag"; break;
        case 132: retval = "AsmElfRelocSectionTag"; break;
        case 133: retval = "AsmElfSectionTag"; break;
        case 134: retval = "AsmElfSectionTableTag"; break;
        case 135: retval = "AsmElfSectionTableEntryTag"; break;
        case 136: retval = "AsmElfSegmentTableTag"; break;
        case 137: retval = "AsmElfSegmentTableEntryTag"; break;
        case 138: retval = "AsmElfSegmentTableEntryListTag"; break;
        case 139: retval = "AsmElfStringSectionTag"; break;
        case 140: retval = "AsmElfStrtabTag"; break;
        case 141: retval = "AsmElfSymbolTag"; break;
        case 142: retval = "AsmElfSymbolListTag"; break;
        case 143: retval = "AsmElfSymbolSectionTag"; break;
        case 144: retval = "AsmElfSymverDefinedAuxTag"; break;
        case 145: retval = "AsmElfSymverDefinedAuxListTag"; break;
        case 146: retval = "AsmElfSymverDefinedEntryTag"; break;
        case 147: retval = "AsmElfSymverDefinedEntryListTag"; break;
        case 148: retval = "AsmElfSymverDefinedSection"; break;
        case 149: retval = "AsmElfSymverEntryTag"; break;
        case 150: retval = "AsmElfSymverEntryListTag"; break;
        case 151: retval = "AsmElfSymverNeededAuxTag"; break;
        case 152: retval = "AsmElfSymverNeededAuxListTag"; break;
        case 153: retval = "AsmElfSymverNeededEntryTag"; break;
        case 154: retval = "AsmElfSymverNeededEntryListTag"; break;
        case 155: retval = "AsmElfSymverNeededSection"; break;
        case 156: retval = "AsmElfSymverSection"; break;
        case 157: retval = "AsmExecutableFileFormatTag"; break;
        case 158: retval = "AsmExprListExpTag"; break;
        case 159: retval = "AsmExpressionTag"; break;
        case 160: retval = "AsmFieldDeclarationTag"; break;
        case 161: retval = "AsmFunctionDeclarationTag"; break;
        case 163: retval = "AsmGenericDLLTag"; break;
        case 164: retval = "AsmGenericDLLListTag"; break;
        case 165: retval = "AsmGenericFileTag"; break;
        case 166: retval = "AsmGenericFileListTag"; break;
        case 167: retval = "AsmGenericFormatTag"; break;
        case 168: retval = "AsmGenericHeaderTag"; break;
        case 169: retval = "AsmGenericHeaderListTag"; break;
        case 170: retval = "AsmGenericSectionTag"; break;
        case 171: retval = "AsmGenericSectionListTag"; break;
        case 172: retval = "AsmGenericStringTag"; break;
        case 173: retval = "AsmGenericStrtabTag"; break;
        case 174: retval = "AsmGenericSymbolTag"; break;
        case 175: retval = "AsmGenericSymbolListTag"; break;
        case 176: retval = "AsmInstructionTag"; break;
        case 177: retval = "AsmInterpretationTag"; break;
        case 178: retval = "AsmInterpretationListTag"; break;
        case 179: retval = "AsmLEEntryPointTag"; break;
        case 180: retval = "AsmLEEntryTableTag"; break;
        case 181: retval = "AsmLEFileHeaderTag"; break;
        case 182: retval = "AsmLENameTableTag"; break;
        case 183: retval = "AsmLEPageTableTag"; break;
        case 184: retval = "AsmLEPageTableEntryTag"; break;
        case 185: retval = "AsmLERelocTableTag"; break;
        case 186: retval = "AsmLESectionTag"; break;
        case 187: retval = "AsmLESectionTableTag"; break;
        case 188: retval = "AsmLESectionTableEntryTag"; break;
        case 189: retval = "AsmMemoryReferenceExpressionTag"; break;
        case 190: retval = "AsmNEEntryPointTag"; break;
        case 191: retval = "AsmNEEntryTableTag"; break;
        case 192: retval = "AsmNEFileHeaderTag"; break;
        case 193: retval = "AsmNEModuleTableTag"; break;
        case 194: retval = "AsmNENameTableTag"; break;
        case 196: retval = "AsmNERelocEntryTag"; break;
        case 197: retval = "AsmNERelocTableTag"; break;
        case 198: retval = "AsmNESectionTag"; break;
        case 199: retval = "AsmNESectionTableTag"; break;
        case 200: retval = "AsmNESectionTableEntryTag"; break;
        case 201: retval = "AsmNEStringTableTag"; break;
        case 202: retval = "AsmNodeTag"; break;
        case 203: retval = "ASM_OP"; break;
        case 204: retval = "AsmOperandListTag"; break;
        case 205: retval = "AsmPEExportDirectoryTag"; break;
        case 206: retval = "AsmPEExportEntryTag"; break;
        case 207: retval = "AsmPEExportEntryListTag"; break;
        case 208: retval = "AsmPEExportSectionTag"; break;
        case 209: retval = "AsmPEFileHeaderTag"; break;
        case 210: retval = "AsmPEImportDirectoryTag"; break;
        case 211: retval = "AsmPEImportDirectoryListTag"; break;
        case 212: retval = "AsmPEImportHNTEntryTag"; break;
        case 213: retval = "AsmPEImportHNTEntryListTag"; break;
        case 214: retval = "AsmPEImportILTEntryTag"; break;
        case 215: retval = "AsmPEImportILTEntryListTag"; break;
        case 216: retval = "AsmPEImportLookupTableTag"; break;
        case 217: retval = "AsmPEImportSectionTag"; break;
        case 218: retval = "AsmPERVASizePairTag"; break;
        case 219: retval = "AsmPERVASizePairListTag"; break;
        case 220: retval = "AsmPESectionTag"; break;
        case 221: retval = "AsmPESectionTableTag"; break;
        case 222: retval = "AsmPESectionTableEntryTag"; break;
        case 223: retval = "AsmPEStringSectionTag"; break;
        case 224: retval = "AsmPowerpcInstructionTag"; break;
        case 225: retval = "AsmPowerpcRegisterReferenceExpressionTag"; break;
        case 228: retval = "AsmQuadWordValueExpressionTag"; break;
        case 229: retval = "AsmRegisterReferenceExpressionTag"; break;
        case 232: retval = "AsmSingleFloatValueExpressionTag"; break;
        case 233: retval = "AsmStatementTag"; break;
        case 234: retval = "ASM_STMT"; break;
        case 235: retval = "AsmStoredStringTag"; break;
        case 236: retval = "AsmStringStorageTag"; break;
        case 237: retval = "AsmTypeTag"; break;
        case 238: retval = "AsmType128bitFloatTag"; break;
        case 239: retval = "AsmType80bitFloatTag"; break;
        case 240: retval = "AsmTypeByteTag"; break;
        case 241: retval = "AsmTypeDoubleFloatTag"; break;
        case 242: retval = "AsmTypeDoubleQuadWordTag"; break;
        case 243: retval = "AsmTypeDoubleWordTag"; break;
        case 244: retval = "AsmTypeQuadWordTag"; break;
        case 245: retval = "AsmTypeSingleFloatTag"; break;
        case 246: retval = "AsmTypeVectorTag"; break;
        case 247: retval = "AsmTypeWordTag"; break;
        case 248: retval = "AsmUnaryArmSpecialRegisterListTag"; break;
        case 249: retval = "AsmUnaryExpressionTag"; break;
        case 250: retval = "AsmUnaryMinusTag"; break;
        case 251: retval = "AsmUnaryPlusTag"; break;
        case 252: retval = "AsmUnaryRrxTag"; break;
        case 253: retval = "AsmValueExpressionTag"; break;
        case 254: retval = "AsmVectorValueExpressionTag"; break;
        case 255: retval = "AsmWordValueExpressionTag"; break;
        case 256: retval = "Asmx86InstructionTag"; break;
        case 257: retval = "Asmx86RegisterReferenceExpressionTag"; break;
        case 258: retval = "BINARY_ADDRESS_SYMBOL"; break;
        case 259: retval = "BINARY_DATA_SYMBOL"; break;
        case 260: retval = "ASSIGN_INIT"; break;
        case 261: retval = "ASSIGN_OP"; break;
        case 262: retval = "TEMP_Assign_Statement"; break;
        case 263: retval = "TEMP_Assigned_Goto_Statement"; break;
        case 264: retval = "TEMP_Associate_Statement"; break;
        case 265: retval = "TEMP_AsteriskShapeExp"; break;
        case 266: retval = "AttributeTag"; break;
        case 267: retval = "TEMP_Attribute_Specification_Statement"; break;
        case 268: retval = "BACKSPACE_STATEMENT"; break;
        case 269: retval = "BaseClassTag"; break;
        case 270: retval = "BaseClassModifierTag"; break;
        case 271: retval = "BASIC_BLOCK_STMT"; break;
        case 272: retval = "BidirectionalGraphTag"; break;
        case 273: retval = "BinaryCompositeTag"; break;
        case 274: retval = "BINARY_EXPRESSION"; break;
        case 275: retval = "BITAND_OP"; break;
        case 276: retval = "BitAttributeTag"; break;
        case 277: retval = "BIT_COMPLEMENT_OP"; break;
        case 278: retval = "BITOR_OP"; break;
        case 279: retval = "BITXOR_OP"; break;
        case 280: retval = "TEMP_Block_Data_Statement"; break;
        case 281: retval = "BOOL_VAL"; break;
        case 282: retval = "BREAK_STMT"; break;
        case 283: retval = "CPP_DIRECTIVE_STMT"; break;
        case 284: retval = "CASE_STMT"; break;
        case 285: retval = "CAST_OP"; break;
        case 286: retval = "CATCH_STMT"; break;
        case 287: retval = "CATCH_STATEMENT_SEQ"; break;
        case 288: retval = "CHAR_VAL"; break;
        case 289: retval = "ClassDecl_attrTag"; break;
        case 290: retval = "CLASS_DECL_STMT"; break;
        case 291: retval = "CLASS_DEFN_STMT"; break;
        case 292: retval = "CLASSNAME_REF"; break;
        case 293: retval = "CLASS_NAME"; break;
        case 294: retval = "T_CLASS"; break;
        case 295: retval = "C_LINKAGE_DECLARATION_STMT"; break;
        case 296: retval = "C_LINKAGE_END_STMT"; break;
        case 297: retval = "C_LINKAGE_START_STMT"; break;
        case 298: retval = "CLOSE_STATEMENT"; break;
        case 299: retval = "TEMP_ColonShapeExp"; break;
        case 300: retval = "COMMA_OP"; break;
        case 301: retval = "COMMON_BLOCK"; break;
        case 302: retval = "TEMP_CommonBlockObject"; break;
        case 303: retval = "COMMON_SYMBOL"; break;
        case 304: retval = "COMPLEX_VAL"; break;
        case 305: retval = "TEMP_Computed_Goto_Statement"; break;
        case 306: retval = "CONCATENATION_OP"; break;
        case 307: retval = "EXPR_CONDITIONAL"; break;
        case 308: retval = "CONJUGATE_OP"; break;
        case 309: retval = "ConstVolatileModifierTag"; break;
        case 310: retval = "CONSTRUCTOR_INIT"; break;
        case 311: retval = "TEMP_Contains_Statement"; break;
        case 312: retval = "CONTINUE_STMT"; break;
        case 313: retval = "CTOR_INITIALIZER_LIST"; break;
        case 314: retval = "TEMP_DataStatementGroup"; break;
        case 315: retval = "TEMP_DataStatementObject"; break;
        case 316: retval = "TEMP_DataStatementValue"; break;
        case 317: retval = "DEAD_IF_DIRECTIVE_STMT"; break;
        case 318: retval = "TEMP_Deallocate_Statement"; break;
        case 319: retval = "DeclarationModifierTag"; break;
        case 320: retval = "DECL_STMT"; break;
        case 321: retval = "DEFAULT_STMT"; break;
        case 322: retval = "DEFAULT_NAME"; break;
        case 323: retval = "DEFINE_DIRECTIVE_STMT"; break;
        case 324: retval = "DELETE_OP"; break;
        case 325: retval = "TEMP_Derived_Type_Statement"; break;
        case 326: retval = "DESIGNATED_INITIALIZER"; break;
        case 327: retval = "TEMP_DimensionObject"; break;
        case 329: retval = "DirectedGraphEdgeTag"; break;
        case 331: retval = "DirectoryTag"; break;
        case 332: retval = "DirectoryListTag"; break;
        case 333: retval = "DIV_ASSIGN_OP"; break;
        case 334: retval = "DIV_OP"; break;
        case 335: retval = "DO_WHILE_STMT"; break;
        case 336: retval = "RECORD_REF"; break;
        case 337: retval = "DOTSTAR_OP"; break;
        case 338: retval = "DOUBLE_VAL"; break;
        case 339: retval = "ElaboratedTypeModifierTag"; break;
        case 340: retval = "ELSE_DIRECTIVE_STMT"; break;
        case 341: retval = "TEMP_Else_Where_Statement"; break;
        case 342: retval = "ELSEIF_DIRECTIVE_STMT"; break;
        case 343: retval = "EMPTY_DIRECTIVE_STMT"; break;
        case 344: retval = "ENDFILE_STATEMENT"; break;
        case 345: retval = "ENDIF_DIRECTIVE_STMT"; break;
        case 346: retval = "ENTRY_STMT"; break;
        case 347: retval = "ENUM_DECL_STMT"; break;
        case 348: retval = "FIELD_NAME"; break;
        case 349: retval = "ENUM_NAME"; break;
        case 350: retval = "T_ENUM"; break;
        case 351: retval = "ENUM_VAL"; break;
        case 352: retval = "EQ_OP"; break;
        case 353: retval = "TEMP_Equivalence_Statement"; break;
        case 354: retval = "ERROR_DIRECTIVE_STMT"; break;
        case 355: retval = "EXPONENTIATION_OP"; break;
        case 356: retval = "EXPR_LIST"; break;
        case 357: retval = "EXPR_STMT"; break;
        case 358: retval = "ExpressionTag"; break;
        case 359: retval = "EXPRESSION_ROOT"; break;
        case 360: retval = "FileTag"; break;
        case 361: retval = "FileListTag"; break;
        case 362: retval = "FLOAT_VAL"; break;
        case 363: retval = "FLUSH_STATEMENT"; break;
        case 364: retval = "FOR_ALL_STMT"; break;
        case 365: retval = "FOR_INIT_STMT"; break;
        case 366: retval = "FOR_STMT"; break;
        case 367: retval = "TEMP_FormatItem"; break;
        case 368: retval = "TEMP_FormatItemList"; break;
        case 369: retval = "FORMAT_STATEMENT"; break;
        case 370: retval = "FORTRAN_DO"; break;
        case 371: retval = "TEMP_Fortran_Include_Line"; break;
        case 372: retval = "FORTRAN_NONBLOCKED_DO"; break;
        case 373: retval = "FuncDecl_attrTag"; break;
        case 374: retval = "FUNC_CALL"; break;
        case 375: retval = "FUNC_DECL_STMT"; break;
        case 376: retval = "FUNC_DEFN_STMT"; break;
        case 377: retval = "FunctionModifierTag"; break;
        case 378: retval = "FUNCTION_PARAMETER_LIST"; break;
        case 379: retval = "T_FUNCTION_PARAMETER_TYPE_LIST"; break;
        case 380: retval = "FUNCTION_REF"; break;
        case 381: retval = "FUNCTION_NAME"; break;
        case 382: retval = "T_FUNCTION"; break;
        case 383: retval = "FUNCTYPE_NAME"; break;
        case 384: retval = "FUNC_TBL_STMT"; break;
        case 385: retval = "TYPE_TABLE"; break;
        case 386: retval = "GLOBAL_STMT"; break;
        case 387: retval = "GOTO_STMT"; break;
        case 388: retval = "GraphTag"; break;
        case 389: retval = "GraphEdgeTag"; break;
        case 390: retval = "GraphEdgeListTag"; break;
        case 391: retval = "GraphNodeTag"; break;
        case 392: retval = "GraphNodeListTag"; break;
        case 393: retval = "GE_OP"; break;
        case 394: retval = "GT_OP"; break;
        case 395: retval = "IO_ITEM_EXPR"; break;
        case 396: retval = "IO_STATEMENT"; break;
        case 397: retval = "IDENT_DIRECTIVE_STMT"; break;
        case 398: retval = "IF_DIRECTIVE_STMT"; break;
        case 399: retval = "IF_STMT"; break;
        case 400: retval = "IFDEF_DIRECTIVE_STMT"; break;
        case 401: retval = "IFNDEF_DIRECTIVE_STMT"; break;
        case 402: retval = "IMAG_PART_OP"; break;
        case 403: retval = "TEMP_Implicit_Statement"; break;
        case 404: retval = "IMPLIED_DO"; break;
        case 405: retval = "TEMP_Import_Statement"; break;
        case 406: retval = "IncidenceDirectedGraphTag"; break;
        case 407: retval = "IncidenceUndirectedGraphTag"; break;
        case 408: retval = "INCLUDE_DIRECTIVE_STMT"; break;
        case 409: retval = "INCLUDE_NEXT_DIRECTIVE_STMT"; break;
        case 410: retval = "InitializedNameTag"; break;
        case 411: retval = "EXPR_INIT"; break;
        case 412: retval = "INQUIRE_STATEMENT"; break;
        case 413: retval = "IntKeyedBidirectionalGraphTag"; break;
        case 414: retval = "INT_VAL"; break;
        case 415: retval = "INTEGER_DIV_OP"; break;
        case 416: retval = "TEMP_Interface_Body"; break;
        case 417: retval = "INTERFACE_STATEMENT"; break;
        case 418: retval = "INTERFACE_SYMBOL"; break;
        case 419: retval = "INTRINSIC_SYMBOL"; break;
        case 420: retval = "IOR_ASSIGN_OP"; break;
        case 421: retval = "EXEC_CONF"; break;
        case 422: retval = "KERN_CALL"; break;
        case 423: retval = "LABEL_REF"; break;
        case 424: retval = "LABEL_STMT"; break;
        case 425: retval = "LABEL_NAME"; break;
        case 426: retval = "LE_OP"; break;
        case 427: retval = "LT_OP"; break;
        case 428: retval = "LINE_DIRECTIVE_STMT"; break;
        case 429: retval = "LINEMARKER_DIRECTIVE_STMT"; break;
        case 430: retval = "LinkageModifierTag"; break;
        case 431: retval = "LocatedNodeTag"; break;
        case 432: retval = "LocatedNodeSupportTag"; break;
        case 433: retval = "LONG_DOUBLE_VAL"; break;
        case 434: retval = "LONG_INT_VAL"; break;
        case 435: retval = "LONG_LONG_INT_VAL"; break;
        case 436: retval = "LSHIFT_ASSIGN_OP"; break;
        case 437: retval = "LSHIFT_OP"; break;
        case 438: retval = "MFUNC_DECL_STMT"; break;
        case 439: retval = "MEMBER_FUNCTION_REF"; break;
        case 440: retval = "MEMBER_FUNC_NAME"; break;
        case 441: retval = "T_MEMBERFUNCTION"; break;
        case 442: retval = "MINUS_ASSIGN_OP"; break;
        case 443: retval = "MINUSMINUS_OP"; break;
        case 444: retval = "UNARY_MINUS_OP"; break;
        case 445: retval = "MOD_ASSIGN_OP"; break;
        case 446: retval = "MOD_OP"; break;
        case 447: retval = "ModifierTag"; break;
        case 448: retval = "ModifierNodesTag"; break;
        case 449: retval = "T_MODIFIER"; break;
        case 450: retval = "MODULE_STATEMENT"; break;
        case 451: retval = "MODULE_SYMBOL"; break;
        case 452: retval = "MULT_ASSIGN_OP"; break;
        case 453: retval = "MULT_OP"; break;
        case 454: retval = "NameTag"; break;
        case 455: retval = "TEMP_Name_Group"; break;
        case 456: retval = "T_NAME"; break;
        case 457: retval = "TEMP_Namelist_Statement"; break;
        case 458: retval = "NAMESPACE_ALIAS_DECLARATION_STMT"; break;
        case 459: retval = "NAMESPACE_DECLARATION_STMT"; break;
        case 460: retval = "NAMESPACE_DEFINITION_STMT"; break;
        case 461: retval = "NAMESPACE_NAME"; break;
        case 462: retval = "NEW_OP"; break;
        case 463: retval = "NodeTag"; break;
        case 464: retval = "NE_OP"; break;
        case 465: retval = "NOT_OP"; break;
        case 466: retval = "NULL_EXPR"; break;
        case 467: retval = "NULL_STMT"; break;
        case 468: retval = "TEMP_Nullify_Statement"; break;
        case 469: retval = "OMP_ATOMIC_STMT"; break;
        case 470: retval = "OMP_BARRIER_STMT"; break;
        case 471: retval = "OMP_CRITICAL_STMT"; break;
        case 472: retval = "OMP_CLAUSEBODY_STMT"; break;
        case 473: retval = "OMP_BODY_STMT"; break;
        case 474: retval = "OMP_DO_STMT"; break;
        case 475: retval = "OMP_FLUSH_STMT"; break;
        case 476: retval = "OMP_FOR_STMT"; break;
        case 477: retval = "OMP_MASTER_STMT"; break;
        case 478: retval = "OMP_ORDERED_STMT"; break;
        case 479: retval = "OMP_PARALLEL_STMT"; break;
        case 480: retval = "OMP_SECTION_STMT"; break;
        case 481: retval = "OMP_SECTIONS_STMT"; break;
        case 482: retval = "OMP_SINGLE_STMT"; break;
        case 483: retval = "OMP_TASK_STMT"; break;
        case 484: retval = "OMP_TASKWAIT_STMT"; break;
        case 485: retval = "OMP_THREADPRIVATE_STMT"; break;
        case 486: retval = "OMP_WORKSHARE_STMT"; break;
        case 487: retval = "OmpClauseTag"; break;
        case 488: retval = "OmpCollapseClauseTag"; break;
        case 489: retval = "OmpCopyinClauseTag"; break;
        case 490: retval = "OmpCopyprivateClauseTag"; break;
        case 491: retval = "OmpDefaultClauseTag"; break;
        case 492: retval = "OmpExpressionClauseTag"; break;
        case 493: retval = "OmpFirstprivateClauseTag"; break;
        case 494: retval = "OmpIfClauseTag"; break;
        case 495: retval = "OmpLastprivateClauseTag"; break;
        case 496: retval = "OmpNowaitClauseTag"; break;
        case 497: retval = "OmpNumThreadsClauseTag"; break;
        case 498: retval = "OmpOrderedClauseTag"; break;
        case 499: retval = "OmpPrivateClauseTag"; break;
        case 500: retval = "OmpReductionClauseTag"; break;
        case 501: retval = "OmpScheduleClauseTag"; break;
        case 502: retval = "OmpSharedClauseTag"; break;
        case 503: retval = "OmpUntiedClauseTag"; break;
        case 504: retval = "OmpVariablesClauseTag"; break;
        case 505: retval = "OPENCL_ACCESS_MODE"; break;
        case 506: retval = "OPEN_STATEMENT"; break;
        case 507: retval = "OptionsTag"; break;
        case 508: retval = "OR_OP"; break;
        case 509: retval = "PARAMETER_STATEMENT"; break;
        case 510: retval = "T_PARTIAL_FUNCTION_MODIFIER"; break;
        case 511: retval = "T_PARTIAL_FUNCTION"; break;
        case 512: retval = "PLUS_ASSIGN_OP"; break;
        case 513: retval = "PLUSPLUS_OP"; break;
        case 514: retval = "ARRAY_OP"; break;
        case 515: retval = "POINTER_ASSIGN_OP"; break;
        case 516: retval = "DEREF_OP"; break;
        case 517: retval = "T_MEMBER_POINTER"; break;
        case 518: retval = "T_POINTER"; break;
        case 519: retval = "PragmaTag"; break;
        case 520: retval = "PRAGMA_DECL"; break;
        case 521: retval = "PRINT_STATEMENT"; break;
        case 522: retval = "PROCEDURE_HEADER_STMT"; break;
        case 523: retval = "PROGRAM_HEADER_STMT"; break;
        case 524: retval = "ProjectTag"; break;
        case 525: retval = "PSEUDO_DESTRUCTOR_REF"; break;
        case 526: retval = "QualifiedNameTag"; break;
        case 527: retval = "T_QUALIFIED_NAME"; break;
        case 528: retval = "READ_STATEMENT"; break;
        case 529: retval = "REAL_PART_OP"; break;
        case 530: retval = "TYPE_REF"; break;
        case 531: retval = "T_REFERENCE"; break;
        case 532: retval = "TEMP_Rename_Pair"; break;
        case 533: retval = "RENAME_SYMBOL"; break;
        case 534: retval = "RETURN_STMT"; break;
        case 535: retval = "REWIND_STATEMENT"; break;
        case 536: retval = "RSHIFT_ASSIGN_OP"; break;
        case 537: retval = "RSHIFT_OP"; break;
        case 538: retval = "SCOPE_OP"; break;
        case 539: retval = "SCOPE_STMT"; break;
        case 540: retval = "TEMP_Sequence_Statement"; break;
        case 541: retval = "SHORT_VAL"; break;
        case 542: retval = "SIZEOF_OP"; break;
        case 543: retval = "SourceFileTag"; break;
        case 544: retval = "SPAWN_STMT"; break;
        case 545: retval = "SpecialFunctionModifierTag"; break;
        case 546: retval = "StatementTag"; break;
        case 547: retval = "STMT_EXPR"; break;
        case 548: retval = "TEMP_Statement_Function_Statement"; break;
        case 549: retval = "STOP_OR_PAUSE_STATEMENT"; break;
        case 550: retval = "StorageModifierTag"; break;
        case 551: retval = "StringKeyedBidirectionalGraphTag"; break;
        case 552: retval = "STRING_VAL"; break;
        case 553: retval = "SUBSCRIPT_EXPR"; break;
        case 554: retval = "SUBT_OP"; break;
        case 555: retval = "SupportTag"; break;
        case 556: retval = "SWITCH_STMT"; break;
        case 557: retval = "SymbolTag"; break;
        case 558: retval = "SymbolTableTag"; break;
        case 559: retval = "TemplateArgumentTag"; break;
        case 560: retval = "TemplateArgumentListTag"; break;
        case 561: retval = "TEMPLATE_DECL_STMT"; break;
        case 562: retval = "TEMPLATE_INST_DECL_STMT"; break;
        case 563: retval = "TEMPLATE_INST_DEFN_STMT"; break;
        case 564: retval = "TEMPLATE_INST_DIRECTIVE_STMT"; break;
        case 565: retval = "TEMPLATE_INST_FUNCTION_DECL_STMT"; break;
        case 566: retval = "TEMPLATE_INST_MEMBER_FUNCTION_DECL_STMT"; break;
        case 567: retval = "TemplateParameterTag"; break;
        case 568: retval = "TemplateParameterListTag"; break;
        case 569: retval = "TEMPLATE_NAME"; break;
        case 570: retval = "T_TEMPLATE"; break;
        case 571: retval = "THIS_NODE"; break;
        case 572: retval = "THROW_OP"; break;
        case 573: retval = "TOKEN"; break;
        case 574: retval = "TRY_STMT"; break;
        case 575: retval = "TypeTag"; break;
        case 576: retval = "T_BOOL"; break;
        case 577: retval = "T_CHAR"; break;
        case 578: retval = "T_COMPLEX"; break;
        case 579: retval = "T_DEFAULT"; break;
        case 580: retval = "T_LABLE"; break;
        case 581: retval = "T_DOUBLE"; break;
        case 582: retval = "T_ELLIPSE"; break;
        case 583: retval = "T_FLOAT"; break;
        case 584: retval = "T_GLOBAL_VOID"; break;
        case 585: retval = "TYPEID_OP"; break;
        case 586: retval = "T_IMAGINARY"; break;
        case 587: retval = "T_INT"; break;
        case 588: retval = "T_LONG"; break;
        case 589: retval = "T_LONG_DOUBLE"; break;
        case 590: retval = "T_LONG_LONG"; break;
        case 591: retval = "TypeModifierTag"; break;
        case 592: retval = "T_SHORT"; break;
        case 593: retval = "T_SIGNED_CHAR"; break;
        case 594: retval = "T_SIGNED_INT"; break;
        case 595: retval = "T_SIGNED_LONG"; break;
        case 596: retval = "T_SIGNED_LONG_LONG"; break;
        case 597: retval = "T_SIGNED_SHORT"; break;
        case 598: retval = "T_STRING"; break;
        case 599: retval = "T_UNKNOWN"; break;
        case 600: retval = "T_UNSIGNED_CHAR"; break;
        case 601: retval = "T_UNSIGNED_INT"; break;
        case 602: retval = "T_UNSIGNED_LONG"; break;
        case 603: retval = "T_UNSIGNED_LONG_LONG"; break;
        case 604: retval = "T_UNSIGNED_SHORT"; break;
        case 605: retval = "T_VOID"; break;
        case 606: retval = "T_WCHAR"; break;
        case 607: retval = "TYPEDEF_STMT"; break;
        case 608: retval = "T_TYPEDEF_SEQ"; break;
        case 609: retval = "TYPEDEF_NAME"; break;
        case 610: retval = "T_TYPEDEF"; break;
        case 611: retval = "UPC_AccessModifierTag"; break;
        case 612: retval = "UNARY_ADD_OP"; break;
        case 613: retval = "UNARY_EXPRESSION"; break;
        case 614: retval = "UNDEF_DIRECTIVE_STMT"; break;
        case 615: retval = "UndirectedGraphEdgeTag"; break;
        case 616: retval = "TEMP_UnknownArrayOrFunctionReference"; break;
        case 617: retval = "UnknownFileTag"; break;
        case 619: retval = "Unparse_InfoTag"; break;
        case 620: retval = "UNSIGNED_CHAR_VAL"; break;
        case 621: retval = "UNSIGNED_INT_VAL"; break;
        case 622: retval = "UNSIGNED_LONG_LONG_INT_VAL"; break;
        case 623: retval = "UNSIGNED_LONG_INT_VAL"; break;
        case 624: retval = "UNSIGNED_SHORT_VAL"; break;
        case 625: retval = "UPC_BARRIER_STMT"; break;
        case 626: retval = "UPC_BLOCK_SIZEOF_EXPR"; break;
        case 627: retval = "UPC_ELEM_SIZEOF_EXPR"; break;
        case 628: retval = "UPC_FENCE_STMT"; break;
        case 629: retval = "UPC_FORALL_STMT"; break;
        case 630: retval = "UPC_LOCAL_SIZEOF_EXPR"; break;
        case 631: retval = "UPC_MYTHREAD"; break;
        case 632: retval = "UPC_NOTIFY_STMT"; break;
        case 633: retval = "UPC_THREADS"; break;
        case 634: retval = "UPC_WAIT_STMT"; break;
        case 635: retval = "USE_STATEMENT"; break;
        case 636: retval = "USER_DEFINED_BINARY_OP"; break;
        case 637: retval = "USER_DEFINED_UNARY_OP"; break;
        case 638: retval = "USING_DECLARATION_STMT"; break;
        case 639: retval = "USING_DIRECTIVE_STMT"; break;
        case 640: retval = "ValueExpTag"; break;
        case 641: retval = "VA_COPY_OP"; break;
        case 642: retval = "VA_END_OP"; break;
        case 643: retval = "VA_OP"; break;
        case 644: retval = "VA_START_ONE_OPERAND_OP"; break;
        case 645: retval = "VA_START_OP"; break;
        case 646: retval = "VAR_REF"; break;
        case 647: retval = "VAR_DECL_STMT"; break;
        case 648: retval = "VAR_DEFN_STMT"; break;
        case 649: retval = "VARIABLE_NAME"; break;
        case 650: retval = "VARIANT_EXPR"; break;
        case 651: retval = "VARIANT_STMT"; break;
        case 652: retval = "WAIT_STATEMENT"; break;
        case 653: retval = "WARNING_DIRECTIVE_STMT"; break;
        case 654: retval = "WCHAR_VAL"; break;
        case 655: retval = "TEMP_Where_Statement"; break;
        case 656: retval = "WHILE_STMT"; break;
        case 657: retval = "WRITE_STATEMENT"; break;
        case 658: retval = "XOR_ASSIGN_OP"; break;
        case 659: retval = "_File_InfoTag"; break;
        case 660: retval = "T_CAFTEAM"; break;
        case 661: retval = "WITHTEAM_STMT"; break;
        case 662: retval = "COARRAY_REF_EXPR"; break;
        case 663: retval = "T_CRAY_POINTER"; break;
        case 665: retval = "Cxx_Grammar_UNKNOWN_GRAMMAR"; break;
        case 666: retval = "Cxx_Grammar_LAST_TAG"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(Cxx_GrammarVariants)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Cxx_GrammarVariants::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// DOTGraphEdge::DOTArrowTypes is defined at src/frontend/SageIII/astVisualization/AstAttributeDOT.h:134
/** Converts an enum of type DOTGraphEdge::DOTArrowTypes to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDOTGraphEdgeDOTArrowTypes(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementArrowTypes"; break;
        case 1: retval = "normal"; break;
        case 2: retval = "inv"; break;
        case 3: retval = "dot"; break;
        case 4: retval = "invdot"; break;
        case 5: retval = "odot"; break;
        case 6: retval = "invodot"; break;
        case 7: retval = "none"; break;
        case 8: retval = "tee"; break;
        case 9: retval = "empty"; break;
        case 10: retval = "invempty"; break;
        case 11: retval = "diamond"; break;
        case 12: retval = "odiamond"; break;
        case 13: retval = "ediamond"; break;
        case 14: retval = "crow"; break;
        case 15: retval = "box"; break;
        case 16: retval = "obox"; break;
        case 17: retval = "open"; break;
        case 18: retval = "halfopen"; break;
        case 19: retval = "vee"; break;
        case 20: retval = "END_OF_NODE_TYPE_LIST_DOTArrowTypes"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(DOTGraphEdge::DOTArrowTypes)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DOTGraphEdge::DOTArrowTypes::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// DOTGraphNode::DOTShapeTypes is defined at src/frontend/SageIII/astVisualization/AstAttributeDOT.h:87
/** Converts an enum of type DOTGraphNode::DOTShapeTypes to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDOTGraphNodeDOTShapeTypes(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementDOTShapeTypes"; break;
        case 1: retval = "polygon"; break;
        case 2: retval = "ellipse"; break;
        case 3: retval = "record"; break;
        case 4: retval = "mrecord"; break;
        case 5: retval = "END_OF_NODE_TYPE_LIST_DOTShapeTypes"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(DOTGraphNode::DOTShapeTypes)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DOTGraphNode::DOTShapeTypes::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// DataRequiredForComputationOfSourcePostionInformation::sourceDataEnum is defined at src/frontend/CxxFrontend/EDG/EDG_SAGE_Connection/sourcePositionComputation.h:84
/** Converts an enum of type DataRequiredForComputationOfSourcePostionInformation::sourceDataEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDataRequiredForComputationOfSourcePostionInformation_sourceDataEnum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_fileInfo"; break;
        case 2: retval = "e_expression"; break;
        case 3: retval = "e_statement"; break;
        case 4: retval = "e_type"; break;
        case 5: retval = "e_source_position"; break;
        case 6: retval = "e_source_range"; break;
        case 7: retval = "e_source_correspondence"; break;
        case 8: retval = "e_parameter"; break;
        case 9: retval = "e_constant"; break;
        case 10: retval = "e_source_sequence"; break;
        case 11: retval = "e_routine"; break;
        case 12: retval = "e_alt_expression"; break;
        case 13: retval = "e_template_argument"; break;
        case 14: retval = "e_variable"; break;
        case 15: retval = "e_secondary_declaration"; break;
        case 16: retval = "e_alt_source_position_data"; break;
        case 17: retval = "e_last"; break;
    }
    if (retval.empty()) {
        char buf[132];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(DataRequiredForComputationOfSourcePostionInformation::sourceDataEnum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DataRequiredForComputationOfSourcePostionInformation::sourceDataEnum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// DependenceGraph::EdgeType is defined at src/midend/programAnalysis/staticInterproceduralSlicing/DependenceGraph.h:693
/** Converts an enum of type DependenceGraph::EdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDependenceGraphEdgeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "CONTROL"; break;
        case 2: retval = "DATA"; break;
        case 3: retval = "SUMMARY"; break;
        case 4: retval = "CALL"; break;
        case 5: retval = "CALL_RETURN"; break;
        case 7: retval = "PARAMETER_IN"; break;
        case 8: retval = "PARAMETER_OUT"; break;
        case 9: retval = "DATA_HELPER"; break;
        case 10: retval = "CONTROL_HELPER"; break;
        case 11: retval = "GLOBALVAR_HELPER"; break;
        case 12: retval = "COMPLETENESS_HELPER"; break;
        case 13: retval = "BELONGS_TO"; break;
        case 14: retval = "SYNTACTIC"; break;
        case 16: retval = "DO_NOT_FOLLOW"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(DependenceGraph::EdgeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DependenceGraph::EdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// DependenceNode::NodeType is defined at src/midend/programAnalysis/staticInterproceduralSlicing/DependenceGraph.h:175
/** Converts an enum of type DependenceNode::NodeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDependenceNodeNodeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "CONTROL"; break;
        case 1: retval = "SGNODE"; break;
        case 2: retval = "CALLSITE"; break;
        case 3: retval = "ACTUALIN"; break;
        case 4: retval = "ACTUALOUT"; break;
        case 5: retval = "FORMALIN"; break;
        case 6: retval = "FORMALOUT"; break;
        case 7: retval = "ENTRY"; break;
        case 8: retval = "ACTUALRETURN"; break;
        case 9: retval = "FORMALRETURN"; break;
        case 10: retval = "NUM_NODE_TYPES"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(DependenceNode::NodeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DependenceNode::NodeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// DependencyInfo::State is defined at src/roseExtensions/qtWidgets/ProjectManager/DependencyInfo.h:21
/** Converts an enum of type DependencyInfo::State to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDependencyInfoState(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "VALID"; break;
        case 1: retval = "INVALID"; break;
        case 2: retval = "ERROR"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(DependencyInfo::State)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DependencyInfo::State::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// Disassembler::SearchHeuristic is defined at src/frontend/Disassemblers/Disassembler.h:152
/** Converts an enum of type Disassembler::SearchHeuristic to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDisassemblerSearchHeuristic(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "SEARCH_FOLLOWING"; break;
        case 2: retval = "SEARCH_IMMEDIATE"; break;
        case 4: retval = "SEARCH_WORDS"; break;
        case 8: retval = "SEARCH_ALLBYTES"; break;
        case 16: retval = "SEARCH_UNUSED"; break;
        case 32: retval = "SEARCH_NONEXE"; break;
        case 64: retval = "SEARCH_DEADEND"; break;
        case 128: retval = "SEARCH_UNKNOWN"; break;
        case 256: retval = "SEARCH_FUNCSYMS"; break;
        case 257: retval = "SEARCH_DEFAULT"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(Disassembler::SearchHeuristic)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Disassembler::SearchHeuristic::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// DisassemblerX86::MMPrefix is defined at src/frontend/Disassemblers/DisassemblerX86.h:77
/** Converts an enum of type DisassemblerX86::MMPrefix to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDisassemblerX86MMPrefix(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "mmNone"; break;
        case 1: retval = "mmF3"; break;
        case 2: retval = "mm66"; break;
        case 3: retval = "mmF2"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(DisassemblerX86::MMPrefix)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DisassemblerX86::MMPrefix::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// DisassemblerX86::RegisterMode is defined at src/frontend/Disassemblers/DisassemblerX86.h:71
/** Converts an enum of type DisassemblerX86::RegisterMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDisassemblerX86RegisterMode(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "rmLegacyByte"; break;
        case 1: retval = "rmRexByte"; break;
        case 2: retval = "rmWord"; break;
        case 3: retval = "rmDWord"; break;
        case 4: retval = "rmQWord"; break;
        case 5: retval = "rmSegment"; break;
        case 6: retval = "rmST"; break;
        case 7: retval = "rmMM"; break;
        case 8: retval = "rmXMM"; break;
        case 9: retval = "rmControl"; break;
        case 10: retval = "rmDebug"; break;
        case 11: retval = "rmReturnNull"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(DisassemblerX86::RegisterMode)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DisassemblerX86::RegisterMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// DisplayEdge::PaintMode is defined at src/roseExtensions/qtWidgets/AstGraphWidget/DisplayEdge.h:40
/** Converts an enum of type DisplayEdge::PaintMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDisplayEdgePaintMode(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "STRAIGHT"; break;
        case 1: retval = "RECTANGULAR"; break;
        case 2: retval = "BEZIER_QUAD"; break;
        case 3: retval = "BEZIER_CUBIC"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(DisplayEdge::PaintMode)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DisplayEdge::PaintMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// DominatorTreesAndDominanceFrontiers::ControlFlowGraph::ID_dir is defined at src/midend/programAnalysis/staticInterproceduralSlicing/ControlFlowGraph.h:53
/** Converts an enum of type DominatorTreesAndDominanceFrontiers::ControlFlowGraph::ID_dir to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDominatorTreesAndDominanceFrontiersControlFlowGraphID_dir(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FORWARD"; break;
        case 1: retval = "BACKWARD"; break;
    }
    if (retval.empty()) {
        char buf[125];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(DominatorTreesAndDominanceFrontiers::ControlFlowGraph::ID_dir)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DominatorTreesAndDominanceFrontiers::ControlFlowGraph::ID_dir::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// DominatorTreesAndDominanceFrontiers::ControlNode::Type is defined at src/midend/programAnalysis/staticInterproceduralSlicing/ControlFlowGraph.h:113
/** Converts an enum of type DominatorTreesAndDominanceFrontiers::ControlNode::Type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDominatorTreesAndDominanceFrontiersControlNodeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SGNODE"; break;
        case 1: retval = "EMPTY"; break;
    }
    if (retval.empty()) {
        char buf[118];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(DominatorTreesAndDominanceFrontiers::ControlNode::Type)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DominatorTreesAndDominanceFrontiers::ControlNode::Type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// DominatorTreesAndDominanceFrontiers::Dir_ection is defined at src/midend/programAnalysis/dominanceAnalysis/DominatorTree.h:14
/** Converts an enum of type DominatorTreesAndDominanceFrontiers::Dir_ection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDominatorTreesAndDominanceFrontiersDir_ection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "PRE_DOMINATOR"; break;
        case 1: retval = "POST_DOMINATOR"; break;
    }
    if (retval.empty()) {
        char buf[111];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(DominatorTreesAndDominanceFrontiers::Dir_ection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DominatorTreesAndDominanceFrontiers::Dir_ection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// DominatorTreesAndDominanceFrontiers::DominatorTree::Direction is defined at src/midend/programAnalysis/dominatorTreesAndDominanceFrontiers/DominatorTree.h:51
/** Converts an enum of type DominatorTreesAndDominanceFrontiers::DominatorTree::Direction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDominatorTreesAndDominanceFrontiersDominatorTreeDirection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "PRE"; break;
        case 1: retval = "POST"; break;
    }
    if (retval.empty()) {
        char buf[125];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(DominatorTreesAndDominanceFrontiers::DominatorTree::Direction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DominatorTreesAndDominanceFrontiers::DominatorTree::Direction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgActualArgumentExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:811
/** Converts an enum of type E_SgActualArgumentExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgActualArgumentExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgActualArgumentExpression_expression"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgActualArgumentExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgActualArgumentExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAddOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:580
/** Converts an enum of type E_SgAddOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAddOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAddOp_lhs_operand_i"; break;
        case 1: retval = "SgAddOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[73];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAddOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAddOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAddressOfOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:517
/** Converts an enum of type E_SgAddressOfOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAddressOfOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAddressOfOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAddressOfOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAddressOfOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAggregateInitializer is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:769
/** Converts an enum of type E_SgAggregateInitializer to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAggregateInitializer(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAggregateInitializer_initializers"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAggregateInitializer)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAggregateInitializer::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAliasSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:856
/** Converts an enum of type E_SgAliasSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAliasSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAliasSymbol_alias"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAliasSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAliasSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAllocateStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:442
/** Converts an enum of type E_SgAllocateStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAllocateStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAllocateStatement_expr_list"; break;
        case 1: retval = "SgAllocateStatement_stat_expression"; break;
        case 2: retval = "SgAllocateStatement_errmsg_expression"; break;
        case 3: retval = "SgAllocateStatement_source_expression"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAllocateStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAllocateStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAndAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:637
/** Converts an enum of type E_SgAndAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAndAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAndAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgAndAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAndAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAndAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAndOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:598
/** Converts an enum of type E_SgAndOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAndOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAndOp_lhs_operand_i"; break;
        case 1: retval = "SgAndOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[73];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAndOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAndOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgArithmeticIfStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:430
/** Converts an enum of type E_SgArithmeticIfStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgArithmeticIfStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgArithmeticIfStatement_conditional"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgArithmeticIfStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgArithmeticIfStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgArrayType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:148
/** Converts an enum of type E_SgArrayType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgArrayType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgArrayType_ref_to"; break;
        case 1: retval = "SgArrayType_ptr_to"; break;
        case 2: retval = "SgArrayType_modifiers"; break;
        case 3: retval = "SgArrayType_typedefs"; break;
        case 4: retval = "SgArrayType_type_kind"; break;
        case 5: retval = "SgArrayType_index"; break;
        case 6: retval = "SgArrayType_dim_info"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgArrayType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgArrayType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgArrowExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:550
/** Converts an enum of type E_SgArrowExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgArrowExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgArrowExp_lhs_operand_i"; break;
        case 1: retval = "SgArrowExp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgArrowExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgArrowExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgArrowStarOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:559
/** Converts an enum of type E_SgArrowStarOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgArrowStarOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgArrowStarOp_lhs_operand_i"; break;
        case 1: retval = "SgArrowStarOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgArrowStarOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgArrowStarOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmArmInstruction is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:868
/** Converts an enum of type E_SgAsmArmInstruction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmArmInstruction(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmArmInstruction_operandList"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmArmInstruction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmArmInstruction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmBinaryAdd is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:901
/** Converts an enum of type E_SgAsmBinaryAdd to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryAdd(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryAdd_lhs"; break;
        case 1: retval = "SgAsmBinaryAdd_rhs"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmBinaryAdd)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryAdd::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmBinaryAddPostupdate is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:922
/** Converts an enum of type E_SgAsmBinaryAddPostupdate to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryAddPostupdate(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryAddPostupdate_lhs"; break;
        case 1: retval = "SgAsmBinaryAddPostupdate_rhs"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmBinaryAddPostupdate)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryAddPostupdate::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmBinaryAddPreupdate is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:916
/** Converts an enum of type E_SgAsmBinaryAddPreupdate to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryAddPreupdate(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryAddPreupdate_lhs"; break;
        case 1: retval = "SgAsmBinaryAddPreupdate_rhs"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmBinaryAddPreupdate)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryAddPreupdate::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmBinaryAsr is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:934
/** Converts an enum of type E_SgAsmBinaryAsr to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryAsr(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryAsr_lhs"; break;
        case 1: retval = "SgAsmBinaryAsr_rhs"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmBinaryAsr)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryAsr::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmBinaryDivide is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:910
/** Converts an enum of type E_SgAsmBinaryDivide to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryDivide(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryDivide_lhs"; break;
        case 1: retval = "SgAsmBinaryDivide_rhs"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmBinaryDivide)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryDivide::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmBinaryExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:940
/** Converts an enum of type E_SgAsmBinaryExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryExpression_lhs"; break;
        case 1: retval = "SgAsmBinaryExpression_rhs"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmBinaryExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmBinaryLsl is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:928
/** Converts an enum of type E_SgAsmBinaryLsl to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryLsl(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryLsl_lhs"; break;
        case 1: retval = "SgAsmBinaryLsl_rhs"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmBinaryLsl)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryLsl::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmBinaryLsr is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:931
/** Converts an enum of type E_SgAsmBinaryLsr to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryLsr(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryLsr_lhs"; break;
        case 1: retval = "SgAsmBinaryLsr_rhs"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmBinaryLsr)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryLsr::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmBinaryMod is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:913
/** Converts an enum of type E_SgAsmBinaryMod to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryMod(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryMod_lhs"; break;
        case 1: retval = "SgAsmBinaryMod_rhs"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmBinaryMod)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryMod::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmBinaryMultiply is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:907
/** Converts an enum of type E_SgAsmBinaryMultiply to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryMultiply(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryMultiply_lhs"; break;
        case 1: retval = "SgAsmBinaryMultiply_rhs"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmBinaryMultiply)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryMultiply::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmBinaryRor is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:937
/** Converts an enum of type E_SgAsmBinaryRor to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryRor(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryRor_lhs"; break;
        case 1: retval = "SgAsmBinaryRor_rhs"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmBinaryRor)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryRor::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmBinarySubtract is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:904
/** Converts an enum of type E_SgAsmBinarySubtract to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinarySubtract(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinarySubtract_lhs"; break;
        case 1: retval = "SgAsmBinarySubtract_rhs"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmBinarySubtract)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinarySubtract::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmBinarySubtractPostupdate is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:925
/** Converts an enum of type E_SgAsmBinarySubtractPostupdate to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinarySubtractPostupdate(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinarySubtractPostupdate_lhs"; break;
        case 1: retval = "SgAsmBinarySubtractPostupdate_rhs"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmBinarySubtractPostupdate)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinarySubtractPostupdate::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmBinarySubtractPreupdate is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:919
/** Converts an enum of type E_SgAsmBinarySubtractPreupdate to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinarySubtractPreupdate(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinarySubtractPreupdate_lhs"; break;
        case 1: retval = "SgAsmBinarySubtractPreupdate_rhs"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmBinarySubtractPreupdate)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinarySubtractPreupdate::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmBlock is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:862
/** Converts an enum of type E_SgAsmBlock to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBlock(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBlock_statementList"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmBlock)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBlock::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmByteValueExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:877
/** Converts an enum of type E_SgAsmByteValueExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmByteValueExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmByteValueExpression_unfolded_expression_tree"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmByteValueExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmByteValueExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmCoffSymbolList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1132
/** Converts an enum of type E_SgAsmCoffSymbolList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmCoffSymbolList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmCoffSymbolList_symbols"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmCoffSymbolList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmCoffSymbolList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmCoffSymbolTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1063
/** Converts an enum of type E_SgAsmCoffSymbolTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmCoffSymbolTable(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmCoffSymbolTable_symbols"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmCoffSymbolTable)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmCoffSymbolTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmCommonSubExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:961
/** Converts an enum of type E_SgAsmCommonSubExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmCommonSubExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmCommonSubExpression_subexpression"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmCommonSubExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmCommonSubExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDOSFileHeader is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1012
/** Converts an enum of type E_SgAsmDOSFileHeader to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDOSFileHeader(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDOSFileHeader_exec_format"; break;
        case 1: retval = "SgAsmDOSFileHeader_dlls"; break;
        case 2: retval = "SgAsmDOSFileHeader_sections"; break;
        case 3: retval = "SgAsmDOSFileHeader_relocs"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDOSFileHeader)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDOSFileHeader::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDoubleFloatValueExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:892
/** Converts an enum of type E_SgAsmDoubleFloatValueExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDoubleFloatValueExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDoubleFloatValueExpression_unfolded_expression_tree"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDoubleFloatValueExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDoubleFloatValueExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDoubleWordValueExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:883
/** Converts an enum of type E_SgAsmDoubleWordValueExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDoubleWordValueExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDoubleWordValueExpression_unfolded_expression_tree"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDoubleWordValueExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDoubleWordValueExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDwarfArrayType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1165
/** Converts an enum of type E_SgAsmDwarfArrayType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfArrayType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfArrayType_body"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDwarfArrayType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfArrayType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDwarfClassType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1168
/** Converts an enum of type E_SgAsmDwarfClassType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfClassType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfClassType_body"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDwarfClassType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfClassType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDwarfCommonBlock is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1189
/** Converts an enum of type E_SgAsmDwarfCommonBlock to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfCommonBlock(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfCommonBlock_body"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDwarfCommonBlock)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfCommonBlock::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDwarfCompilationUnit is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1177
/** Converts an enum of type E_SgAsmDwarfCompilationUnit to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfCompilationUnit(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfCompilationUnit_line_info"; break;
        case 1: retval = "SgAsmDwarfCompilationUnit_language_constructs"; break;
        case 2: retval = "SgAsmDwarfCompilationUnit_macro_info"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDwarfCompilationUnit)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfCompilationUnit::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDwarfCompilationUnitList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1162
/** Converts an enum of type E_SgAsmDwarfCompilationUnitList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfCompilationUnitList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfCompilationUnitList_cu_list"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDwarfCompilationUnitList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfCompilationUnitList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDwarfConstructList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1201
/** Converts an enum of type E_SgAsmDwarfConstructList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfConstructList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfConstructList_list"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDwarfConstructList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfConstructList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDwarfEnumerationType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1171
/** Converts an enum of type E_SgAsmDwarfEnumerationType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfEnumerationType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfEnumerationType_body"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDwarfEnumerationType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfEnumerationType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDwarfInlinedSubroutine is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1192
/** Converts an enum of type E_SgAsmDwarfInlinedSubroutine to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfInlinedSubroutine(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfInlinedSubroutine_body"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDwarfInlinedSubroutine)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfInlinedSubroutine::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDwarfLexicalBlock is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1174
/** Converts an enum of type E_SgAsmDwarfLexicalBlock to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfLexicalBlock(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfLexicalBlock_body"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDwarfLexicalBlock)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfLexicalBlock::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDwarfLineList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1159
/** Converts an enum of type E_SgAsmDwarfLineList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfLineList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfLineList_line_list"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDwarfLineList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfLineList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDwarfMacroList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1156
/** Converts an enum of type E_SgAsmDwarfMacroList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfMacroList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfMacroList_macro_list"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDwarfMacroList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfMacroList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDwarfNamespace is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1198
/** Converts an enum of type E_SgAsmDwarfNamespace to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfNamespace(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfNamespace_body"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDwarfNamespace)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfNamespace::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDwarfStructureType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1180
/** Converts an enum of type E_SgAsmDwarfStructureType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfStructureType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfStructureType_body"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDwarfStructureType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfStructureType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDwarfSubprogram is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1195
/** Converts an enum of type E_SgAsmDwarfSubprogram to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfSubprogram(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfSubprogram_body"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDwarfSubprogram)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfSubprogram::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDwarfSubroutineType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1183
/** Converts an enum of type E_SgAsmDwarfSubroutineType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfSubroutineType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfSubroutineType_body"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDwarfSubroutineType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfSubroutineType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmDwarfUnionType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1186
/** Converts an enum of type E_SgAsmDwarfUnionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfUnionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfUnionType_body"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmDwarfUnionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfUnionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfDynamicSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1027
/** Converts an enum of type E_SgAsmElfDynamicSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfDynamicSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfDynamicSection_section_entry"; break;
        case 1: retval = "SgAsmElfDynamicSection_segment_entry"; break;
        case 2: retval = "SgAsmElfDynamicSection_entries"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfDynamicSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfDynamicSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfEHFrameEntryCI is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1138
/** Converts an enum of type E_SgAsmElfEHFrameEntryCI to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfEHFrameEntryCI(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfEHFrameEntryCI_fd_entries"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfEHFrameEntryCI)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfEHFrameEntryCI::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfEHFrameSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1036
/** Converts an enum of type E_SgAsmElfEHFrameSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfEHFrameSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfEHFrameSection_section_entry"; break;
        case 1: retval = "SgAsmElfEHFrameSection_segment_entry"; break;
        case 2: retval = "SgAsmElfEHFrameSection_ci_entries"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfEHFrameSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfEHFrameSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfFileHeader is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1015
/** Converts an enum of type E_SgAsmElfFileHeader to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfFileHeader(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfFileHeader_exec_format"; break;
        case 1: retval = "SgAsmElfFileHeader_dlls"; break;
        case 2: retval = "SgAsmElfFileHeader_sections"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfFileHeader)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfFileHeader::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfNoteSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1033
/** Converts an enum of type E_SgAsmElfNoteSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfNoteSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfNoteSection_section_entry"; break;
        case 1: retval = "SgAsmElfNoteSection_segment_entry"; break;
        case 2: retval = "SgAsmElfNoteSection_entries"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfNoteSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfNoteSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfRelocSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1024
/** Converts an enum of type E_SgAsmElfRelocSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfRelocSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfRelocSection_section_entry"; break;
        case 1: retval = "SgAsmElfRelocSection_segment_entry"; break;
        case 2: retval = "SgAsmElfRelocSection_entries"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfRelocSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfRelocSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1048
/** Converts an enum of type E_SgAsmElfSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSection_section_entry"; break;
        case 1: retval = "SgAsmElfSection_segment_entry"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfSegmentTableEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1105
/** Converts an enum of type E_SgAsmElfSegmentTableEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSegmentTableEntryList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSegmentTableEntryList_entries"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfSegmentTableEntryList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSegmentTableEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfStringSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1030
/** Converts an enum of type E_SgAsmElfStringSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfStringSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfStringSection_section_entry"; break;
        case 1: retval = "SgAsmElfStringSection_segment_entry"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfStringSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfStringSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfSymbolList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1096
/** Converts an enum of type E_SgAsmElfSymbolList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymbolList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymbolList_symbols"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfSymbolList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymbolList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfSymbolSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1021
/** Converts an enum of type E_SgAsmElfSymbolSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymbolSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymbolSection_section_entry"; break;
        case 1: retval = "SgAsmElfSymbolSection_segment_entry"; break;
        case 2: retval = "SgAsmElfSymbolSection_symbols"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfSymbolSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymbolSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfSymverDefinedAuxList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1117
/** Converts an enum of type E_SgAsmElfSymverDefinedAuxList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverDefinedAuxList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverDefinedAuxList_entries"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverDefinedAuxList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverDefinedAuxList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfSymverDefinedEntry is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1111
/** Converts an enum of type E_SgAsmElfSymverDefinedEntry to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverDefinedEntry(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverDefinedEntry_entries"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverDefinedEntry)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverDefinedEntry::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfSymverDefinedEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1114
/** Converts an enum of type E_SgAsmElfSymverDefinedEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverDefinedEntryList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverDefinedEntryList_entries"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverDefinedEntryList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverDefinedEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfSymverDefinedSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1042
/** Converts an enum of type E_SgAsmElfSymverDefinedSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverDefinedSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverDefinedSection_section_entry"; break;
        case 1: retval = "SgAsmElfSymverDefinedSection_segment_entry"; break;
        case 2: retval = "SgAsmElfSymverDefinedSection_entries"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverDefinedSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverDefinedSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfSymverEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1108
/** Converts an enum of type E_SgAsmElfSymverEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverEntryList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverEntryList_entries"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverEntryList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfSymverNeededAuxList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1126
/** Converts an enum of type E_SgAsmElfSymverNeededAuxList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverNeededAuxList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverNeededAuxList_entries"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverNeededAuxList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverNeededAuxList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfSymverNeededEntry is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1120
/** Converts an enum of type E_SgAsmElfSymverNeededEntry to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverNeededEntry(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverNeededEntry_entries"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverNeededEntry)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverNeededEntry::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfSymverNeededEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1123
/** Converts an enum of type E_SgAsmElfSymverNeededEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverNeededEntryList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverNeededEntryList_entries"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverNeededEntryList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverNeededEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfSymverNeededSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1045
/** Converts an enum of type E_SgAsmElfSymverNeededSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverNeededSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverNeededSection_section_entry"; break;
        case 1: retval = "SgAsmElfSymverNeededSection_segment_entry"; break;
        case 2: retval = "SgAsmElfSymverNeededSection_entries"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverNeededSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverNeededSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmElfSymverSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1039
/** Converts an enum of type E_SgAsmElfSymverSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverSection_section_entry"; break;
        case 1: retval = "SgAsmElfSymverSection_segment_entry"; break;
        case 2: retval = "SgAsmElfSymverSection_entries"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmExprListExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:964
/** Converts an enum of type E_SgAsmExprListExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmExprListExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmExprListExp_expressions"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmExprListExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmExprListExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmFunctionDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:859
/** Converts an enum of type E_SgAsmFunctionDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmFunctionDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmFunctionDeclaration_statementList"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmFunctionDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmFunctionDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmGenericFile is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1000
/** Converts an enum of type E_SgAsmGenericFile to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericFile(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmGenericFile_headers"; break;
        case 1: retval = "SgAsmGenericFile_holes"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmGenericFile)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericFile::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmGenericFileList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1207
/** Converts an enum of type E_SgAsmGenericFileList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericFileList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmGenericFileList_files"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmGenericFileList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericFileList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmGenericHeader is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1018
/** Converts an enum of type E_SgAsmGenericHeader to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericHeader(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmGenericHeader_exec_format"; break;
        case 1: retval = "SgAsmGenericHeader_dlls"; break;
        case 2: retval = "SgAsmGenericHeader_sections"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmGenericHeader)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericHeader::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmGenericHeaderList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1093
/** Converts an enum of type E_SgAsmGenericHeaderList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericHeaderList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmGenericHeaderList_headers"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmGenericHeaderList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericHeaderList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmGenericSectionList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1090
/** Converts an enum of type E_SgAsmGenericSectionList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericSectionList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmGenericSectionList_sections"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmGenericSectionList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericSectionList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmInstruction is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:874
/** Converts an enum of type E_SgAsmInstruction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmInstruction(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmInstruction_operandList"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmInstruction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmInstruction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmInterpretation is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:967
/** Converts an enum of type E_SgAsmInterpretation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmInterpretation(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmInterpretation_dwarf_info"; break;
        case 1: retval = "SgAsmInterpretation_global_block"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmInterpretation)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmInterpretation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmInterpretationList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1204
/** Converts an enum of type E_SgAsmInterpretationList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmInterpretationList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmInterpretationList_interpretations"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmInterpretationList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmInterpretationList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmLEEntryPoint is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1153
/** Converts an enum of type E_SgAsmLEEntryPoint to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmLEEntryPoint(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmLEEntryPoint_entries"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmLEEntryPoint)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmLEEntryPoint::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmLEEntryTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1084
/** Converts an enum of type E_SgAsmLEEntryTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmLEEntryTable(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmLEEntryTable_entries"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmLEEntryTable)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmLEEntryTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmLEFileHeader is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1006
/** Converts an enum of type E_SgAsmLEFileHeader to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmLEFileHeader(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmLEFileHeader_exec_format"; break;
        case 1: retval = "SgAsmLEFileHeader_dlls"; break;
        case 2: retval = "SgAsmLEFileHeader_sections"; break;
        case 3: retval = "SgAsmLEFileHeader_dos2_header"; break;
        case 4: retval = "SgAsmLEFileHeader_page_table"; break;
        case 5: retval = "SgAsmLEFileHeader_resname_table"; break;
        case 6: retval = "SgAsmLEFileHeader_nonresname_table"; break;
        case 7: retval = "SgAsmLEFileHeader_entry_table"; break;
        case 8: retval = "SgAsmLEFileHeader_reloc_table"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmLEFileHeader)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmLEFileHeader::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmLEPageTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1081
/** Converts an enum of type E_SgAsmLEPageTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmLEPageTable(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmLEPageTable_entries"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmLEPageTable)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmLEPageTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmLERelocTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1087
/** Converts an enum of type E_SgAsmLERelocTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmLERelocTable(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmLERelocTable_entries"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmLERelocTable)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmLERelocTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmLESection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1078
/** Converts an enum of type E_SgAsmLESection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmLESection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmLESection_st_entry"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmLESection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmLESection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmMemoryReferenceExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:958
/** Converts an enum of type E_SgAsmMemoryReferenceExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmMemoryReferenceExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmMemoryReferenceExpression_address"; break;
        case 1: retval = "SgAsmMemoryReferenceExpression_segment"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmMemoryReferenceExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmMemoryReferenceExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmNEEntryTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1072
/** Converts an enum of type E_SgAsmNEEntryTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmNEEntryTable(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmNEEntryTable_entries"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmNEEntryTable)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmNEEntryTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmNEFileHeader is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1009
/** Converts an enum of type E_SgAsmNEFileHeader to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmNEFileHeader(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmNEFileHeader_exec_format"; break;
        case 1: retval = "SgAsmNEFileHeader_dlls"; break;
        case 2: retval = "SgAsmNEFileHeader_sections"; break;
        case 3: retval = "SgAsmNEFileHeader_dos2_header"; break;
        case 4: retval = "SgAsmNEFileHeader_resname_table"; break;
        case 5: retval = "SgAsmNEFileHeader_nonresname_table"; break;
        case 6: retval = "SgAsmNEFileHeader_module_table"; break;
        case 7: retval = "SgAsmNEFileHeader_entry_table"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmNEFileHeader)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmNEFileHeader::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmNEModuleTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1069
/** Converts an enum of type E_SgAsmNEModuleTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmNEModuleTable(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmNEModuleTable_strtab"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmNEModuleTable)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmNEModuleTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmNERelocTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1075
/** Converts an enum of type E_SgAsmNERelocTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmNERelocTable(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmNERelocTable_entries"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmNERelocTable)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmNERelocTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmNESection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1066
/** Converts an enum of type E_SgAsmNESection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmNESection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmNESection_st_entry"; break;
        case 1: retval = "SgAsmNESection_reloc_table"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmNESection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmNESection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:808
/** Converts an enum of type E_SgAsmOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmOp_expression"; break;
    }
    if (retval.empty()) {
        char buf[73];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmOperandList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:970
/** Converts an enum of type E_SgAsmOperandList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmOperandList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmOperandList_operands"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmOperandList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmOperandList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmPEExportEntry is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1099
/** Converts an enum of type E_SgAsmPEExportEntry to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEExportEntry(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEExportEntry_name"; break;
        case 1: retval = "SgAsmPEExportEntry_forwarder"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmPEExportEntry)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEExportEntry::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmPEExportEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1102
/** Converts an enum of type E_SgAsmPEExportEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEExportEntryList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEExportEntryList_exports"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmPEExportEntryList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEExportEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmPEExportSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1054
/** Converts an enum of type E_SgAsmPEExportSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEExportSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEExportSection_section_entry"; break;
        case 1: retval = "SgAsmPEExportSection_export_dir"; break;
        case 2: retval = "SgAsmPEExportSection_exports"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmPEExportSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEExportSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmPEFileHeader is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1003
/** Converts an enum of type E_SgAsmPEFileHeader to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEFileHeader(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEFileHeader_exec_format"; break;
        case 1: retval = "SgAsmPEFileHeader_dlls"; break;
        case 2: retval = "SgAsmPEFileHeader_sections"; break;
        case 3: retval = "SgAsmPEFileHeader_rvasize_pairs"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmPEFileHeader)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEFileHeader::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmPEImportDirectory is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1129
/** Converts an enum of type E_SgAsmPEImportDirectory to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEImportDirectory(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEImportDirectory_ilt"; break;
        case 1: retval = "SgAsmPEImportDirectory_iat"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmPEImportDirectory)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEImportDirectory::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmPEImportDirectoryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1150
/** Converts an enum of type E_SgAsmPEImportDirectoryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEImportDirectoryList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEImportDirectoryList_vector"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmPEImportDirectoryList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEImportDirectoryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmPEImportHNTEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1141
/** Converts an enum of type E_SgAsmPEImportHNTEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEImportHNTEntryList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEImportHNTEntryList_hintnames"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmPEImportHNTEntryList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEImportHNTEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmPEImportILTEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1144
/** Converts an enum of type E_SgAsmPEImportILTEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEImportILTEntryList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEImportILTEntryList_vector"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmPEImportILTEntryList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEImportILTEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmPEImportLookupTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1147
/** Converts an enum of type E_SgAsmPEImportLookupTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEImportLookupTable(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEImportLookupTable_entries"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmPEImportLookupTable)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEImportLookupTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmPEImportSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1051
/** Converts an enum of type E_SgAsmPEImportSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEImportSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEImportSection_section_entry"; break;
        case 1: retval = "SgAsmPEImportSection_import_directories"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmPEImportSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEImportSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmPERVASizePairList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1135
/** Converts an enum of type E_SgAsmPERVASizePairList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPERVASizePairList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPERVASizePairList_pairs"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmPERVASizePairList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPERVASizePairList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmPESection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1060
/** Converts an enum of type E_SgAsmPESection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPESection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPESection_section_entry"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmPESection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPESection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmPEStringSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1057
/** Converts an enum of type E_SgAsmPEStringSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEStringSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEStringSection_section_entry"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmPEStringSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEStringSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmPowerpcInstruction is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:871
/** Converts an enum of type E_SgAsmPowerpcInstruction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPowerpcInstruction(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPowerpcInstruction_operandList"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmPowerpcInstruction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPowerpcInstruction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmQuadWordValueExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:886
/** Converts an enum of type E_SgAsmQuadWordValueExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmQuadWordValueExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmQuadWordValueExpression_unfolded_expression_tree"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmQuadWordValueExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmQuadWordValueExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmSingleFloatValueExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:889
/** Converts an enum of type E_SgAsmSingleFloatValueExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmSingleFloatValueExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmSingleFloatValueExpression_unfolded_expression_tree"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmSingleFloatValueExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmSingleFloatValueExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:292
/** Converts an enum of type E_SgAsmStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmStmt_operands"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmType128bitFloat is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:991
/** Converts an enum of type E_SgAsmType128bitFloat to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmType128bitFloat(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmType128bitFloat_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmType128bitFloat)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmType128bitFloat::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmType80bitFloat is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:988
/** Converts an enum of type E_SgAsmType80bitFloat to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmType80bitFloat(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmType80bitFloat_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmType80bitFloat)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmType80bitFloat::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmTypeByte is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:973
/** Converts an enum of type E_SgAsmTypeByte to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmTypeByte(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmTypeByte_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmTypeByte)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmTypeByte::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmTypeDoubleFloat is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:997
/** Converts an enum of type E_SgAsmTypeDoubleFloat to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmTypeDoubleFloat(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmTypeDoubleFloat_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmTypeDoubleFloat)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmTypeDoubleFloat::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmTypeDoubleQuadWord is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:985
/** Converts an enum of type E_SgAsmTypeDoubleQuadWord to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmTypeDoubleQuadWord(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmTypeDoubleQuadWord_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmTypeDoubleQuadWord)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmTypeDoubleQuadWord::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmTypeDoubleWord is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:979
/** Converts an enum of type E_SgAsmTypeDoubleWord to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmTypeDoubleWord(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmTypeDoubleWord_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmTypeDoubleWord)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmTypeDoubleWord::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmTypeQuadWord is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:982
/** Converts an enum of type E_SgAsmTypeQuadWord to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmTypeQuadWord(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmTypeQuadWord_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmTypeQuadWord)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmTypeQuadWord::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmTypeSingleFloat is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:994
/** Converts an enum of type E_SgAsmTypeSingleFloat to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmTypeSingleFloat(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmTypeSingleFloat_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmTypeSingleFloat)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmTypeSingleFloat::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmTypeWord is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:976
/** Converts an enum of type E_SgAsmTypeWord to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmTypeWord(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmTypeWord_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmTypeWord)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmTypeWord::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmUnaryArmSpecialRegisterList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:952
/** Converts an enum of type E_SgAsmUnaryArmSpecialRegisterList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmUnaryArmSpecialRegisterList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmUnaryArmSpecialRegisterList_operand"; break;
    }
    if (retval.empty()) {
        char buf[98];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmUnaryArmSpecialRegisterList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmUnaryArmSpecialRegisterList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmUnaryExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:955
/** Converts an enum of type E_SgAsmUnaryExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmUnaryExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmUnaryExpression_operand"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmUnaryExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmUnaryExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmUnaryMinus is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:946
/** Converts an enum of type E_SgAsmUnaryMinus to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmUnaryMinus(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmUnaryMinus_operand"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmUnaryMinus)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmUnaryMinus::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmUnaryPlus is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:943
/** Converts an enum of type E_SgAsmUnaryPlus to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmUnaryPlus(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmUnaryPlus_operand"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmUnaryPlus)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmUnaryPlus::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmUnaryRrx is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:949
/** Converts an enum of type E_SgAsmUnaryRrx to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmUnaryRrx(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmUnaryRrx_operand"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmUnaryRrx)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmUnaryRrx::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmValueExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:898
/** Converts an enum of type E_SgAsmValueExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmValueExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmValueExpression_unfolded_expression_tree"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmValueExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmValueExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmVectorValueExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:895
/** Converts an enum of type E_SgAsmVectorValueExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmVectorValueExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmVectorValueExpression_unfolded_expression_tree"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmVectorValueExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmVectorValueExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmWordValueExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:880
/** Converts an enum of type E_SgAsmWordValueExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmWordValueExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmWordValueExpression_unfolded_expression_tree"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmWordValueExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmWordValueExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAsmx86Instruction is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:865
/** Converts an enum of type E_SgAsmx86Instruction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmx86Instruction(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmx86Instruction_operandList"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAsmx86Instruction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmx86Instruction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAssignInitializer is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:775
/** Converts an enum of type E_SgAssignInitializer to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAssignInitializer(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAssignInitializer_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAssignInitializer)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAssignInitializer::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:628
/** Converts an enum of type E_SgAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAssignStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:433
/** Converts an enum of type E_SgAssignStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAssignStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAssignStatement_value"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAssignStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAssignStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAssignedGotoStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:439
/** Converts an enum of type E_SgAssignedGotoStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAssignedGotoStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAssignedGotoStatement_targets"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAssignedGotoStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAssignedGotoStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgAssociateStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:262
/** Converts an enum of type E_SgAssociateStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAssociateStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAssociateStatement_variable_declaration"; break;
        case 1: retval = "SgAssociateStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgAssociateStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAssociateStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgBackspaceStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:406
/** Converts an enum of type E_SgBackspaceStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBackspaceStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBackspaceStatement_io_stmt_list"; break;
        case 1: retval = "SgBackspaceStatement_unit"; break;
        case 2: retval = "SgBackspaceStatement_iostat"; break;
        case 3: retval = "SgBackspaceStatement_err"; break;
        case 4: retval = "SgBackspaceStatement_iomsg"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgBackspaceStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBackspaceStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgBaseClass is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:16
/** Converts an enum of type E_SgBaseClass to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBaseClass(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBaseClass_base_class"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgBaseClass)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBaseClass::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgBasicBlock is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:229
/** Converts an enum of type E_SgBasicBlock to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBasicBlock(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBasicBlock_statements"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgBasicBlock)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBasicBlock::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgBinaryComposite is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:7
/** Converts an enum of type E_SgBinaryComposite to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBinaryComposite(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBinaryComposite_genericFileList"; break;
        case 1: retval = "SgBinaryComposite_interpretations"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgBinaryComposite)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBinaryComposite::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgBinaryOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:673
/** Converts an enum of type E_SgBinaryOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBinaryOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBinaryOp_lhs_operand_i"; break;
        case 1: retval = "SgBinaryOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgBinaryOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBinaryOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgBitAndOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:607
/** Converts an enum of type E_SgBitAndOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBitAndOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBitAndOp_lhs_operand_i"; break;
        case 1: retval = "SgBitAndOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgBitAndOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBitAndOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgBitComplementOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:526
/** Converts an enum of type E_SgBitComplementOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBitComplementOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBitComplementOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgBitComplementOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBitComplementOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgBitOrOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:610
/** Converts an enum of type E_SgBitOrOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBitOrOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBitOrOp_lhs_operand_i"; break;
        case 1: retval = "SgBitOrOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgBitOrOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBitOrOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgBitXorOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:604
/** Converts an enum of type E_SgBitXorOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBitXorOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBitXorOp_lhs_operand_i"; break;
        case 1: retval = "SgBitXorOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgBitXorOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBitXorOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgBoolValExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:679
/** Converts an enum of type E_SgBoolValExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBoolValExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBoolValExp_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgBoolValExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBoolValExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgCAFCoExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:817
/** Converts an enum of type E_SgCAFCoExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCAFCoExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCAFCoExpression_referData"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgCAFCoExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCAFCoExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgCAFWithTeamStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:277
/** Converts an enum of type E_SgCAFWithTeamStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCAFWithTeamStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCAFWithTeamStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgCAFWithTeamStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCAFWithTeamStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgCaseOptionStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:364
/** Converts an enum of type E_SgCaseOptionStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCaseOptionStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCaseOptionStmt_key"; break;
        case 1: retval = "SgCaseOptionStmt_body"; break;
        case 2: retval = "SgCaseOptionStmt_key_range_end"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgCaseOptionStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCaseOptionStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgCastExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:529
/** Converts an enum of type E_SgCastExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCastExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCastExp_operand_i"; break;
        case 1: retval = "SgCastExp_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgCastExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCastExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgCatchOptionStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:256
/** Converts an enum of type E_SgCatchOptionStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCatchOptionStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCatchOptionStmt_condition"; break;
        case 1: retval = "SgCatchOptionStmt_body"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgCatchOptionStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCatchOptionStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgCatchStatementSeq is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:382
/** Converts an enum of type E_SgCatchStatementSeq to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCatchStatementSeq(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCatchStatementSeq_catch_statement_seq"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgCatchStatementSeq)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCatchStatementSeq::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgCharVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:688
/** Converts an enum of type E_SgCharVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCharVal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCharVal_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgCharVal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCharVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgClassDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:331
/** Converts an enum of type E_SgClassDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgClassDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgClassDeclaration_definition"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgClassDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgClassDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgClassDefinition is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:244
/** Converts an enum of type E_SgClassDefinition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgClassDefinition(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgClassDefinition_members"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgClassDefinition)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgClassDefinition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgClassSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:835
/** Converts an enum of type E_SgClassSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgClassSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgClassSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgClassSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgClassSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgClassType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:121
/** Converts an enum of type E_SgClassType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgClassType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgClassType_ref_to"; break;
        case 1: retval = "SgClassType_ptr_to"; break;
        case 2: retval = "SgClassType_modifiers"; break;
        case 3: retval = "SgClassType_typedefs"; break;
        case 4: retval = "SgClassType_type_kind"; break;
        case 5: retval = "SgClassType_builtin_type"; break;
        case 6: retval = "SgClassType_declaration"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgClassType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgClassType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgCloseStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:397
/** Converts an enum of type E_SgCloseStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCloseStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCloseStatement_io_stmt_list"; break;
        case 1: retval = "SgCloseStatement_unit"; break;
        case 2: retval = "SgCloseStatement_iostat"; break;
        case 3: retval = "SgCloseStatement_err"; break;
        case 4: retval = "SgCloseStatement_iomsg"; break;
        case 5: retval = "SgCloseStatement_status"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgCloseStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCloseStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgCommaOpExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:613
/** Converts an enum of type E_SgCommaOpExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCommaOpExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCommaOpExp_lhs_operand_i"; break;
        case 1: retval = "SgCommaOpExp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgCommaOpExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCommaOpExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgCommonBlock is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:307
/** Converts an enum of type E_SgCommonBlock to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCommonBlock(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCommonBlock_block_list"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgCommonBlock)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCommonBlock::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgCommonBlockObject is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:181
/** Converts an enum of type E_SgCommonBlockObject to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCommonBlockObject(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCommonBlockObject_variable_reference_list"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgCommonBlockObject)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCommonBlockObject::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgComplexVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:730
/** Converts an enum of type E_SgComplexVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgComplexVal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgComplexVal_originalExpressionTree"; break;
        case 1: retval = "SgComplexVal_real_value"; break;
        case 2: retval = "SgComplexVal_imaginary_value"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgComplexVal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgComplexVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgComputedGotoStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:436
/** Converts an enum of type E_SgComputedGotoStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgComputedGotoStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgComputedGotoStatement_labelList"; break;
        case 1: retval = "SgComputedGotoStatement_label_index"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgComputedGotoStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgComputedGotoStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgConcatenationOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:664
/** Converts an enum of type E_SgConcatenationOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgConcatenationOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgConcatenationOp_lhs_operand_i"; break;
        case 1: retval = "SgConcatenationOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgConcatenationOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgConcatenationOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgConditionalExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:760
/** Converts an enum of type E_SgConditionalExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgConditionalExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgConditionalExp_conditional_exp"; break;
        case 1: retval = "SgConditionalExp_true_exp"; break;
        case 2: retval = "SgConditionalExp_false_exp"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgConditionalExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgConditionalExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgConjugateOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:541
/** Converts an enum of type E_SgConjugateOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgConjugateOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgConjugateOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgConjugateOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgConjugateOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgConstructorInitializer is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:772
/** Converts an enum of type E_SgConstructorInitializer to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgConstructorInitializer(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgConstructorInitializer_args"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgConstructorInitializer)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgConstructorInitializer::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgCtorInitializerList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:316
/** Converts an enum of type E_SgCtorInitializerList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCtorInitializerList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCtorInitializerList_ctors"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgCtorInitializerList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCtorInitializerList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgCudaKernelCallExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:820
/** Converts an enum of type E_SgCudaKernelCallExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCudaKernelCallExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCudaKernelCallExp_function"; break;
        case 1: retval = "SgCudaKernelCallExp_args"; break;
        case 2: retval = "SgCudaKernelCallExp_exec_config"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgCudaKernelCallExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCudaKernelCallExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgCudaKernelExecConfig is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:823
/** Converts an enum of type E_SgCudaKernelExecConfig to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCudaKernelExecConfig(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCudaKernelExecConfig_grid"; break;
        case 1: retval = "SgCudaKernelExecConfig_blocks"; break;
        case 2: retval = "SgCudaKernelExecConfig_shared"; break;
        case 3: retval = "SgCudaKernelExecConfig_stream"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgCudaKernelExecConfig)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCudaKernelExecConfig::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgDeallocateStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:445
/** Converts an enum of type E_SgDeallocateStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDeallocateStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDeallocateStatement_expr_list"; break;
        case 1: retval = "SgDeallocateStatement_stat_expression"; break;
        case 2: retval = "SgDeallocateStatement_errmsg_expression"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgDeallocateStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDeallocateStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgDefaultOptionStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:370
/** Converts an enum of type E_SgDefaultOptionStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDefaultOptionStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDefaultOptionStmt_body"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgDefaultOptionStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDefaultOptionStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgDeleteExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:766
/** Converts an enum of type E_SgDeleteExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDeleteExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDeleteExp_variable"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgDeleteExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDeleteExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgDerivedTypeStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:325
/** Converts an enum of type E_SgDerivedTypeStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDerivedTypeStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDerivedTypeStatement_definition"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgDerivedTypeStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDerivedTypeStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgDesignatedInitializer is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:778
/** Converts an enum of type E_SgDesignatedInitializer to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDesignatedInitializer(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDesignatedInitializer_designatorList"; break;
        case 1: retval = "SgDesignatedInitializer_memberInit"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgDesignatedInitializer)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDesignatedInitializer::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgDirectory is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:25
/** Converts an enum of type E_SgDirectory to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDirectory(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDirectory_fileList"; break;
        case 1: retval = "SgDirectory_directoryList"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgDirectory)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDirectory::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgDirectoryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:31
/** Converts an enum of type E_SgDirectoryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDirectoryList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDirectoryList_listOfDirectories"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgDirectoryList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDirectoryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgDivAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:646
/** Converts an enum of type E_SgDivAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDivAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDivAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgDivAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgDivAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDivAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgDivideOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:589
/** Converts an enum of type E_SgDivideOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDivideOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDivideOp_lhs_operand_i"; break;
        case 1: retval = "SgDivideOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgDivideOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDivideOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgDoWhileStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:250
/** Converts an enum of type E_SgDoWhileStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDoWhileStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDoWhileStmt_body"; break;
        case 1: retval = "SgDoWhileStmt_condition"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgDoWhileStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDoWhileStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgDotExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:553
/** Converts an enum of type E_SgDotExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDotExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDotExp_lhs_operand_i"; break;
        case 1: retval = "SgDotExp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgDotExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDotExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgDotStarOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:556
/** Converts an enum of type E_SgDotStarOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDotStarOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDotStarOp_lhs_operand_i"; break;
        case 1: retval = "SgDotStarOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgDotStarOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDotStarOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgDoubleVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:724
/** Converts an enum of type E_SgDoubleVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDoubleVal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDoubleVal_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgDoubleVal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDoubleVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgElseWhereStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:424
/** Converts an enum of type E_SgElseWhereStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgElseWhereStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgElseWhereStatement_condition"; break;
        case 1: retval = "SgElseWhereStatement_body"; break;
        case 2: retval = "SgElseWhereStatement_elsewhere"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgElseWhereStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgElseWhereStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgEndfileStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:412
/** Converts an enum of type E_SgEndfileStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEndfileStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgEndfileStatement_io_stmt_list"; break;
        case 1: retval = "SgEndfileStatement_unit"; break;
        case 2: retval = "SgEndfileStatement_iostat"; break;
        case 3: retval = "SgEndfileStatement_err"; break;
        case 4: retval = "SgEndfileStatement_iomsg"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgEndfileStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEndfileStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgEntryStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:352
/** Converts an enum of type E_SgEntryStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEntryStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgEntryStatement_parameterList"; break;
        case 1: retval = "SgEntryStatement_definition"; break;
        case 2: retval = "SgEntryStatement_result_name"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgEntryStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEntryStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgEnumDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:289
/** Converts an enum of type E_SgEnumDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEnumDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgEnumDeclaration_enumerators"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgEnumDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEnumDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgEnumSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:841
/** Converts an enum of type E_SgEnumSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEnumSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgEnumSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgEnumSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEnumSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgEnumType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:124
/** Converts an enum of type E_SgEnumType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEnumType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgEnumType_ref_to"; break;
        case 1: retval = "SgEnumType_ptr_to"; break;
        case 2: retval = "SgEnumType_modifiers"; break;
        case 3: retval = "SgEnumType_typedefs"; break;
        case 4: retval = "SgEnumType_type_kind"; break;
        case 5: retval = "SgEnumType_builtin_type"; break;
        case 6: retval = "SgEnumType_declaration"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgEnumType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEnumType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgEnumVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:703
/** Converts an enum of type E_SgEnumVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEnumVal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgEnumVal_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgEnumVal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEnumVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgEqualityOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:562
/** Converts an enum of type E_SgEqualityOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEqualityOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgEqualityOp_lhs_operand_i"; break;
        case 1: retval = "SgEqualityOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgEqualityOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEqualityOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgExponentiationOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:661
/** Converts an enum of type E_SgExponentiationOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgExponentiationOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgExponentiationOp_lhs_operand_i"; break;
        case 1: retval = "SgExponentiationOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgExponentiationOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgExponentiationOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgExprListExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:676
/** Converts an enum of type E_SgExprListExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgExprListExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgExprListExp_expressions"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgExprListExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgExprListExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgExprStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:361
/** Converts an enum of type E_SgExprStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgExprStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgExprStatement_expression"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgExprStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgExprStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgExpressionRoot is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:502
/** Converts an enum of type E_SgExpressionRoot to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgExpressionRoot(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgExpressionRoot_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgExpressionRoot)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgExpressionRoot::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgFileList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:28
/** Converts an enum of type E_SgFileList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFileList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFileList_listOfFiles"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgFileList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFileList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgFloatVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:721
/** Converts an enum of type E_SgFloatVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFloatVal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFloatVal_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgFloatVal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFloatVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgFlushStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:403
/** Converts an enum of type E_SgFlushStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFlushStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFlushStatement_io_stmt_list"; break;
        case 1: retval = "SgFlushStatement_unit"; break;
        case 2: retval = "SgFlushStatement_iostat"; break;
        case 3: retval = "SgFlushStatement_err"; break;
        case 4: retval = "SgFlushStatement_iomsg"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgFlushStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFlushStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgForAllStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:271
/** Converts an enum of type E_SgForAllStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgForAllStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgForAllStatement_forall_header"; break;
        case 1: retval = "SgForAllStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgForAllStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgForAllStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgForInitStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:379
/** Converts an enum of type E_SgForInitStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgForInitStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgForInitStatement_init_stmt"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgForInitStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgForInitStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgForStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:235
/** Converts an enum of type E_SgForStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgForStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgForStatement_for_init_stmt"; break;
        case 1: retval = "SgForStatement_test"; break;
        case 2: retval = "SgForStatement_increment"; break;
        case 3: retval = "SgForStatement_loop_body"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgForStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgForStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgFortranDo is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:268
/** Converts an enum of type E_SgFortranDo to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFortranDo(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFortranDo_initialization"; break;
        case 1: retval = "SgFortranDo_bound"; break;
        case 2: retval = "SgFortranDo_increment"; break;
        case 3: retval = "SgFortranDo_body"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgFortranDo)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFortranDo::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgFortranNonblockedDo is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:265
/** Converts an enum of type E_SgFortranNonblockedDo to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFortranNonblockedDo(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFortranNonblockedDo_initialization"; break;
        case 1: retval = "SgFortranNonblockedDo_bound"; break;
        case 2: retval = "SgFortranNonblockedDo_increment"; break;
        case 3: retval = "SgFortranNonblockedDo_body"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgFortranNonblockedDo)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFortranNonblockedDo::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgFunctionCallExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:742
/** Converts an enum of type E_SgFunctionCallExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionCallExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFunctionCallExp_function"; break;
        case 1: retval = "SgFunctionCallExp_args"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgFunctionCallExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionCallExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgFunctionDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:355
/** Converts an enum of type E_SgFunctionDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFunctionDeclaration_parameterList"; break;
        case 1: retval = "SgFunctionDeclaration_definition"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgFunctionDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgFunctionDefinition is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:238
/** Converts an enum of type E_SgFunctionDefinition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionDefinition(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFunctionDefinition_body"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgFunctionDefinition)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionDefinition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgFunctionParameterList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:280
/** Converts an enum of type E_SgFunctionParameterList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionParameterList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFunctionParameterList_args"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgFunctionParameterList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionParameterList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgFunctionSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:832
/** Converts an enum of type E_SgFunctionSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFunctionSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgFunctionSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgFunctionType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:145
/** Converts an enum of type E_SgFunctionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFunctionType_ref_to"; break;
        case 1: retval = "SgFunctionType_ptr_to"; break;
        case 2: retval = "SgFunctionType_modifiers"; break;
        case 3: retval = "SgFunctionType_typedefs"; break;
        case 4: retval = "SgFunctionType_type_kind"; break;
        case 5: retval = "SgFunctionType_return_type"; break;
        case 6: retval = "SgFunctionType_orig_return_type"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgFunctionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgGlobal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:226
/** Converts an enum of type E_SgGlobal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgGlobal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgGlobal_declarations"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgGlobal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgGlobal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgGreaterOrEqualOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:577
/** Converts an enum of type E_SgGreaterOrEqualOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgGreaterOrEqualOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgGreaterOrEqualOp_lhs_operand_i"; break;
        case 1: retval = "SgGreaterOrEqualOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgGreaterOrEqualOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgGreaterOrEqualOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgGreaterThanOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:568
/** Converts an enum of type E_SgGreaterThanOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgGreaterThanOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgGreaterThanOp_lhs_operand_i"; break;
        case 1: retval = "SgGreaterThanOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgGreaterThanOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgGreaterThanOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgIOItemExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:802
/** Converts an enum of type E_SgIOItemExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIOItemExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgIOItemExpression_io_item"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgIOItemExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIOItemExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgIOStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:418
/** Converts an enum of type E_SgIOStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIOStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgIOStatement_io_stmt_list"; break;
        case 1: retval = "SgIOStatement_unit"; break;
        case 2: retval = "SgIOStatement_iostat"; break;
        case 3: retval = "SgIOStatement_err"; break;
        case 4: retval = "SgIOStatement_iomsg"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgIOStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIOStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgIfStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:232
/** Converts an enum of type E_SgIfStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIfStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgIfStmt_conditional"; break;
        case 1: retval = "SgIfStmt_true_body"; break;
        case 2: retval = "SgIfStmt_false_body"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgIfStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIfStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgImagPartOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:538
/** Converts an enum of type E_SgImagPartOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgImagPartOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgImagPartOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgImagPartOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgImagPartOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgImplicitStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:334
/** Converts an enum of type E_SgImplicitStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgImplicitStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgImplicitStatement_variables"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgImplicitStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgImplicitStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgImpliedDo is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:799
/** Converts an enum of type E_SgImpliedDo to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgImpliedDo(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgImpliedDo_do_var_initialization"; break;
        case 1: retval = "SgImpliedDo_last_val"; break;
        case 2: retval = "SgImpliedDo_increment"; break;
        case 3: retval = "SgImpliedDo_object_list"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgImpliedDo)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgImpliedDo::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgInitializedName is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:184
/** Converts an enum of type E_SgInitializedName to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgInitializedName(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgInitializedName_initptr"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgInitializedName)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgInitializedName::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgInquireStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:400
/** Converts an enum of type E_SgInquireStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgInquireStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgInquireStatement_io_stmt_list"; break;
        case 1: retval = "SgInquireStatement_unit"; break;
        case 2: retval = "SgInquireStatement_iostat"; break;
        case 3: retval = "SgInquireStatement_err"; break;
        case 4: retval = "SgInquireStatement_iomsg"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgInquireStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgInquireStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgIntVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:700
/** Converts an enum of type E_SgIntVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIntVal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgIntVal_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgIntVal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIntVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgIntegerDivideOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:592
/** Converts an enum of type E_SgIntegerDivideOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIntegerDivideOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgIntegerDivideOp_lhs_operand_i"; break;
        case 1: retval = "SgIntegerDivideOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgIntegerDivideOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIntegerDivideOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgInterfaceStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:304
/** Converts an enum of type E_SgInterfaceStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgInterfaceStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgInterfaceStatement_interface_body_list"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgInterfaceStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgInterfaceStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgIorAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:640
/** Converts an enum of type E_SgIorAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIorAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgIorAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgIorAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgIorAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIorAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgLabelSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:847
/** Converts an enum of type E_SgLabelSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLabelSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgLabelSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgLabelSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLabelSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgLessOrEqualOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:574
/** Converts an enum of type E_SgLessOrEqualOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLessOrEqualOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgLessOrEqualOp_lhs_operand_i"; break;
        case 1: retval = "SgLessOrEqualOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgLessOrEqualOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLessOrEqualOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgLessThanOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:565
/** Converts an enum of type E_SgLessThanOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLessThanOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgLessThanOp_lhs_operand_i"; break;
        case 1: retval = "SgLessThanOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgLessThanOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLessThanOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgLongDoubleVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:727
/** Converts an enum of type E_SgLongDoubleVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLongDoubleVal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgLongDoubleVal_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgLongDoubleVal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLongDoubleVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgLongIntVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:709
/** Converts an enum of type E_SgLongIntVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLongIntVal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgLongIntVal_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgLongIntVal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLongIntVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgLongLongIntVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:712
/** Converts an enum of type E_SgLongLongIntVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLongLongIntVal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgLongLongIntVal_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgLongLongIntVal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLongLongIntVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgLshiftAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:655
/** Converts an enum of type E_SgLshiftAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLshiftAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgLshiftAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgLshiftAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgLshiftAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLshiftAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgLshiftOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:616
/** Converts an enum of type E_SgLshiftOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLshiftOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgLshiftOp_lhs_operand_i"; break;
        case 1: retval = "SgLshiftOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgLshiftOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLshiftOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgMemberFunctionDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:340
/** Converts an enum of type E_SgMemberFunctionDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMemberFunctionDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMemberFunctionDeclaration_parameterList"; break;
        case 1: retval = "SgMemberFunctionDeclaration_definition"; break;
        case 2: retval = "SgMemberFunctionDeclaration_CtorInitializerList"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgMemberFunctionDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMemberFunctionDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgMemberFunctionSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:826
/** Converts an enum of type E_SgMemberFunctionSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMemberFunctionSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMemberFunctionSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgMemberFunctionSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMemberFunctionSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgMemberFunctionType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:142
/** Converts an enum of type E_SgMemberFunctionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMemberFunctionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMemberFunctionType_ref_to"; break;
        case 1: retval = "SgMemberFunctionType_ptr_to"; break;
        case 2: retval = "SgMemberFunctionType_modifiers"; break;
        case 3: retval = "SgMemberFunctionType_typedefs"; break;
        case 4: retval = "SgMemberFunctionType_type_kind"; break;
        case 5: retval = "SgMemberFunctionType_return_type"; break;
        case 6: retval = "SgMemberFunctionType_orig_return_type"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgMemberFunctionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMemberFunctionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgMinusAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:634
/** Converts an enum of type E_SgMinusAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMinusAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMinusAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgMinusAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgMinusAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMinusAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgMinusMinusOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:520
/** Converts an enum of type E_SgMinusMinusOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMinusMinusOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMinusMinusOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgMinusMinusOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMinusMinusOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgMinusOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:505
/** Converts an enum of type E_SgMinusOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMinusOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMinusOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgMinusOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMinusOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgModAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:649
/** Converts an enum of type E_SgModAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgModAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgModAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgModAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgModAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgModAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgModOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:595
/** Converts an enum of type E_SgModOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgModOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgModOp_lhs_operand_i"; break;
        case 1: retval = "SgModOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[73];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgModOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgModOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgModifierType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:133
/** Converts an enum of type E_SgModifierType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgModifierType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgModifierType_ref_to"; break;
        case 1: retval = "SgModifierType_ptr_to"; break;
        case 2: retval = "SgModifierType_modifiers"; break;
        case 3: retval = "SgModifierType_typedefs"; break;
        case 4: retval = "SgModifierType_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgModifierType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgModifierType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgModuleStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:328
/** Converts an enum of type E_SgModuleStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgModuleStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgModuleStatement_definition"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgModuleStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgModuleStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgModuleSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:853
/** Converts an enum of type E_SgModuleSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgModuleSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgModuleSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgModuleSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgModuleSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgMultAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:643
/** Converts an enum of type E_SgMultAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMultAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMultAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgMultAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgMultAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMultAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgMultiplyOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:586
/** Converts an enum of type E_SgMultiplyOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMultiplyOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMultiplyOp_lhs_operand_i"; break;
        case 1: retval = "SgMultiplyOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgMultiplyOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMultiplyOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgNamedType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:130
/** Converts an enum of type E_SgNamedType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNamedType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNamedType_ref_to"; break;
        case 1: retval = "SgNamedType_ptr_to"; break;
        case 2: retval = "SgNamedType_modifiers"; break;
        case 3: retval = "SgNamedType_typedefs"; break;
        case 4: retval = "SgNamedType_type_kind"; break;
        case 5: retval = "SgNamedType_builtin_type"; break;
        case 6: retval = "SgNamedType_declaration"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgNamedType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNamedType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgNamespaceDeclarationStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:301
/** Converts an enum of type E_SgNamespaceDeclarationStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNamespaceDeclarationStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNamespaceDeclarationStatement_definition"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgNamespaceDeclarationStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNamespaceDeclarationStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgNamespaceDefinitionStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:259
/** Converts an enum of type E_SgNamespaceDefinitionStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNamespaceDefinitionStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNamespaceDefinitionStatement_declarations"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgNamespaceDefinitionStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNamespaceDefinitionStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgNamespaceSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:850
/** Converts an enum of type E_SgNamespaceSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNamespaceSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNamespaceSymbol_declaration"; break;
        case 1: retval = "SgNamespaceSymbol_aliasDeclaration"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgNamespaceSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNamespaceSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgNewExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:763
/** Converts an enum of type E_SgNewExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNewExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNewExp_placement_args"; break;
        case 1: retval = "SgNewExp_constructor_args"; break;
        case 2: retval = "SgNewExp_builtin_args"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgNewExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNewExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgNotEqualOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:571
/** Converts an enum of type E_SgNotEqualOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNotEqualOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNotEqualOp_lhs_operand_i"; break;
        case 1: retval = "SgNotEqualOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgNotEqualOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNotEqualOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgNotOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:511
/** Converts an enum of type E_SgNotOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNotOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNotOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[73];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgNotOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNotOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgNullifyStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:427
/** Converts an enum of type E_SgNullifyStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNullifyStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNullifyStatement_pointer_list"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgNullifyStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNullifyStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpAtomicStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:460
/** Converts an enum of type E_SgOmpAtomicStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpAtomicStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpAtomicStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpAtomicStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpAtomicStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpBodyStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:499
/** Converts an enum of type E_SgOmpBodyStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpBodyStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpBodyStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpBodyStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpBodyStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpClauseBodyStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:496
/** Converts an enum of type E_SgOmpClauseBodyStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpClauseBodyStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpClauseBodyStatement_body"; break;
        case 1: retval = "SgOmpClauseBodyStatement_clauses"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpClauseBodyStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpClauseBodyStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpCollapseClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:187
/** Converts an enum of type E_SgOmpCollapseClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpCollapseClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpCollapseClause_expression"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpCollapseClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpCollapseClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpCopyinClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:211
/** Converts an enum of type E_SgOmpCopyinClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpCopyinClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpCopyinClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpCopyinClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpCopyinClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpCopyprivateClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:199
/** Converts an enum of type E_SgOmpCopyprivateClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpCopyprivateClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpCopyprivateClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpCopyprivateClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpCopyprivateClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpCriticalStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:469
/** Converts an enum of type E_SgOmpCriticalStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpCriticalStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpCriticalStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpCriticalStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpCriticalStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpDoStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:490
/** Converts an enum of type E_SgOmpDoStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpDoStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpDoStatement_body"; break;
        case 1: retval = "SgOmpDoStatement_clauses"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpDoStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpDoStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpExpressionClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:196
/** Converts an enum of type E_SgOmpExpressionClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpExpressionClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpExpressionClause_expression"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpExpressionClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpExpressionClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpFirstprivateClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:205
/** Converts an enum of type E_SgOmpFirstprivateClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpFirstprivateClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpFirstprivateClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpFirstprivateClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpFirstprivateClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpFlushStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:457
/** Converts an enum of type E_SgOmpFlushStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpFlushStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpFlushStatement_variables"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpFlushStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpFlushStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpForStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:487
/** Converts an enum of type E_SgOmpForStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpForStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpForStatement_body"; break;
        case 1: retval = "SgOmpForStatement_clauses"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpForStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpForStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpIfClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:190
/** Converts an enum of type E_SgOmpIfClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpIfClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpIfClause_expression"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpIfClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpIfClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpLastprivateClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:214
/** Converts an enum of type E_SgOmpLastprivateClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpLastprivateClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpLastprivateClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpLastprivateClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpLastprivateClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpMasterStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:463
/** Converts an enum of type E_SgOmpMasterStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpMasterStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpMasterStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpMasterStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpMasterStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpNumThreadsClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:193
/** Converts an enum of type E_SgOmpNumThreadsClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpNumThreadsClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpNumThreadsClause_expression"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpNumThreadsClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpNumThreadsClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpOrderedStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:466
/** Converts an enum of type E_SgOmpOrderedStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpOrderedStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpOrderedStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpOrderedStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpOrderedStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpParallelStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:478
/** Converts an enum of type E_SgOmpParallelStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpParallelStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpParallelStatement_body"; break;
        case 1: retval = "SgOmpParallelStatement_clauses"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpParallelStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpParallelStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpPrivateClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:202
/** Converts an enum of type E_SgOmpPrivateClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpPrivateClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpPrivateClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpPrivateClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpPrivateClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpReductionClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:217
/** Converts an enum of type E_SgOmpReductionClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpReductionClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpReductionClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpReductionClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpReductionClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpScheduleClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:223
/** Converts an enum of type E_SgOmpScheduleClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpScheduleClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpScheduleClause_chunk_size"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpScheduleClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpScheduleClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpSectionStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:472
/** Converts an enum of type E_SgOmpSectionStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpSectionStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpSectionStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpSectionStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpSectionStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpSectionsStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:493
/** Converts an enum of type E_SgOmpSectionsStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpSectionsStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpSectionsStatement_body"; break;
        case 1: retval = "SgOmpSectionsStatement_clauses"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpSectionsStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpSectionsStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpSharedClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:208
/** Converts an enum of type E_SgOmpSharedClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpSharedClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpSharedClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpSharedClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpSharedClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpSingleStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:481
/** Converts an enum of type E_SgOmpSingleStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpSingleStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpSingleStatement_body"; break;
        case 1: retval = "SgOmpSingleStatement_clauses"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpSingleStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpSingleStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpTaskStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:484
/** Converts an enum of type E_SgOmpTaskStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpTaskStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpTaskStatement_body"; break;
        case 1: retval = "SgOmpTaskStatement_clauses"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpTaskStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpTaskStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpThreadprivateStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:358
/** Converts an enum of type E_SgOmpThreadprivateStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpThreadprivateStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpThreadprivateStatement_variables"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpThreadprivateStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpThreadprivateStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpVariablesClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:220
/** Converts an enum of type E_SgOmpVariablesClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpVariablesClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpVariablesClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpVariablesClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpVariablesClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOmpWorkshareStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:475
/** Converts an enum of type E_SgOmpWorkshareStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpWorkshareStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpWorkshareStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOmpWorkshareStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpWorkshareStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOpenStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:394
/** Converts an enum of type E_SgOpenStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOpenStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOpenStatement_io_stmt_list"; break;
        case 1: retval = "SgOpenStatement_unit"; break;
        case 2: retval = "SgOpenStatement_iostat"; break;
        case 3: retval = "SgOpenStatement_err"; break;
        case 4: retval = "SgOpenStatement_iomsg"; break;
        case 5: retval = "SgOpenStatement_file"; break;
        case 6: retval = "SgOpenStatement_status"; break;
        case 7: retval = "SgOpenStatement_access"; break;
        case 8: retval = "SgOpenStatement_form"; break;
        case 9: retval = "SgOpenStatement_recl"; break;
        case 10: retval = "SgOpenStatement_blank"; break;
        case 11: retval = "SgOpenStatement_position"; break;
        case 12: retval = "SgOpenStatement_action"; break;
        case 13: retval = "SgOpenStatement_delim"; break;
        case 14: retval = "SgOpenStatement_pad"; break;
        case 15: retval = "SgOpenStatement_round"; break;
        case 16: retval = "SgOpenStatement_sign"; break;
        case 17: retval = "SgOpenStatement_asynchronous"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOpenStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOpenStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgOrOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:601
/** Converts an enum of type E_SgOrOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOrOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOrOp_lhs_operand_i"; break;
        case 1: retval = "SgOrOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[72];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgOrOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOrOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgPartialFunctionModifierType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:136
/** Converts an enum of type E_SgPartialFunctionModifierType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPartialFunctionModifierType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPartialFunctionModifierType_ref_to"; break;
        case 1: retval = "SgPartialFunctionModifierType_ptr_to"; break;
        case 2: retval = "SgPartialFunctionModifierType_modifiers"; break;
        case 3: retval = "SgPartialFunctionModifierType_typedefs"; break;
        case 4: retval = "SgPartialFunctionModifierType_type_kind"; break;
        case 5: retval = "SgPartialFunctionModifierType_return_type"; break;
        case 6: retval = "SgPartialFunctionModifierType_orig_return_type"; break;
        case 7: retval = "SgPartialFunctionModifierType_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgPartialFunctionModifierType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPartialFunctionModifierType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgPartialFunctionType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:139
/** Converts an enum of type E_SgPartialFunctionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPartialFunctionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPartialFunctionType_ref_to"; break;
        case 1: retval = "SgPartialFunctionType_ptr_to"; break;
        case 2: retval = "SgPartialFunctionType_modifiers"; break;
        case 3: retval = "SgPartialFunctionType_typedefs"; break;
        case 4: retval = "SgPartialFunctionType_type_kind"; break;
        case 5: retval = "SgPartialFunctionType_return_type"; break;
        case 6: retval = "SgPartialFunctionType_orig_return_type"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgPartialFunctionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPartialFunctionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgPlusAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:631
/** Converts an enum of type E_SgPlusAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPlusAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPlusAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgPlusAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgPlusAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPlusAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgPlusPlusOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:523
/** Converts an enum of type E_SgPlusPlusOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPlusPlusOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPlusPlusOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgPlusPlusOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPlusPlusOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgPntrArrRefExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:622
/** Converts an enum of type E_SgPntrArrRefExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPntrArrRefExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPntrArrRefExp_lhs_operand_i"; break;
        case 1: retval = "SgPntrArrRefExp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgPntrArrRefExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPntrArrRefExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgPointerAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:667
/** Converts an enum of type E_SgPointerAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPointerAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPointerAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgPointerAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgPointerAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPointerAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgPointerDerefExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:514
/** Converts an enum of type E_SgPointerDerefExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPointerDerefExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPointerDerefExp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgPointerDerefExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPointerDerefExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgPointerMemberType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:112
/** Converts an enum of type E_SgPointerMemberType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPointerMemberType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPointerMemberType_ref_to"; break;
        case 1: retval = "SgPointerMemberType_ptr_to"; break;
        case 2: retval = "SgPointerMemberType_modifiers"; break;
        case 3: retval = "SgPointerMemberType_typedefs"; break;
        case 4: retval = "SgPointerMemberType_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgPointerMemberType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPointerMemberType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgPointerType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:115
/** Converts an enum of type E_SgPointerType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPointerType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPointerType_ref_to"; break;
        case 1: retval = "SgPointerType_ptr_to"; break;
        case 2: retval = "SgPointerType_modifiers"; break;
        case 3: retval = "SgPointerType_typedefs"; break;
        case 4: retval = "SgPointerType_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgPointerType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPointerType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgPragmaDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:319
/** Converts an enum of type E_SgPragmaDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPragmaDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPragmaDeclaration_pragma"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgPragmaDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPragmaDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgPrintStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:385
/** Converts an enum of type E_SgPrintStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPrintStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPrintStatement_io_stmt_list"; break;
        case 1: retval = "SgPrintStatement_unit"; break;
        case 2: retval = "SgPrintStatement_iostat"; break;
        case 3: retval = "SgPrintStatement_err"; break;
        case 4: retval = "SgPrintStatement_iomsg"; break;
        case 5: retval = "SgPrintStatement_format"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgPrintStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPrintStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgProcedureHeaderStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:349
/** Converts an enum of type E_SgProcedureHeaderStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgProcedureHeaderStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgProcedureHeaderStatement_parameterList"; break;
        case 1: retval = "SgProcedureHeaderStatement_definition"; break;
        case 2: retval = "SgProcedureHeaderStatement_result_name"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgProcedureHeaderStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgProcedureHeaderStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgProgramHeaderStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:346
/** Converts an enum of type E_SgProgramHeaderStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgProgramHeaderStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgProgramHeaderStatement_parameterList"; break;
        case 1: retval = "SgProgramHeaderStatement_definition"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgProgramHeaderStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgProgramHeaderStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgProject is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:13
/** Converts an enum of type E_SgProject to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgProject(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgProject_fileList_ptr"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgProject)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgProject::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgQualifiedNameType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:157
/** Converts an enum of type E_SgQualifiedNameType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgQualifiedNameType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgQualifiedNameType_ref_to"; break;
        case 1: retval = "SgQualifiedNameType_ptr_to"; break;
        case 2: retval = "SgQualifiedNameType_modifiers"; break;
        case 3: retval = "SgQualifiedNameType_typedefs"; break;
        case 4: retval = "SgQualifiedNameType_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgQualifiedNameType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgQualifiedNameType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgReadStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:388
/** Converts an enum of type E_SgReadStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgReadStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgReadStatement_io_stmt_list"; break;
        case 1: retval = "SgReadStatement_unit"; break;
        case 2: retval = "SgReadStatement_iostat"; break;
        case 3: retval = "SgReadStatement_err"; break;
        case 4: retval = "SgReadStatement_iomsg"; break;
        case 5: retval = "SgReadStatement_format"; break;
        case 6: retval = "SgReadStatement_rec"; break;
        case 7: retval = "SgReadStatement_end"; break;
        case 8: retval = "SgReadStatement_namelist"; break;
        case 9: retval = "SgReadStatement_advance"; break;
        case 10: retval = "SgReadStatement_size"; break;
        case 11: retval = "SgReadStatement_eor"; break;
        case 12: retval = "SgReadStatement_asynchronous"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgReadStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgReadStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgRealPartOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:535
/** Converts an enum of type E_SgRealPartOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRealPartOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgRealPartOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgRealPartOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRealPartOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgReferenceType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:118
/** Converts an enum of type E_SgReferenceType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgReferenceType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgReferenceType_ref_to"; break;
        case 1: retval = "SgReferenceType_ptr_to"; break;
        case 2: retval = "SgReferenceType_modifiers"; break;
        case 3: retval = "SgReferenceType_typedefs"; break;
        case 4: retval = "SgReferenceType_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgReferenceType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgReferenceType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgRenameSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:829
/** Converts an enum of type E_SgRenameSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRenameSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgRenameSymbol_declaration"; break;
        case 1: retval = "SgRenameSymbol_original_symbol"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgRenameSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRenameSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgReturnStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:373
/** Converts an enum of type E_SgReturnStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgReturnStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgReturnStmt_expression"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgReturnStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgReturnStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgRewindStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:409
/** Converts an enum of type E_SgRewindStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRewindStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgRewindStatement_io_stmt_list"; break;
        case 1: retval = "SgRewindStatement_unit"; break;
        case 2: retval = "SgRewindStatement_iostat"; break;
        case 3: retval = "SgRewindStatement_err"; break;
        case 4: retval = "SgRewindStatement_iomsg"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgRewindStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRewindStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgRshiftAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:658
/** Converts an enum of type E_SgRshiftAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRshiftAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgRshiftAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgRshiftAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgRshiftAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRshiftAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgRshiftOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:619
/** Converts an enum of type E_SgRshiftOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRshiftOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgRshiftOp_lhs_operand_i"; break;
        case 1: retval = "SgRshiftOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgRshiftOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRshiftOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgScopeOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:625
/** Converts an enum of type E_SgScopeOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgScopeOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgScopeOp_lhs_operand_i"; break;
        case 1: retval = "SgScopeOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgScopeOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgScopeOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgShortVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:685
/** Converts an enum of type E_SgShortVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgShortVal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgShortVal_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgShortVal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgShortVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgSizeOfOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:745
/** Converts an enum of type E_SgSizeOfOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSizeOfOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgSizeOfOp_operand_expr"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgSizeOfOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSizeOfOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgSourceFile is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:4
/** Converts an enum of type E_SgSourceFile to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSourceFile(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgSourceFile_globalScope"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgSourceFile)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSourceFile::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgSpawnStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:376
/** Converts an enum of type E_SgSpawnStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSpawnStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgSpawnStmt_the_func"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgSpawnStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSpawnStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgStatementExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:805
/** Converts an enum of type E_SgStatementExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgStatementExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgStatementExpression_statement"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgStatementExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgStatementExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgStatementFunctionStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:313
/** Converts an enum of type E_SgStatementFunctionStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgStatementFunctionStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgStatementFunctionStatement_function"; break;
        case 1: retval = "SgStatementFunctionStatement_expression"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgStatementFunctionStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgStatementFunctionStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgStringVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:682
/** Converts an enum of type E_SgStringVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgStringVal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgStringVal_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgStringVal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgStringVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgSubscriptExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:796
/** Converts an enum of type E_SgSubscriptExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSubscriptExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgSubscriptExpression_lowerBound"; break;
        case 1: retval = "SgSubscriptExpression_upperBound"; break;
        case 2: retval = "SgSubscriptExpression_stride"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgSubscriptExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSubscriptExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgSubtractOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:583
/** Converts an enum of type E_SgSubtractOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSubtractOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgSubtractOp_lhs_operand_i"; break;
        case 1: retval = "SgSubtractOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgSubtractOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSubtractOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgSwitchStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:253
/** Converts an enum of type E_SgSwitchStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSwitchStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgSwitchStatement_item_selector"; break;
        case 1: retval = "SgSwitchStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgSwitchStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSwitchStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTemplateArgument is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:22
/** Converts an enum of type E_SgTemplateArgument to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateArgument(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateArgument_expression"; break;
        case 1: retval = "SgTemplateArgument_templateDeclaration"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTemplateArgument)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateArgument::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTemplateArgumentList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:34
/** Converts an enum of type E_SgTemplateArgumentList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateArgumentList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateArgumentList_args"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTemplateArgumentList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateArgumentList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTemplateInstantiationDecl is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:322
/** Converts an enum of type E_SgTemplateInstantiationDecl to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateInstantiationDecl(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateInstantiationDecl_definition"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTemplateInstantiationDecl)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateInstantiationDecl::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTemplateInstantiationDefn is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:241
/** Converts an enum of type E_SgTemplateInstantiationDefn to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateInstantiationDefn(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateInstantiationDefn_members"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTemplateInstantiationDefn)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateInstantiationDefn::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTemplateInstantiationDirectiveStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:295
/** Converts an enum of type E_SgTemplateInstantiationDirectiveStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateInstantiationDirectiveStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateInstantiationDirectiveStatement_declaration"; break;
    }
    if (retval.empty()) {
        char buf[107];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTemplateInstantiationDirectiveStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateInstantiationDirectiveStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTemplateInstantiationFunctionDecl is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:343
/** Converts an enum of type E_SgTemplateInstantiationFunctionDecl to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateInstantiationFunctionDecl(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateInstantiationFunctionDecl_parameterList"; break;
        case 1: retval = "SgTemplateInstantiationFunctionDecl_definition"; break;
    }
    if (retval.empty()) {
        char buf[101];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTemplateInstantiationFunctionDecl)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateInstantiationFunctionDecl::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTemplateInstantiationMemberFunctionDecl is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:337
/** Converts an enum of type E_SgTemplateInstantiationMemberFunctionDecl to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateInstantiationMemberFunctionDecl(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateInstantiationMemberFunctionDecl_parameterList"; break;
        case 1: retval = "SgTemplateInstantiationMemberFunctionDecl_definition"; break;
        case 2: retval = "SgTemplateInstantiationMemberFunctionDecl_CtorInitializerList"; break;
    }
    if (retval.empty()) {
        char buf[107];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTemplateInstantiationMemberFunctionDecl)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateInstantiationMemberFunctionDecl::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTemplateParameter is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:19
/** Converts an enum of type E_SgTemplateParameter to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateParameter(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateParameter_expression"; break;
        case 1: retval = "SgTemplateParameter_defaultExpressionParameter"; break;
        case 2: retval = "SgTemplateParameter_templateDeclaration"; break;
        case 3: retval = "SgTemplateParameter_defaultTemplateDeclarationParameter"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTemplateParameter)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateParameter::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTemplateParameterList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:37
/** Converts an enum of type E_SgTemplateParameterList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateParameterList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateParameterList_args"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTemplateParameterList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateParameterList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTemplateSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:838
/** Converts an enum of type E_SgTemplateSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTemplateSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTemplateType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:154
/** Converts an enum of type E_SgTemplateType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateType_ref_to"; break;
        case 1: retval = "SgTemplateType_ptr_to"; break;
        case 2: retval = "SgTemplateType_modifiers"; break;
        case 3: retval = "SgTemplateType_typedefs"; break;
        case 4: retval = "SgTemplateType_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTemplateType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgThrowOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:532
/** Converts an enum of type E_SgThrowOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgThrowOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgThrowOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgThrowOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgThrowOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTryStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:367
/** Converts an enum of type E_SgTryStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTryStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTryStmt_body"; break;
        case 1: retval = "SgTryStmt_catch_statement_seq_root"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTryStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTryStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:178
/** Converts an enum of type E_SgType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgType_ref_to"; break;
        case 1: retval = "SgType_ptr_to"; break;
        case 2: retval = "SgType_modifiers"; break;
        case 3: retval = "SgType_typedefs"; break;
        case 4: retval = "SgType_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[72];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeBool is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:109
/** Converts an enum of type E_SgTypeBool to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeBool(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeBool_ref_to"; break;
        case 1: retval = "SgTypeBool_ptr_to"; break;
        case 2: retval = "SgTypeBool_modifiers"; break;
        case 3: retval = "SgTypeBool_typedefs"; break;
        case 4: retval = "SgTypeBool_type_kind"; break;
        case 5: retval = "SgTypeBool_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeBool)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeBool::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeCAFTeam is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:169
/** Converts an enum of type E_SgTypeCAFTeam to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeCAFTeam(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeCAFTeam_ref_to"; break;
        case 1: retval = "SgTypeCAFTeam_ptr_to"; break;
        case 2: retval = "SgTypeCAFTeam_modifiers"; break;
        case 3: retval = "SgTypeCAFTeam_typedefs"; break;
        case 4: retval = "SgTypeCAFTeam_type_kind"; break;
        case 5: retval = "SgTypeCAFTeam_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeCAFTeam)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeCAFTeam::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeChar is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:43
/** Converts an enum of type E_SgTypeChar to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeChar(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeChar_ref_to"; break;
        case 1: retval = "SgTypeChar_ptr_to"; break;
        case 2: retval = "SgTypeChar_modifiers"; break;
        case 3: retval = "SgTypeChar_typedefs"; break;
        case 4: retval = "SgTypeChar_type_kind"; break;
        case 5: retval = "SgTypeChar_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeChar)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeChar::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeComplex is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:160
/** Converts an enum of type E_SgTypeComplex to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeComplex(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeComplex_ref_to"; break;
        case 1: retval = "SgTypeComplex_ptr_to"; break;
        case 2: retval = "SgTypeComplex_modifiers"; break;
        case 3: retval = "SgTypeComplex_typedefs"; break;
        case 4: retval = "SgTypeComplex_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeComplex)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeComplex::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeCrayPointer is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:172
/** Converts an enum of type E_SgTypeCrayPointer to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeCrayPointer(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeCrayPointer_ref_to"; break;
        case 1: retval = "SgTypeCrayPointer_ptr_to"; break;
        case 2: retval = "SgTypeCrayPointer_modifiers"; break;
        case 3: retval = "SgTypeCrayPointer_typedefs"; break;
        case 4: retval = "SgTypeCrayPointer_type_kind"; break;
        case 5: retval = "SgTypeCrayPointer_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeCrayPointer)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeCrayPointer::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeDefault is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:166
/** Converts an enum of type E_SgTypeDefault to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeDefault(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeDefault_ref_to"; break;
        case 1: retval = "SgTypeDefault_ptr_to"; break;
        case 2: retval = "SgTypeDefault_modifiers"; break;
        case 3: retval = "SgTypeDefault_typedefs"; break;
        case 4: retval = "SgTypeDefault_type_kind"; break;
        case 5: retval = "SgTypeDefault_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeDefault)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeDefault::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeDouble is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:91
/** Converts an enum of type E_SgTypeDouble to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeDouble(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeDouble_ref_to"; break;
        case 1: retval = "SgTypeDouble_ptr_to"; break;
        case 2: retval = "SgTypeDouble_modifiers"; break;
        case 3: retval = "SgTypeDouble_typedefs"; break;
        case 4: retval = "SgTypeDouble_type_kind"; break;
        case 5: retval = "SgTypeDouble_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeDouble)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeDouble::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeEllipse is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:151
/** Converts an enum of type E_SgTypeEllipse to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeEllipse(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeEllipse_ref_to"; break;
        case 1: retval = "SgTypeEllipse_ptr_to"; break;
        case 2: retval = "SgTypeEllipse_modifiers"; break;
        case 3: retval = "SgTypeEllipse_typedefs"; break;
        case 4: retval = "SgTypeEllipse_type_kind"; break;
        case 5: retval = "SgTypeEllipse_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeEllipse)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeEllipse::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeFloat is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:88
/** Converts an enum of type E_SgTypeFloat to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeFloat(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeFloat_ref_to"; break;
        case 1: retval = "SgTypeFloat_ptr_to"; break;
        case 2: retval = "SgTypeFloat_modifiers"; break;
        case 3: retval = "SgTypeFloat_typedefs"; break;
        case 4: retval = "SgTypeFloat_type_kind"; break;
        case 5: retval = "SgTypeFloat_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeFloat)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeFloat::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeGlobalVoid is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:82
/** Converts an enum of type E_SgTypeGlobalVoid to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeGlobalVoid(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeGlobalVoid_ref_to"; break;
        case 1: retval = "SgTypeGlobalVoid_ptr_to"; break;
        case 2: retval = "SgTypeGlobalVoid_modifiers"; break;
        case 3: retval = "SgTypeGlobalVoid_typedefs"; break;
        case 4: retval = "SgTypeGlobalVoid_type_kind"; break;
        case 5: retval = "SgTypeGlobalVoid_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeGlobalVoid)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeGlobalVoid::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeIdOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:757
/** Converts an enum of type E_SgTypeIdOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeIdOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeIdOp_operand_expr"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeIdOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeIdOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeImaginary is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:163
/** Converts an enum of type E_SgTypeImaginary to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeImaginary(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeImaginary_ref_to"; break;
        case 1: retval = "SgTypeImaginary_ptr_to"; break;
        case 2: retval = "SgTypeImaginary_modifiers"; break;
        case 3: retval = "SgTypeImaginary_typedefs"; break;
        case 4: retval = "SgTypeImaginary_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeImaginary)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeImaginary::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeInt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:61
/** Converts an enum of type E_SgTypeInt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeInt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeInt_ref_to"; break;
        case 1: retval = "SgTypeInt_ptr_to"; break;
        case 2: retval = "SgTypeInt_modifiers"; break;
        case 3: retval = "SgTypeInt_typedefs"; break;
        case 4: retval = "SgTypeInt_type_kind"; break;
        case 5: retval = "SgTypeInt_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeInt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeInt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeLabel is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:175
/** Converts an enum of type E_SgTypeLabel to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeLabel(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeLabel_ref_to"; break;
        case 1: retval = "SgTypeLabel_ptr_to"; break;
        case 2: retval = "SgTypeLabel_modifiers"; break;
        case 3: retval = "SgTypeLabel_typedefs"; break;
        case 4: retval = "SgTypeLabel_type_kind"; break;
        case 5: retval = "SgTypeLabel_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeLabel)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeLabel::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeLong is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:70
/** Converts an enum of type E_SgTypeLong to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeLong(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeLong_ref_to"; break;
        case 1: retval = "SgTypeLong_ptr_to"; break;
        case 2: retval = "SgTypeLong_modifiers"; break;
        case 3: retval = "SgTypeLong_typedefs"; break;
        case 4: retval = "SgTypeLong_type_kind"; break;
        case 5: retval = "SgTypeLong_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeLong)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeLong::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeLongDouble is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:103
/** Converts an enum of type E_SgTypeLongDouble to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeLongDouble(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeLongDouble_ref_to"; break;
        case 1: retval = "SgTypeLongDouble_ptr_to"; break;
        case 2: retval = "SgTypeLongDouble_modifiers"; break;
        case 3: retval = "SgTypeLongDouble_typedefs"; break;
        case 4: retval = "SgTypeLongDouble_type_kind"; break;
        case 5: retval = "SgTypeLongDouble_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeLongDouble)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeLongDouble::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeLongLong is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:94
/** Converts an enum of type E_SgTypeLongLong to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeLongLong(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeLongLong_ref_to"; break;
        case 1: retval = "SgTypeLongLong_ptr_to"; break;
        case 2: retval = "SgTypeLongLong_modifiers"; break;
        case 3: retval = "SgTypeLongLong_typedefs"; break;
        case 4: retval = "SgTypeLongLong_type_kind"; break;
        case 5: retval = "SgTypeLongLong_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeLongLong)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeLongLong::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeShort is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:52
/** Converts an enum of type E_SgTypeShort to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeShort(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeShort_ref_to"; break;
        case 1: retval = "SgTypeShort_ptr_to"; break;
        case 2: retval = "SgTypeShort_modifiers"; break;
        case 3: retval = "SgTypeShort_typedefs"; break;
        case 4: retval = "SgTypeShort_type_kind"; break;
        case 5: retval = "SgTypeShort_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeShort)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeShort::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeSignedChar is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:46
/** Converts an enum of type E_SgTypeSignedChar to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeSignedChar(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeSignedChar_ref_to"; break;
        case 1: retval = "SgTypeSignedChar_ptr_to"; break;
        case 2: retval = "SgTypeSignedChar_modifiers"; break;
        case 3: retval = "SgTypeSignedChar_typedefs"; break;
        case 4: retval = "SgTypeSignedChar_type_kind"; break;
        case 5: retval = "SgTypeSignedChar_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeSignedChar)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeSignedChar::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeSignedInt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:64
/** Converts an enum of type E_SgTypeSignedInt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeSignedInt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeSignedInt_ref_to"; break;
        case 1: retval = "SgTypeSignedInt_ptr_to"; break;
        case 2: retval = "SgTypeSignedInt_modifiers"; break;
        case 3: retval = "SgTypeSignedInt_typedefs"; break;
        case 4: retval = "SgTypeSignedInt_type_kind"; break;
        case 5: retval = "SgTypeSignedInt_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeSignedInt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeSignedInt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeSignedLong is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:73
/** Converts an enum of type E_SgTypeSignedLong to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeSignedLong(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeSignedLong_ref_to"; break;
        case 1: retval = "SgTypeSignedLong_ptr_to"; break;
        case 2: retval = "SgTypeSignedLong_modifiers"; break;
        case 3: retval = "SgTypeSignedLong_typedefs"; break;
        case 4: retval = "SgTypeSignedLong_type_kind"; break;
        case 5: retval = "SgTypeSignedLong_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeSignedLong)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeSignedLong::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeSignedLongLong is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:97
/** Converts an enum of type E_SgTypeSignedLongLong to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeSignedLongLong(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeSignedLongLong_ref_to"; break;
        case 1: retval = "SgTypeSignedLongLong_ptr_to"; break;
        case 2: retval = "SgTypeSignedLongLong_modifiers"; break;
        case 3: retval = "SgTypeSignedLongLong_typedefs"; break;
        case 4: retval = "SgTypeSignedLongLong_type_kind"; break;
        case 5: retval = "SgTypeSignedLongLong_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeSignedLongLong)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeSignedLongLong::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeSignedShort is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:55
/** Converts an enum of type E_SgTypeSignedShort to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeSignedShort(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeSignedShort_ref_to"; break;
        case 1: retval = "SgTypeSignedShort_ptr_to"; break;
        case 2: retval = "SgTypeSignedShort_modifiers"; break;
        case 3: retval = "SgTypeSignedShort_typedefs"; break;
        case 4: retval = "SgTypeSignedShort_type_kind"; break;
        case 5: retval = "SgTypeSignedShort_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeSignedShort)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeSignedShort::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeString is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:106
/** Converts an enum of type E_SgTypeString to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeString(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeString_ref_to"; break;
        case 1: retval = "SgTypeString_ptr_to"; break;
        case 2: retval = "SgTypeString_modifiers"; break;
        case 3: retval = "SgTypeString_typedefs"; break;
        case 4: retval = "SgTypeString_type_kind"; break;
        case 5: retval = "SgTypeString_lengthExpression"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeString)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeString::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeUnknown is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:40
/** Converts an enum of type E_SgTypeUnknown to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnknown(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeUnknown_ref_to"; break;
        case 1: retval = "SgTypeUnknown_ptr_to"; break;
        case 2: retval = "SgTypeUnknown_modifiers"; break;
        case 3: retval = "SgTypeUnknown_typedefs"; break;
        case 4: retval = "SgTypeUnknown_type_kind"; break;
        case 5: retval = "SgTypeUnknown_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeUnknown)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnknown::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeUnsignedChar is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:49
/** Converts an enum of type E_SgTypeUnsignedChar to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnsignedChar(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeUnsignedChar_ref_to"; break;
        case 1: retval = "SgTypeUnsignedChar_ptr_to"; break;
        case 2: retval = "SgTypeUnsignedChar_modifiers"; break;
        case 3: retval = "SgTypeUnsignedChar_typedefs"; break;
        case 4: retval = "SgTypeUnsignedChar_type_kind"; break;
        case 5: retval = "SgTypeUnsignedChar_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeUnsignedChar)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnsignedChar::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeUnsignedInt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:67
/** Converts an enum of type E_SgTypeUnsignedInt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnsignedInt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeUnsignedInt_ref_to"; break;
        case 1: retval = "SgTypeUnsignedInt_ptr_to"; break;
        case 2: retval = "SgTypeUnsignedInt_modifiers"; break;
        case 3: retval = "SgTypeUnsignedInt_typedefs"; break;
        case 4: retval = "SgTypeUnsignedInt_type_kind"; break;
        case 5: retval = "SgTypeUnsignedInt_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeUnsignedInt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnsignedInt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeUnsignedLong is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:76
/** Converts an enum of type E_SgTypeUnsignedLong to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnsignedLong(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeUnsignedLong_ref_to"; break;
        case 1: retval = "SgTypeUnsignedLong_ptr_to"; break;
        case 2: retval = "SgTypeUnsignedLong_modifiers"; break;
        case 3: retval = "SgTypeUnsignedLong_typedefs"; break;
        case 4: retval = "SgTypeUnsignedLong_type_kind"; break;
        case 5: retval = "SgTypeUnsignedLong_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeUnsignedLong)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnsignedLong::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeUnsignedLongLong is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:100
/** Converts an enum of type E_SgTypeUnsignedLongLong to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnsignedLongLong(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeUnsignedLongLong_ref_to"; break;
        case 1: retval = "SgTypeUnsignedLongLong_ptr_to"; break;
        case 2: retval = "SgTypeUnsignedLongLong_modifiers"; break;
        case 3: retval = "SgTypeUnsignedLongLong_typedefs"; break;
        case 4: retval = "SgTypeUnsignedLongLong_type_kind"; break;
        case 5: retval = "SgTypeUnsignedLongLong_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeUnsignedLongLong)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnsignedLongLong::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeUnsignedShort is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:58
/** Converts an enum of type E_SgTypeUnsignedShort to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnsignedShort(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeUnsignedShort_ref_to"; break;
        case 1: retval = "SgTypeUnsignedShort_ptr_to"; break;
        case 2: retval = "SgTypeUnsignedShort_modifiers"; break;
        case 3: retval = "SgTypeUnsignedShort_typedefs"; break;
        case 4: retval = "SgTypeUnsignedShort_type_kind"; break;
        case 5: retval = "SgTypeUnsignedShort_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeUnsignedShort)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnsignedShort::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeVoid is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:79
/** Converts an enum of type E_SgTypeVoid to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeVoid(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeVoid_ref_to"; break;
        case 1: retval = "SgTypeVoid_ptr_to"; break;
        case 2: retval = "SgTypeVoid_modifiers"; break;
        case 3: retval = "SgTypeVoid_typedefs"; break;
        case 4: retval = "SgTypeVoid_type_kind"; break;
        case 5: retval = "SgTypeVoid_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeVoid)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeVoid::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypeWchar is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:85
/** Converts an enum of type E_SgTypeWchar to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeWchar(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeWchar_ref_to"; break;
        case 1: retval = "SgTypeWchar_ptr_to"; break;
        case 2: retval = "SgTypeWchar_modifiers"; break;
        case 3: retval = "SgTypeWchar_typedefs"; break;
        case 4: retval = "SgTypeWchar_type_kind"; break;
        case 5: retval = "SgTypeWchar_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypeWchar)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeWchar::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypedefDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:310
/** Converts an enum of type E_SgTypedefDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypedefDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypedefDeclaration_declaration"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypedefDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypedefDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypedefSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:844
/** Converts an enum of type E_SgTypedefSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypedefSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypedefSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypedefSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypedefSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgTypedefType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:127
/** Converts an enum of type E_SgTypedefType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypedefType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypedefType_ref_to"; break;
        case 1: retval = "SgTypedefType_ptr_to"; break;
        case 2: retval = "SgTypedefType_modifiers"; break;
        case 3: retval = "SgTypedefType_typedefs"; break;
        case 4: retval = "SgTypedefType_type_kind"; break;
        case 5: retval = "SgTypedefType_builtin_type"; break;
        case 6: retval = "SgTypedefType_declaration"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgTypedefType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypedefType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUnaryAddOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:508
/** Converts an enum of type E_SgUnaryAddOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUnaryAddOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUnaryAddOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUnaryAddOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUnaryAddOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUnaryOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:547
/** Converts an enum of type E_SgUnaryOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUnaryOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUnaryOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUnaryOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUnaryOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUnknownArrayOrFunctionReference is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:814
/** Converts an enum of type E_SgUnknownArrayOrFunctionReference to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUnknownArrayOrFunctionReference(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUnknownArrayOrFunctionReference_named_reference"; break;
        case 1: retval = "SgUnknownArrayOrFunctionReference_expression_list"; break;
    }
    if (retval.empty()) {
        char buf[99];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUnknownArrayOrFunctionReference)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUnknownArrayOrFunctionReference::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUnknownFile is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:10
/** Converts an enum of type E_SgUnknownFile to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUnknownFile(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUnknownFile_globalScope"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUnknownFile)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUnknownFile::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUnsignedCharVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:691
/** Converts an enum of type E_SgUnsignedCharVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUnsignedCharVal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUnsignedCharVal_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUnsignedCharVal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUnsignedCharVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUnsignedIntVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:706
/** Converts an enum of type E_SgUnsignedIntVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUnsignedIntVal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUnsignedIntVal_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUnsignedIntVal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUnsignedIntVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUnsignedLongLongIntVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:715
/** Converts an enum of type E_SgUnsignedLongLongIntVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUnsignedLongLongIntVal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUnsignedLongLongIntVal_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUnsignedLongLongIntVal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUnsignedLongLongIntVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUnsignedLongVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:718
/** Converts an enum of type E_SgUnsignedLongVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUnsignedLongVal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUnsignedLongVal_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUnsignedLongVal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUnsignedLongVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUnsignedShortVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:697
/** Converts an enum of type E_SgUnsignedShortVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUnsignedShortVal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUnsignedShortVal_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUnsignedShortVal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUnsignedShortVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUpcBarrierStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:454
/** Converts an enum of type E_SgUpcBarrierStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcBarrierStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUpcBarrierStatement_barrier_expression"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUpcBarrierStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcBarrierStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUpcBlocksizeofExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:751
/** Converts an enum of type E_SgUpcBlocksizeofExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcBlocksizeofExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUpcBlocksizeofExpression_expression"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUpcBlocksizeofExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcBlocksizeofExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUpcElemsizeofExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:754
/** Converts an enum of type E_SgUpcElemsizeofExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcElemsizeofExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUpcElemsizeofExpression_expression"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUpcElemsizeofExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcElemsizeofExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUpcForAllStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:274
/** Converts an enum of type E_SgUpcForAllStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcForAllStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUpcForAllStatement_for_init_stmt"; break;
        case 1: retval = "SgUpcForAllStatement_test"; break;
        case 2: retval = "SgUpcForAllStatement_increment"; break;
        case 3: retval = "SgUpcForAllStatement_affinity"; break;
        case 4: retval = "SgUpcForAllStatement_loop_body"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUpcForAllStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcForAllStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUpcLocalsizeofExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:748
/** Converts an enum of type E_SgUpcLocalsizeofExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcLocalsizeofExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUpcLocalsizeofExpression_expression"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUpcLocalsizeofExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcLocalsizeofExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUpcMythread is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:736
/** Converts an enum of type E_SgUpcMythread to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcMythread(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUpcMythread_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUpcMythread)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcMythread::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUpcNotifyStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:448
/** Converts an enum of type E_SgUpcNotifyStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcNotifyStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUpcNotifyStatement_notify_expression"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUpcNotifyStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcNotifyStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUpcThreads is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:733
/** Converts an enum of type E_SgUpcThreads to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcThreads(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUpcThreads_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUpcThreads)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcThreads::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUpcWaitStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:451
/** Converts an enum of type E_SgUpcWaitStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcWaitStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUpcWaitStatement_wait_expression"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUpcWaitStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcWaitStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUseStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:298
/** Converts an enum of type E_SgUseStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUseStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUseStatement_rename_list"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUseStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUseStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUserDefinedBinaryOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:670
/** Converts an enum of type E_SgUserDefinedBinaryOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUserDefinedBinaryOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUserDefinedBinaryOp_lhs_operand_i"; break;
        case 1: retval = "SgUserDefinedBinaryOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUserDefinedBinaryOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUserDefinedBinaryOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgUserDefinedUnaryOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:544
/** Converts an enum of type E_SgUserDefinedUnaryOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUserDefinedUnaryOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUserDefinedUnaryOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgUserDefinedUnaryOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUserDefinedUnaryOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgValueExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:739
/** Converts an enum of type E_SgValueExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgValueExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgValueExp_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgValueExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgValueExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgVarArgCopyOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:790
/** Converts an enum of type E_SgVarArgCopyOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVarArgCopyOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgVarArgCopyOp_lhs_operand"; break;
        case 1: retval = "SgVarArgCopyOp_rhs_operand"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgVarArgCopyOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVarArgCopyOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgVarArgEndOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:787
/** Converts an enum of type E_SgVarArgEndOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVarArgEndOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgVarArgEndOp_operand_expr"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgVarArgEndOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVarArgEndOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgVarArgOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:784
/** Converts an enum of type E_SgVarArgOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVarArgOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgVarArgOp_operand_expr"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgVarArgOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVarArgOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgVarArgStartOneOperandOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:793
/** Converts an enum of type E_SgVarArgStartOneOperandOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVarArgStartOneOperandOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgVarArgStartOneOperandOp_operand_expr"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgVarArgStartOneOperandOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVarArgStartOneOperandOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgVarArgStartOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:781
/** Converts an enum of type E_SgVarArgStartOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVarArgStartOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgVarArgStartOp_lhs_operand"; break;
        case 1: retval = "SgVarArgStartOp_rhs_operand"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgVarArgStartOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVarArgStartOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgVariableDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:283
/** Converts an enum of type E_SgVariableDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVariableDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgVariableDeclaration_baseTypeDefiningDeclaration"; break;
        case 1: retval = "SgVariableDeclaration_variables"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgVariableDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVariableDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgVariableDefinition is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:286
/** Converts an enum of type E_SgVariableDefinition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVariableDefinition(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgVariableDefinition_vardefn"; break;
        case 1: retval = "SgVariableDefinition_bitfield"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgVariableDefinition)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVariableDefinition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgWaitStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:415
/** Converts an enum of type E_SgWaitStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgWaitStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgWaitStatement_io_stmt_list"; break;
        case 1: retval = "SgWaitStatement_unit"; break;
        case 2: retval = "SgWaitStatement_iostat"; break;
        case 3: retval = "SgWaitStatement_err"; break;
        case 4: retval = "SgWaitStatement_iomsg"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgWaitStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgWaitStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgWcharVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:694
/** Converts an enum of type E_SgWcharVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgWcharVal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgWcharVal_originalExpressionTree"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgWcharVal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgWcharVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgWhereStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:421
/** Converts an enum of type E_SgWhereStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgWhereStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgWhereStatement_condition"; break;
        case 1: retval = "SgWhereStatement_body"; break;
        case 2: retval = "SgWhereStatement_elsewhere"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgWhereStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgWhereStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgWhileStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:247
/** Converts an enum of type E_SgWhileStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgWhileStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgWhileStmt_condition"; break;
        case 1: retval = "SgWhileStmt_body"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgWhileStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgWhileStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgWriteStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:391
/** Converts an enum of type E_SgWriteStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgWriteStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgWriteStatement_io_stmt_list"; break;
        case 1: retval = "SgWriteStatement_unit"; break;
        case 2: retval = "SgWriteStatement_iostat"; break;
        case 3: retval = "SgWriteStatement_err"; break;
        case 4: retval = "SgWriteStatement_iomsg"; break;
        case 5: retval = "SgWriteStatement_format"; break;
        case 6: retval = "SgWriteStatement_rec"; break;
        case 7: retval = "SgWriteStatement_namelist"; break;
        case 8: retval = "SgWriteStatement_advance"; break;
        case 9: retval = "SgWriteStatement_asynchronous"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgWriteStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgWriteStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// E_SgXorAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:652
/** Converts an enum of type E_SgXorAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgXorAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgXorAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgXorAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(E_SgXorAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgXorAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// Format_Opt is defined at src/backend/unparser/formatSupport/unparse_format.h:52
/** Converts an enum of type Format_Opt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyFormat_Opt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FORMAT_BEFORE_DIRECTIVE"; break;
        case 1: retval = "FORMAT_AFTER_DIRECTIVE"; break;
        case 2: retval = "FORMAT_BEFORE_STMT"; break;
        case 3: retval = "FORMAT_AFTER_STMT"; break;
        case 4: retval = "FORMAT_BEFORE_BASIC_BLOCK1"; break;
        case 5: retval = "FORMAT_AFTER_BASIC_BLOCK1"; break;
        case 6: retval = "FORMAT_BEFORE_BASIC_BLOCK2"; break;
        case 7: retval = "FORMAT_AFTER_BASIC_BLOCK2"; break;
        case 8: retval = "FORMAT_BEFORE_NESTED_STATEMENT"; break;
        case 9: retval = "FORMAT_AFTER_NESTED_STATEMENT"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(Format_Opt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Format_Opt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// GenRepresentation::TypeOfPrint is defined at src/roseExtensions/dataStructureTraversal/GenRepresentation.h:24
/** Converts an enum of type GenRepresentation::TypeOfPrint to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyGenRepresentationTypeOfPrint(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElement"; break;
        case 1: retval = "Container"; break;
        case 2: retval = "Contained"; break;
        case 3: retval = "END_OF_LIST"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(GenRepresentation::TypeOfPrint)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "GenRepresentation::TypeOfPrint::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum is defined at src/midend/astRewriteMechanism/rewrite.h:177
/** Converts an enum of type HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyHighLevelCollectionTypedefsIntermediateFileStringPosition_Enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "unknownIntermediatePositionInScope"; break;
        case 1: retval = "GlobalScopePreamble"; break;
        case 2: retval = "GlobalScopeTopOfScope"; break;
        case 3: retval = "GlobalScopeTopOfIncludeRegion"; break;
        case 4: retval = "GlobalScopeBottomOfIncludeRegion"; break;
        case 5: retval = "GlobalScopeBeforeCurrentPosition"; break;
        case 6: retval = "GlobalScopeReplaceCurrentPosition"; break;
        case 7: retval = "FunctionScopePreamble"; break;
        case 8: retval = "FunctionScopeTopOfScope"; break;
        case 9: retval = "FunctionScopeBeforeCurrentPosition"; break;
        case 10: retval = "FunctionScopeReplaceCurrentPosition"; break;
        case 11: retval = "FunctionScopeAfterCurrentPosition"; break;
        case 12: retval = "FunctionScopeBottomOfScope"; break;
        case 13: retval = "GlobalScopeAfterCurrentPosition"; break;
        case 14: retval = "GlobalScopeBottomOfScope"; break;
        case 15: retval = "LAST_INTERMEDIATE_SOURCE_CODE_PLACEMENT_TAG"; break;
    }
    if (retval.empty()) {
        char buf[128];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// HighLevelCollectionTypedefs::PlacementPosition_Enum is defined at src/midend/astRewriteMechanism/rewrite.h:163
/** Converts an enum of type HighLevelCollectionTypedefs::PlacementPosition_Enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyHighLevelCollectionTypedefsPlacementPosition_Enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "unknownPositionInScope"; break;
        case 1: retval = "PreamblePositionInScope"; break;
        case 2: retval = "TopOfScope"; break;
        case 3: retval = "TopOfIncludeRegion"; break;
        case 4: retval = "BottomOfIncludeRegion"; break;
        case 5: retval = "BeforeCurrentPosition"; break;
        case 6: retval = "ReplaceCurrentPosition"; break;
        case 7: retval = "AfterCurrentPosition"; break;
        case 8: retval = "BottomOfScope"; break;
        case 9: retval = "LAST_PLACEMENT_TAG"; break;
    }
    if (retval.empty()) {
        char buf[115];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(HighLevelCollectionTypedefs::PlacementPosition_Enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "HighLevelCollectionTypedefs::PlacementPosition_Enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// HighLevelCollectionTypedefs::ScopeIdentifier_Enum is defined at src/midend/astRewriteMechanism/rewrite.h:142
/** Converts an enum of type HighLevelCollectionTypedefs::ScopeIdentifier_Enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyHighLevelCollectionTypedefsScopeIdentifier_Enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "unknownScope"; break;
        case 1: retval = "SurroundingScope"; break;
        case 2: retval = "ParentScope"; break;
        case 3: retval = "NestedLoopScope"; break;
        case 4: retval = "NestedConditionalScope"; break;
        case 5: retval = "FunctionScope"; break;
        case 6: retval = "FileScope"; break;
        case 7: retval = "GlobalScope"; break;
        case 8: retval = "Preamble"; break;
        case 9: retval = "LAST_SCOPE_TAG"; break;
    }
    if (retval.empty()) {
        char buf[113];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(HighLevelCollectionTypedefs::ScopeIdentifier_Enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "HighLevelCollectionTypedefs::ScopeIdentifier_Enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// IRProcType is defined at src/midend/programAnalysis/OpenAnalysis/Interface/IRInterface.h:164
/** Converts an enum of type IRProcType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyIRProcType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ProcType_PGM"; break;
        case 1: retval = "ProcType_SUB"; break;
        case 2: retval = "ProcType_FUNC"; break;
        case 3: retval = "ProcType_BDATA"; break;
        case 4: retval = "ProcType_ILLEGAL"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(IRProcType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "IRProcType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// IRStmtType is defined at src/midend/programAnalysis/OpenAnalysis/Interface/IRInterface.h:174
/** Converts an enum of type IRStmtType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyIRStmtType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SIMPLE"; break;
        case 1: retval = "COMPOUND"; break;
        case 2: retval = "LOOP"; break;
        case 3: retval = "END_TESTED_LOOP"; break;
        case 4: retval = "STRUCT_TWOWAY_CONDITIONAL"; break;
        case 5: retval = "STRUCT_MULTIWAY_CONDITIONAL"; break;
        case 6: retval = "USTRUCT_TWOWAY_CONDITIONAL_T"; break;
        case 7: retval = "USTRUCT_TWOWAY_CONDITIONAL_F"; break;
        case 8: retval = "USTRUCT_MULTIWAY_CONDITIONAL"; break;
        case 9: retval = "RETURN"; break;
        case 10: retval = "BREAK"; break;
        case 11: retval = "LOOP_CONTINUE"; break;
        case 12: retval = "ALTERNATE_PROC_ENTRY"; break;
        case 13: retval = "UNCONDITIONAL_JUMP"; break;
        case 14: retval = "UNCONDITIONAL_JUMP_I"; break;
        case 15: retval = "NONE"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(IRStmtType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "IRStmtType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// InsnSemanticsExpr::Operator is defined at src/midend/binaryAnalyses/instructionSemantics/InsnSemanticsExpr.h:15
/** Converts an enum of type InsnSemanticsExpr::Operator to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyInsnSemanticsExprOperator(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "OP_ADD"; break;
        case 1: retval = "OP_AND"; break;
        case 2: retval = "OP_ASR"; break;
        case 3: retval = "OP_BV_AND"; break;
        case 4: retval = "OP_BV_OR"; break;
        case 5: retval = "OP_BV_XOR"; break;
        case 6: retval = "OP_CONCAT"; break;
        case 7: retval = "OP_EQ"; break;
        case 8: retval = "OP_EXTRACT"; break;
        case 9: retval = "OP_INVERT"; break;
        case 10: retval = "OP_ITE"; break;
        case 11: retval = "OP_LSSB"; break;
        case 12: retval = "OP_MSSB"; break;
        case 13: retval = "OP_NE"; break;
        case 14: retval = "OP_NEGATE"; break;
        case 15: retval = "OP_NOOP"; break;
        case 16: retval = "OP_OR"; break;
        case 17: retval = "OP_ROL"; break;
        case 18: retval = "OP_ROR"; break;
        case 19: retval = "OP_SDIV"; break;
        case 20: retval = "OP_SEXTEND"; break;
        case 21: retval = "OP_SGE"; break;
        case 22: retval = "OP_SGT"; break;
        case 23: retval = "OP_SHL0"; break;
        case 24: retval = "OP_SHL1"; break;
        case 25: retval = "OP_SHR0"; break;
        case 26: retval = "OP_SHR1"; break;
        case 27: retval = "OP_SLE"; break;
        case 28: retval = "OP_SLT"; break;
        case 29: retval = "OP_SMOD"; break;
        case 30: retval = "OP_SMUL"; break;
        case 31: retval = "OP_UDIV"; break;
        case 32: retval = "OP_UEXTEND"; break;
        case 33: retval = "OP_UGE"; break;
        case 34: retval = "OP_UGT"; break;
        case 35: retval = "OP_ULE"; break;
        case 36: retval = "OP_ULT"; break;
        case 37: retval = "OP_UMOD"; break;
        case 38: retval = "OP_UMUL"; break;
        case 39: retval = "OP_ZEROP"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(InsnSemanticsExpr::Operator)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "InsnSemanticsExpr::Operator::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// MemoryMap::Protection is defined at src/frontend/BinaryFormats/MemoryMap.h:18
/** Converts an enum of type MemoryMap::Protection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMemoryMapProtection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "MM_PROT_NONE"; break;
        case 1: retval = "MM_PROT_READ"; break;
        case 2: retval = "MM_PROT_WRITE"; break;
        case 4: retval = "MM_PROT_EXEC"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(MemoryMap::Protection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MemoryMap::Protection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum is defined at src/midend/astRewriteMechanism/rewrite.h:80
/** Converts an enum of type MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMidLevelCollectionTypedefsIntermediateFileStringPosition_Enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "unknownIntermediatePositionInScope"; break;
        case 1: retval = "GlobalScopePreamble"; break;
        case 2: retval = "CurrentLocationTopOfScope"; break;
        case 3: retval = "CurrentLocationBefore"; break;
        case 4: retval = "CurrentLocationReplace"; break;
        case 5: retval = "CurrentLocationAfter"; break;
        case 6: retval = "CurrentLocationBottomOfScope"; break;
        case 7: retval = "LAST_INTERMEDIATE_SOURCE_CODE_PLACEMENT_TAG"; break;
    }
    if (retval.empty()) {
        char buf[127];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// MidLevelCollectionTypedefs::PlacementPosition_Enum is defined at src/midend/astRewriteMechanism/rewrite.h:67
/** Converts an enum of type MidLevelCollectionTypedefs::PlacementPosition_Enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMidLevelCollectionTypedefsPlacementPosition_Enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "unknownPositionInScope"; break;
        case 1: retval = "PreamblePositionInScope"; break;
        case 2: retval = "TopOfCurrentScope"; break;
        case 3: retval = "BeforeCurrentPosition"; break;
        case 4: retval = "ReplaceCurrentPosition"; break;
        case 5: retval = "AfterCurrentPosition"; break;
        case 6: retval = "BottomOfCurrentScope"; break;
        case 7: retval = "LAST_PLACEMENT_TAG"; break;
    }
    if (retval.empty()) {
        char buf[114];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(MidLevelCollectionTypedefs::PlacementPosition_Enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MidLevelCollectionTypedefs::PlacementPosition_Enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// MidLevelCollectionTypedefs::ScopeIdentifier_Enum is defined at src/midend/astRewriteMechanism/rewrite.h:53
/** Converts an enum of type MidLevelCollectionTypedefs::ScopeIdentifier_Enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMidLevelCollectionTypedefsScopeIdentifier_Enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "unknownScope"; break;
        case 1: retval = "StatementScope"; break;
        case 2: retval = "SurroundingScope"; break;
        case 3: retval = "Preamble"; break;
        case 4: retval = "LAST_SCOPE_TAG"; break;
    }
    if (retval.empty()) {
        char buf[112];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(MidLevelCollectionTypedefs::ScopeIdentifier_Enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MidLevelCollectionTypedefs::ScopeIdentifier_Enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// NFAAssertion is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfa.h:64
/** Converts an enum of type NFAAssertion to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNFAAssertion(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NoAssertion"; break;
        case 1: retval = "ZeroOrOne"; break;
        case 2: retval = "ZeroOrMore"; break;
        case 4: retval = "OneOrMore"; break;
        case 8: retval = "WordStart"; break;
        case 16: retval = "WordEnd"; break;
        case 32: retval = "Word"; break;
        case 64: retval = "NonWord"; break;
        case 128: retval = "Digit"; break;
        case 256: retval = "NonDigit"; break;
        case 512: retval = "Space"; break;
        case 1024: retval = "NonSpace"; break;
        case 2048: retval = "CaseSensitive"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(NFAAssertion)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NFAAssertion::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// NFAType is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfa.h:43
/** Converts an enum of type NFAType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNFAType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Char"; break;
        case 1: retval = "Match"; break;
        case 2: retval = "CxtBeg"; break;
        case 3: retval = "ContextBegin"; break;
        case 4: retval = "CxtEnd"; break;
        case 5: retval = "ContextEnd"; break;
        case 8: retval = "CxtEsc"; break;
        case 9: retval = "EscapeSeq"; break;
        case 16: retval = "Escaped"; break;
        case 32: retval = "Exclusive"; break;
        case 64: retval = "StayOnLine"; break;
        case 128: retval = "Reserved"; break;
    }
    if (retval.empty()) {
        char buf[71];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(NFAType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NFAType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// NameQuery::TypeOfQueryTypeOneParameter is defined at src/midend/astQuery/nameQuery.h:75
/** Converts an enum of type NameQuery::TypeOfQueryTypeOneParameter to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNameQueryTypeOfQueryTypeOneParameter(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementType"; break;
        case 1: retval = "VariableNames"; break;
        case 2: retval = "VariableTypeNames"; break;
        case 3: retval = "FunctionDeclarationNames"; break;
        case 4: retval = "MemberFunctionDeclarationNames"; break;
        case 5: retval = "ClassDeclarationNames"; break;
        case 6: retval = "ArgumentNames"; break;
        case 7: retval = "ClassFieldNames"; break;
        case 8: retval = "UnionFieldNames"; break;
        case 9: retval = "StructFieldNames"; break;
        case 10: retval = "FunctionReferenceNames"; break;
        case 11: retval = "StructNames"; break;
        case 12: retval = "UnionNames"; break;
        case 13: retval = "TypedefDeclarationNames"; break;
        case 14: retval = "TypeNames"; break;
        case 15: retval = "END_OF_NAME_TYPE_LIST"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(NameQuery::TypeOfQueryTypeOneParameter)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NameQuery::TypeOfQueryTypeOneParameter::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// NameQuery::TypeOfQueryTypeTwoParameters is defined at src/midend/astQuery/nameQuery.h:95
/** Converts an enum of type NameQuery::TypeOfQueryTypeTwoParameters to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNameQueryTypeOfQueryTypeTwoParameters(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementTypeTwoParameters"; break;
        case 1: retval = "VariableNamesWithTypeName"; break;
        case 2: retval = "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS"; break;
    }
    if (retval.empty()) {
        char buf[103];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(NameQuery::TypeOfQueryTypeTwoParameters)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NameQuery::TypeOfQueryTypeTwoParameters::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// NodeQuery::TypeOfQueryTypeOneParameter is defined at src/midend/astQuery/nodeQuery.h:133
/** Converts an enum of type NodeQuery::TypeOfQueryTypeOneParameter to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNodeQueryTypeOfQueryTypeOneParameter(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementType"; break;
        case 1: retval = "VariableDeclarations"; break;
        case 2: retval = "VariableTypes"; break;
        case 3: retval = "FunctionDeclarations"; break;
        case 4: retval = "MemberFunctionDeclarations"; break;
        case 5: retval = "ClassDeclarations"; break;
        case 6: retval = "StructDeclarations"; break;
        case 7: retval = "UnionDeclarations"; break;
        case 8: retval = "Arguments"; break;
        case 9: retval = "ClassFields"; break;
        case 10: retval = "StructFields"; break;
        case 11: retval = "UnionFields"; break;
        case 12: retval = "StructDefinitions"; break;
        case 13: retval = "TypedefDeclarations"; break;
        case 14: retval = "AnonymousTypedefs"; break;
        case 15: retval = "AnonymousTypedefClassDeclarations"; break;
        case 16: retval = "END_OF_NODE_TYPE_LIST_ONE_PARAMETER"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(NodeQuery::TypeOfQueryTypeOneParameter)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NodeQuery::TypeOfQueryTypeOneParameter::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// NodeQuery::TypeOfQueryTypeTwoParameters is defined at src/midend/astQuery/nodeQuery.h:154
/** Converts an enum of type NodeQuery::TypeOfQueryTypeTwoParameters to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNodeQueryTypeOfQueryTypeTwoParameters(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementTypeTwoParameters"; break;
        case 1: retval = "FunctionDeclarationFromDefinition"; break;
        case 2: retval = "ClassDeclarationFromName"; break;
        case 3: retval = "ClassDeclarationsFromTypeName"; break;
        case 4: retval = "PragmaDeclarationFromName"; break;
        case 5: retval = "VariableDeclarationFromName"; break;
        case 6: retval = "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS"; break;
    }
    if (retval.empty()) {
        char buf[103];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(NodeQuery::TypeOfQueryTypeTwoParameters)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NodeQuery::TypeOfQueryTypeTwoParameters::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// NumberQuery::TypeOfQueryTypeOneParameter is defined at src/midend/astQuery/numberQuery.h:11
/** Converts an enum of type NumberQuery::TypeOfQueryTypeOneParameter to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNumberQueryTypeOfQueryTypeOneParameter(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementType"; break;
        case 1: retval = "NumberOfArgsInConstructor"; break;
        case 2: retval = "NumberOfOperands"; break;
        case 3: retval = "NumberOfArgsInScalarIndexingOperator"; break;
        case 4: retval = "END_OF_NODE_TYPE_LIST_ONE_PARAMETER"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(NumberQuery::TypeOfQueryTypeOneParameter)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NumberQuery::TypeOfQueryTypeOneParameter::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// NumberQuery::TypeOfQueryTypeTwoParameters is defined at src/midend/astQuery/numberQuery.h:20
/** Converts an enum of type NumberQuery::TypeOfQueryTypeTwoParameters to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNumberQueryTypeOfQueryTypeTwoParameters(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementTypeTwoParameters"; break;
        case 1: retval = "NumberOfArgsInParanthesisOperator"; break;
        case 2: retval = "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(NumberQuery::TypeOfQueryTypeTwoParameters)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NumberQuery::TypeOfQueryTypeTwoParameters::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// OmpSupport::omp_construct_enum is defined at src/frontend/SageIII/OmpAttribute.h:27
/** Converts an enum of type OmpSupport::omp_construct_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyOmpSupport_omp_construct_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_parallel"; break;
        case 2: retval = "e_for"; break;
        case 3: retval = "e_do"; break;
        case 4: retval = "e_workshare"; break;
        case 5: retval = "e_sections"; break;
        case 6: retval = "e_section"; break;
        case 7: retval = "e_single"; break;
        case 8: retval = "e_master"; break;
        case 9: retval = "e_critical"; break;
        case 10: retval = "e_barrier"; break;
        case 11: retval = "e_atomic"; break;
        case 12: retval = "e_flush"; break;
        case 13: retval = "e_threadprivate"; break;
        case 14: retval = "e_parallel_for"; break;
        case 15: retval = "e_parallel_do"; break;
        case 16: retval = "e_parallel_sections"; break;
        case 17: retval = "e_parallel_workshare"; break;
        case 18: retval = "e_task"; break;
        case 19: retval = "e_taskwait"; break;
        case 20: retval = "e_ordered_directive"; break;
        case 21: retval = "e_end_critical"; break;
        case 22: retval = "e_end_do"; break;
        case 23: retval = "e_end_master"; break;
        case 24: retval = "e_end_ordered"; break;
        case 25: retval = "e_end_parallel_do"; break;
        case 26: retval = "e_end_parallel_sections"; break;
        case 27: retval = "e_end_parallel_workshare"; break;
        case 28: retval = "e_end_parallel"; break;
        case 29: retval = "e_end_sections"; break;
        case 30: retval = "e_end_single"; break;
        case 31: retval = "e_end_task"; break;
        case 32: retval = "e_end_workshare"; break;
        case 33: retval = "e_default"; break;
        case 34: retval = "e_shared"; break;
        case 35: retval = "e_private"; break;
        case 36: retval = "e_firstprivate"; break;
        case 37: retval = "e_lastprivate"; break;
        case 38: retval = "e_copyin"; break;
        case 39: retval = "e_copyprivate"; break;
        case 40: retval = "e_if"; break;
        case 41: retval = "e_num_threads"; break;
        case 42: retval = "e_nowait"; break;
        case 43: retval = "e_ordered_clause"; break;
        case 44: retval = "e_reduction"; break;
        case 45: retval = "e_schedule"; break;
        case 46: retval = "e_collapse"; break;
        case 47: retval = "e_untied"; break;
        case 48: retval = "e_default_none"; break;
        case 49: retval = "e_default_shared"; break;
        case 50: retval = "e_default_private"; break;
        case 51: retval = "e_default_firstprivate"; break;
        case 52: retval = "e_reduction_plus"; break;
        case 53: retval = "e_reduction_mul"; break;
        case 54: retval = "e_reduction_minus"; break;
        case 55: retval = "e_reduction_bitand"; break;
        case 56: retval = "e_reduction_bitor"; break;
        case 57: retval = "e_reduction_bitxor"; break;
        case 58: retval = "e_reduction_logand"; break;
        case 59: retval = "e_reduction_logor"; break;
        case 60: retval = "e_reduction_and"; break;
        case 61: retval = "e_reduction_or"; break;
        case 62: retval = "e_reduction_eqv"; break;
        case 63: retval = "e_reduction_neqv"; break;
        case 64: retval = "e_reduction_max"; break;
        case 65: retval = "e_reduction_min"; break;
        case 66: retval = "e_reduction_iand"; break;
        case 67: retval = "e_reduction_ior"; break;
        case 68: retval = "e_reduction_ieor"; break;
        case 69: retval = "e_schedule_none"; break;
        case 70: retval = "e_schedule_static"; break;
        case 71: retval = "e_schedule_dynamic"; break;
        case 72: retval = "e_schedule_guided"; break;
        case 73: retval = "e_schedule_auto"; break;
        case 74: retval = "e_schedule_runtime"; break;
        case 75: retval = "e_not_omp"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(OmpSupport::omp_construct_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "OmpSupport::omp_construct_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// OmpSupport::omp_rtl_enum is defined at src/midend/programTransformation/ompLowering/omp_lowering.h:18
/** Converts an enum of type OmpSupport::omp_rtl_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyOmpSupport_omp_rtl_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_gomp"; break;
        case 1: retval = "e_omni"; break;
        case 2: retval = "e_last_rtl"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(OmpSupport::omp_rtl_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "OmpSupport::omp_rtl_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// PowerpcConditionRegisterAccessGranularity is defined at src/frontend/BinaryDisassembly/powerpcInstructionEnum.h:471
/** Converts an enum of type PowerpcConditionRegisterAccessGranularity to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPowerpcConditionRegisterAccessGranularity(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "powerpc_condreggranularity_whole"; break;
        case 1: retval = "powerpc_condreggranularity_field"; break;
        case 2: retval = "powerpc_condreggranularity_bit"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(PowerpcConditionRegisterAccessGranularity)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PowerpcConditionRegisterAccessGranularity::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// PowerpcInstructionKind is defined at src/frontend/BinaryDisassembly/powerpcInstructionEnum.h:9
/** Converts an enum of type PowerpcInstructionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPowerpcInstructionKind(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "powerpc_unknown_instruction"; break;
        case 1: retval = "powerpc_add"; break;
        case 2: retval = "powerpc_add_record"; break;
        case 3: retval = "powerpc_addo"; break;
        case 4: retval = "powerpc_addo_record"; break;
        case 5: retval = "powerpc_addc"; break;
        case 6: retval = "powerpc_addc_record"; break;
        case 7: retval = "powerpc_addco"; break;
        case 8: retval = "powerpc_addco_record"; break;
        case 9: retval = "powerpc_adde"; break;
        case 10: retval = "powerpc_adde_record"; break;
        case 11: retval = "powerpc_addeo"; break;
        case 12: retval = "powerpc_addeo_record"; break;
        case 13: retval = "powerpc_addi"; break;
        case 14: retval = "powerpc_addic"; break;
        case 15: retval = "powerpc_addic_record"; break;
        case 16: retval = "powerpc_addis"; break;
        case 17: retval = "powerpc_addme"; break;
        case 18: retval = "powerpc_addme_record"; break;
        case 19: retval = "powerpc_addmeo"; break;
        case 20: retval = "powerpc_addmeo_record"; break;
        case 21: retval = "powerpc_addze"; break;
        case 22: retval = "powerpc_addze_record"; break;
        case 23: retval = "powerpc_addzeo"; break;
        case 24: retval = "powerpc_addzeo_record"; break;
        case 25: retval = "powerpc_and"; break;
        case 26: retval = "powerpc_and_record"; break;
        case 27: retval = "powerpc_andc"; break;
        case 28: retval = "powerpc_andc_record"; break;
        case 29: retval = "powerpc_andi_record"; break;
        case 30: retval = "powerpc_andis_record"; break;
        case 31: retval = "powerpc_b"; break;
        case 32: retval = "powerpc_ba"; break;
        case 33: retval = "powerpc_bl"; break;
        case 34: retval = "powerpc_bla"; break;
        case 35: retval = "powerpc_bc"; break;
        case 36: retval = "powerpc_bca"; break;
        case 37: retval = "powerpc_bcl"; break;
        case 38: retval = "powerpc_bcla"; break;
        case 39: retval = "powerpc_bcctr"; break;
        case 40: retval = "powerpc_bcctrl"; break;
        case 41: retval = "powerpc_bclr"; break;
        case 42: retval = "powerpc_bclrl"; break;
        case 43: retval = "powerpc_cmp"; break;
        case 44: retval = "powerpc_cmpi"; break;
        case 45: retval = "powerpc_cmpl"; break;
        case 46: retval = "powerpc_cmpli"; break;
        case 47: retval = "powerpc_cntlzd"; break;
        case 48: retval = "powerpc_cntlzd_record"; break;
        case 49: retval = "powerpc_cntlzw"; break;
        case 50: retval = "powerpc_cntlzw_record"; break;
        case 51: retval = "powerpc_crand"; break;
        case 52: retval = "powerpc_crandc"; break;
        case 53: retval = "powerpc_creqv"; break;
        case 54: retval = "powerpc_crnand"; break;
        case 55: retval = "powerpc_crnor"; break;
        case 56: retval = "powerpc_cror"; break;
        case 57: retval = "powerpc_crorc"; break;
        case 58: retval = "powerpc_crxor"; break;
        case 59: retval = "powerpc_dcbf"; break;
        case 60: retval = "powerpc_dcba"; break;
        case 61: retval = "powerpc_dcbi"; break;
        case 62: retval = "powerpc_dcbst"; break;
        case 63: retval = "powerpc_dcbt"; break;
        case 64: retval = "powerpc_dcbtst"; break;
        case 65: retval = "powerpc_dcbz"; break;
        case 66: retval = "powerpc_divd"; break;
        case 67: retval = "powerpc_divd_record"; break;
        case 68: retval = "powerpc_divdo"; break;
        case 69: retval = "powerpc_divdo_record"; break;
        case 70: retval = "powerpc_divdu"; break;
        case 71: retval = "powerpc_divdu_record"; break;
        case 72: retval = "powerpc_divduo"; break;
        case 73: retval = "powerpc_divduo_record"; break;
        case 74: retval = "powerpc_divw"; break;
        case 75: retval = "powerpc_divw_record"; break;
        case 76: retval = "powerpc_divwo"; break;
        case 77: retval = "powerpc_divwo_record"; break;
        case 78: retval = "powerpc_divwu"; break;
        case 79: retval = "powerpc_divwu_record"; break;
        case 80: retval = "powerpc_divwuo"; break;
        case 81: retval = "powerpc_divwuo_record"; break;
        case 82: retval = "powerpc_dst"; break;
        case 83: retval = "powerpc_dstt"; break;
        case 84: retval = "powerpc_dstst"; break;
        case 85: retval = "powerpc_dststt"; break;
        case 86: retval = "powerpc_dss"; break;
        case 87: retval = "powerpc_dssall"; break;
        case 88: retval = "powerpc_eciwx"; break;
        case 89: retval = "powerpc_ecowx"; break;
        case 90: retval = "powerpc_eieio"; break;
        case 91: retval = "powerpc_eqv"; break;
        case 92: retval = "powerpc_eqv_record"; break;
        case 93: retval = "powerpc_extsb"; break;
        case 94: retval = "powerpc_extsb_record"; break;
        case 95: retval = "powerpc_extsh"; break;
        case 96: retval = "powerpc_extsh_record"; break;
        case 97: retval = "powerpc_extsw"; break;
        case 98: retval = "powerpc_extsw_record"; break;
        case 99: retval = "powerpc_fabs"; break;
        case 100: retval = "powerpc_fabs_record"; break;
        case 101: retval = "powerpc_fadd"; break;
        case 102: retval = "powerpc_fadd_record"; break;
        case 103: retval = "powerpc_fadds"; break;
        case 104: retval = "powerpc_fadds_record"; break;
        case 105: retval = "powerpc_fcfid"; break;
        case 106: retval = "powerpc_fcfid_record"; break;
        case 107: retval = "powerpc_fcmpo"; break;
        case 108: retval = "powerpc_fcmpu"; break;
        case 109: retval = "powerpc_fctid"; break;
        case 110: retval = "powerpc_fctid_record"; break;
        case 111: retval = "powerpc_fctidz"; break;
        case 112: retval = "powerpc_fctidz_record"; break;
        case 113: retval = "powerpc_fctiw"; break;
        case 114: retval = "powerpc_fctiw_record"; break;
        case 115: retval = "powerpc_fctiwz"; break;
        case 116: retval = "powerpc_fctiwz_record"; break;
        case 117: retval = "powerpc_fdiv"; break;
        case 118: retval = "powerpc_fdiv_record"; break;
        case 119: retval = "powerpc_fdivs"; break;
        case 120: retval = "powerpc_fdivs_record"; break;
        case 121: retval = "powerpc_fmadd"; break;
        case 122: retval = "powerpc_fmadd_record"; break;
        case 123: retval = "powerpc_fmadds"; break;
        case 124: retval = "powerpc_fmadds_record"; break;
        case 125: retval = "powerpc_fmr"; break;
        case 126: retval = "powerpc_fmr_record"; break;
        case 127: retval = "powerpc_fmsub"; break;
        case 128: retval = "powerpc_fmsub_record"; break;
        case 129: retval = "powerpc_fmsubs"; break;
        case 130: retval = "powerpc_fmsubs_record"; break;
        case 131: retval = "powerpc_fmul"; break;
        case 132: retval = "powerpc_fmul_record"; break;
        case 133: retval = "powerpc_fmuls"; break;
        case 134: retval = "powerpc_fmuls_record"; break;
        case 135: retval = "powerpc_fnabs"; break;
        case 136: retval = "powerpc_fnabs_record"; break;
        case 137: retval = "powerpc_fneg"; break;
        case 138: retval = "powerpc_fneg_record"; break;
        case 139: retval = "powerpc_fnmadd"; break;
        case 140: retval = "powerpc_fnmadd_record"; break;
        case 141: retval = "powerpc_fnmadds"; break;
        case 142: retval = "powerpc_fnmadds_record"; break;
        case 143: retval = "powerpc_fnmsub"; break;
        case 144: retval = "powerpc_fnmsub_record"; break;
        case 145: retval = "powerpc_fnmsubs"; break;
        case 146: retval = "powerpc_fnmsubs_record"; break;
        case 147: retval = "powerpc_fpmul"; break;
        case 148: retval = "powerpc_fxmul"; break;
        case 149: retval = "powerpc_fxpmul"; break;
        case 150: retval = "powerpc_fxsmul"; break;
        case 151: retval = "powerpc_fpadd"; break;
        case 152: retval = "powerpc_fpsub"; break;
        case 153: retval = "powerpc_fpre"; break;
        case 154: retval = "powerpc_fprsqrte"; break;
        case 155: retval = "powerpc_fpmr"; break;
        case 156: retval = "powerpc_fpabs"; break;
        case 157: retval = "powerpc_lfssx"; break;
        case 158: retval = "powerpc_fpneg"; break;
        case 159: retval = "powerpc_lfssux"; break;
        case 160: retval = "powerpc_fprsp"; break;
        case 161: retval = "powerpc_lfsdx"; break;
        case 162: retval = "powerpc_fpnabs"; break;
        case 163: retval = "powerpc_lfsdux"; break;
        case 164: retval = "powerpc_lfxsx"; break;
        case 165: retval = "powerpc_fsmr"; break;
        case 166: retval = "powerpc_lfxsux"; break;
        case 167: retval = "powerpc_lfxdx"; break;
        case 168: retval = "powerpc_fsabs"; break;
        case 169: retval = "powerpc_lfxdux"; break;
        case 170: retval = "powerpc_lfpsx"; break;
        case 171: retval = "powerpc_fsneg"; break;
        case 172: retval = "powerpc_lfpsux"; break;
        case 173: retval = "powerpc_lfpdx"; break;
        case 174: retval = "powerpc_fsnabs"; break;
        case 175: retval = "powerpc_lfpdux"; break;
        case 176: retval = "powerpc_stfpiwx"; break;
        case 177: retval = "powerpc_fxmr"; break;
        case 178: retval = "powerpc_fpctiw"; break;
        case 179: retval = "powerpc_stfssx"; break;
        case 180: retval = "powerpc_stfssux"; break;
        case 181: retval = "powerpc_fpctiwz"; break;
        case 182: retval = "powerpc_stfsdx"; break;
        case 183: retval = "powerpc_stfsdux"; break;
        case 184: retval = "powerpc_stfxsx"; break;
        case 185: retval = "powerpc_fsmtp"; break;
        case 186: retval = "powerpc_stfxsux"; break;
        case 187: retval = "powerpc_stfxdx"; break;
        case 188: retval = "powerpc_stfxdux"; break;
        case 189: retval = "powerpc_stfpsx"; break;
        case 190: retval = "powerpc_fsmfp"; break;
        case 191: retval = "powerpc_stfpsux"; break;
        case 192: retval = "powerpc_stfpdx"; break;
        case 193: retval = "powerpc_stfpdux"; break;
        case 194: retval = "powerpc_fpsel"; break;
        case 195: retval = "powerpc_fpmadd"; break;
        case 196: retval = "powerpc_fpmsub"; break;
        case 197: retval = "powerpc_fxmadd"; break;
        case 198: retval = "powerpc_fxcpmadd"; break;
        case 199: retval = "powerpc_fxcsmadd"; break;
        case 200: retval = "powerpc_fpnmadd"; break;
        case 201: retval = "powerpc_fxnmadd"; break;
        case 202: retval = "powerpc_fxcpnmadd"; break;
        case 203: retval = "powerpc_fxcsnmadd"; break;
        case 204: retval = "powerpc_fxcpnpma"; break;
        case 205: retval = "powerpc_fxmsub"; break;
        case 206: retval = "powerpc_fxcsnpma"; break;
        case 207: retval = "powerpc_fxcpmsub"; break;
        case 208: retval = "powerpc_fxcpnsma"; break;
        case 209: retval = "powerpc_fxcsmsub"; break;
        case 210: retval = "powerpc_fxcsnsma"; break;
        case 211: retval = "powerpc_fpnmsub"; break;
        case 212: retval = "powerpc_fxcxma"; break;
        case 213: retval = "powerpc_fxnmsub"; break;
        case 214: retval = "powerpc_fxcxnpma"; break;
        case 215: retval = "powerpc_fxcpnmsub"; break;
        case 216: retval = "powerpc_fxcxnsma"; break;
        case 217: retval = "powerpc_fxcsnmsub"; break;
        case 218: retval = "powerpc_fxcxnms"; break;
        case 219: retval = "powerpc_fre"; break;
        case 220: retval = "powerpc_fre_record"; break;
        case 221: retval = "powerpc_fres"; break;
        case 222: retval = "powerpc_fres_record"; break;
        case 223: retval = "powerpc_frsp"; break;
        case 224: retval = "powerpc_frsp_record"; break;
        case 225: retval = "powerpc_frsqrte"; break;
        case 226: retval = "powerpc_frsqrte_record"; break;
        case 227: retval = "powerpc_frsqrtes"; break;
        case 228: retval = "powerpc_frsqrtes_record"; break;
        case 229: retval = "powerpc_fsel"; break;
        case 230: retval = "powerpc_fsel_record"; break;
        case 231: retval = "powerpc_fsqrt"; break;
        case 232: retval = "powerpc_fsqrt_record"; break;
        case 233: retval = "powerpc_fsqrts"; break;
        case 234: retval = "powerpc_fsqrts_record"; break;
        case 235: retval = "powerpc_fsub"; break;
        case 236: retval = "powerpc_fsub_record"; break;
        case 237: retval = "powerpc_fsubs"; break;
        case 238: retval = "powerpc_fsubs_record"; break;
        case 239: retval = "powerpc_icbi"; break;
        case 240: retval = "powerpc_isync"; break;
        case 241: retval = "powerpc_lbz"; break;
        case 242: retval = "powerpc_lbzu"; break;
        case 243: retval = "powerpc_lbzux"; break;
        case 244: retval = "powerpc_lbzx"; break;
        case 245: retval = "powerpc_ld"; break;
        case 246: retval = "powerpc_ldarx"; break;
        case 247: retval = "powerpc_ldu"; break;
        case 248: retval = "powerpc_ldux"; break;
        case 249: retval = "powerpc_ldx"; break;
        case 250: retval = "powerpc_lfd"; break;
        case 251: retval = "powerpc_lfdu"; break;
        case 252: retval = "powerpc_lfdux"; break;
        case 253: retval = "powerpc_lfdx"; break;
        case 254: retval = "powerpc_lfs"; break;
        case 255: retval = "powerpc_lfsu"; break;
        case 256: retval = "powerpc_lfsux"; break;
        case 257: retval = "powerpc_lfsx"; break;
        case 258: retval = "powerpc_lha"; break;
        case 259: retval = "powerpc_lhau"; break;
        case 260: retval = "powerpc_lhaux"; break;
        case 261: retval = "powerpc_lhax"; break;
        case 262: retval = "powerpc_lhbrx"; break;
        case 263: retval = "powerpc_lhz"; break;
        case 264: retval = "powerpc_lhzu"; break;
        case 265: retval = "powerpc_lhzux"; break;
        case 266: retval = "powerpc_lhzx"; break;
        case 267: retval = "powerpc_lmw"; break;
        case 268: retval = "powerpc_lswi"; break;
        case 269: retval = "powerpc_lswx"; break;
        case 270: retval = "powerpc_lwa"; break;
        case 271: retval = "powerpc_lwarx"; break;
        case 272: retval = "powerpc_lwaux"; break;
        case 273: retval = "powerpc_lwax"; break;
        case 274: retval = "powerpc_lwbrx"; break;
        case 275: retval = "powerpc_lwz"; break;
        case 276: retval = "powerpc_lwzu"; break;
        case 277: retval = "powerpc_lwzux"; break;
        case 278: retval = "powerpc_lwzx"; break;
        case 279: retval = "powerpc_mcrf"; break;
        case 280: retval = "powerpc_mcrfs"; break;
        case 281: retval = "powerpc_mcrxr"; break;
        case 282: retval = "powerpc_mfcr"; break;
        case 283: retval = "powerpc_mffs"; break;
        case 284: retval = "powerpc_mffs_record"; break;
        case 285: retval = "powerpc_mfmsr"; break;
        case 286: retval = "powerpc_mfspr"; break;
        case 287: retval = "powerpc_mfsr"; break;
        case 288: retval = "powerpc_mfsrin"; break;
        case 289: retval = "powerpc_mftb"; break;
        case 290: retval = "powerpc_mtcrf"; break;
        case 291: retval = "powerpc_mtfsb0"; break;
        case 292: retval = "powerpc_mtfsb0_record"; break;
        case 293: retval = "powerpc_mtfsb1"; break;
        case 294: retval = "powerpc_mtfsb1_record"; break;
        case 295: retval = "powerpc_mtfsf"; break;
        case 296: retval = "powerpc_mtfsf_record"; break;
        case 297: retval = "powerpc_mtfsfi"; break;
        case 298: retval = "powerpc_mtfsfi_record"; break;
        case 299: retval = "powerpc_mtmsr"; break;
        case 300: retval = "powerpc_mtmsrd"; break;
        case 301: retval = "powerpc_mtspr"; break;
        case 302: retval = "powerpc_mtsr"; break;
        case 303: retval = "powerpc_mtsrd"; break;
        case 304: retval = "powerpc_mtsrdin"; break;
        case 305: retval = "powerpc_mtsrin"; break;
        case 306: retval = "powerpc_mulhd"; break;
        case 307: retval = "powerpc_mulhd_record"; break;
        case 308: retval = "powerpc_mulhdu"; break;
        case 309: retval = "powerpc_mulhdu_record"; break;
        case 310: retval = "powerpc_mulhw"; break;
        case 311: retval = "powerpc_mulhw_record"; break;
        case 312: retval = "powerpc_mulhwu"; break;
        case 313: retval = "powerpc_mulhwu_record"; break;
        case 314: retval = "powerpc_mulld"; break;
        case 315: retval = "powerpc_mulld_record"; break;
        case 316: retval = "powerpc_mulldo"; break;
        case 317: retval = "powerpc_mulldo_record"; break;
        case 318: retval = "powerpc_mulli"; break;
        case 319: retval = "powerpc_mullw"; break;
        case 320: retval = "powerpc_mullw_record"; break;
        case 321: retval = "powerpc_mullwo"; break;
        case 322: retval = "powerpc_mullwo_record"; break;
        case 323: retval = "powerpc_nand"; break;
        case 324: retval = "powerpc_nand_record"; break;
        case 325: retval = "powerpc_neg"; break;
        case 326: retval = "powerpc_neg_record"; break;
        case 327: retval = "powerpc_nego"; break;
        case 328: retval = "powerpc_nego_record"; break;
        case 329: retval = "powerpc_nor"; break;
        case 330: retval = "powerpc_nor_record"; break;
        case 331: retval = "powerpc_or"; break;
        case 332: retval = "powerpc_or_record"; break;
        case 333: retval = "powerpc_orc"; break;
        case 334: retval = "powerpc_orc_record"; break;
        case 335: retval = "powerpc_ori"; break;
        case 336: retval = "powerpc_oris"; break;
        case 337: retval = "powerpc_rfi"; break;
        case 338: retval = "powerpc_rfid"; break;
        case 339: retval = "powerpc_rldcl"; break;
        case 340: retval = "powerpc_rldcl_record"; break;
        case 341: retval = "powerpc_rldcr"; break;
        case 342: retval = "powerpc_rldcr_record"; break;
        case 343: retval = "powerpc_rldic"; break;
        case 344: retval = "powerpc_rldic_record"; break;
        case 345: retval = "powerpc_rldicl"; break;
        case 346: retval = "powerpc_rldicl_record"; break;
        case 347: retval = "powerpc_rldicr"; break;
        case 348: retval = "powerpc_rldicr_record"; break;
        case 349: retval = "powerpc_rldimi"; break;
        case 350: retval = "powerpc_rldimi_record"; break;
        case 351: retval = "powerpc_rlwimi"; break;
        case 352: retval = "powerpc_rlwimi_record"; break;
        case 353: retval = "powerpc_rlwinm"; break;
        case 354: retval = "powerpc_rlwinm_record"; break;
        case 355: retval = "powerpc_rlwnm"; break;
        case 356: retval = "powerpc_rlwnm_record"; break;
        case 357: retval = "powerpc_sc"; break;
        case 358: retval = "powerpc_slbia"; break;
        case 359: retval = "powerpc_slbie"; break;
        case 360: retval = "powerpc_sld"; break;
        case 361: retval = "powerpc_sld_record"; break;
        case 362: retval = "powerpc_slw"; break;
        case 363: retval = "powerpc_slw_record"; break;
        case 364: retval = "powerpc_srad"; break;
        case 365: retval = "powerpc_srad_record"; break;
        case 366: retval = "powerpc_sradi"; break;
        case 367: retval = "powerpc_sradi_record"; break;
        case 368: retval = "powerpc_srd"; break;
        case 369: retval = "powerpc_srd_record"; break;
        case 370: retval = "powerpc_sraw"; break;
        case 371: retval = "powerpc_sraw_record"; break;
        case 372: retval = "powerpc_srawi"; break;
        case 373: retval = "powerpc_srawi_record"; break;
        case 374: retval = "powerpc_srw"; break;
        case 375: retval = "powerpc_srw_record"; break;
        case 376: retval = "powerpc_stb"; break;
        case 377: retval = "powerpc_stbu"; break;
        case 378: retval = "powerpc_stbux"; break;
        case 379: retval = "powerpc_stbx"; break;
        case 380: retval = "powerpc_std"; break;
        case 381: retval = "powerpc_stdcx_record"; break;
        case 382: retval = "powerpc_stdu"; break;
        case 383: retval = "powerpc_stdux"; break;
        case 384: retval = "powerpc_stdx"; break;
        case 385: retval = "powerpc_stfd"; break;
        case 386: retval = "powerpc_stfdu"; break;
        case 387: retval = "powerpc_stfdux"; break;
        case 388: retval = "powerpc_stfdx"; break;
        case 389: retval = "powerpc_stfiwx"; break;
        case 390: retval = "powerpc_stfs"; break;
        case 391: retval = "powerpc_stfsu"; break;
        case 392: retval = "powerpc_stfsux"; break;
        case 393: retval = "powerpc_stfsx"; break;
        case 394: retval = "powerpc_sth"; break;
        case 395: retval = "powerpc_sthbrx"; break;
        case 396: retval = "powerpc_sthu"; break;
        case 397: retval = "powerpc_sthux"; break;
        case 398: retval = "powerpc_sthx"; break;
        case 399: retval = "powerpc_stmw"; break;
        case 400: retval = "powerpc_stswi"; break;
        case 401: retval = "powerpc_stswx"; break;
        case 402: retval = "powerpc_stw"; break;
        case 403: retval = "powerpc_stwbrx"; break;
        case 404: retval = "powerpc_stwcx_record"; break;
        case 405: retval = "powerpc_stwu"; break;
        case 406: retval = "powerpc_stwux"; break;
        case 407: retval = "powerpc_stwx"; break;
        case 408: retval = "powerpc_subf"; break;
        case 409: retval = "powerpc_subf_record"; break;
        case 410: retval = "powerpc_subfo"; break;
        case 411: retval = "powerpc_subfo_record"; break;
        case 412: retval = "powerpc_subfc"; break;
        case 413: retval = "powerpc_subfc_record"; break;
        case 414: retval = "powerpc_subfco"; break;
        case 415: retval = "powerpc_subfco_record"; break;
        case 416: retval = "powerpc_subfe"; break;
        case 417: retval = "powerpc_subfe_record"; break;
        case 418: retval = "powerpc_subfeo"; break;
        case 419: retval = "powerpc_subfeo_record"; break;
        case 420: retval = "powerpc_subfic"; break;
        case 421: retval = "powerpc_subfme"; break;
        case 422: retval = "powerpc_subfme_record"; break;
        case 423: retval = "powerpc_subfmeo"; break;
        case 424: retval = "powerpc_subfmeo_record"; break;
        case 425: retval = "powerpc_subfze"; break;
        case 426: retval = "powerpc_subfze_record"; break;
        case 427: retval = "powerpc_subfzeo"; break;
        case 428: retval = "powerpc_subfzeo_record"; break;
        case 429: retval = "powerpc_sync"; break;
        case 430: retval = "powerpc_td"; break;
        case 431: retval = "powerpc_tdi"; break;
        case 432: retval = "powerpc_tlbia"; break;
        case 433: retval = "powerpc_tlbie"; break;
        case 434: retval = "powerpc_tlbsync"; break;
        case 435: retval = "powerpc_tw"; break;
        case 436: retval = "powerpc_twi"; break;
        case 437: retval = "powerpc_xor"; break;
        case 438: retval = "powerpc_xor_record"; break;
        case 439: retval = "powerpc_xori"; break;
        case 440: retval = "powerpc_xoris"; break;
        case 441: retval = "powerpc_last_instruction"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(PowerpcInstructionKind)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PowerpcInstructionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// PowerpcRegisterClass is defined at src/frontend/BinaryDisassembly/powerpcInstructionEnum.h:455
/** Converts an enum of type PowerpcRegisterClass to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPowerpcRegisterClass(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "powerpc_regclass_unknown"; break;
        case 1: retval = "powerpc_regclass_gpr"; break;
        case 2: retval = "powerpc_regclass_fpr"; break;
        case 3: retval = "powerpc_regclass_cr"; break;
        case 4: retval = "powerpc_regclass_fpscr"; break;
        case 5: retval = "powerpc_regclass_spr"; break;
        case 6: retval = "powerpc_regclass_tbr"; break;
        case 7: retval = "powerpc_regclass_msr"; break;
        case 8: retval = "powerpc_regclass_sr"; break;
        case 9: retval = "powerpc_regclass_iar"; break;
        case 10: retval = "powerpc_regclass_pvr"; break;
        case 11: retval = "powerpc_last_register_class"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(PowerpcRegisterClass)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PowerpcRegisterClass::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// PowerpcSpecialPurposeRegister is defined at src/frontend/BinaryDisassembly/powerpcInstructionEnum.h:478
/** Converts an enum of type PowerpcSpecialPurposeRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPowerpcSpecialPurposeRegister(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "powerpc_spr_xer"; break;
        case 8: retval = "powerpc_spr_lr"; break;
        case 9: retval = "powerpc_spr_ctr"; break;
        case 18: retval = "powerpc_spr_dsisr"; break;
        case 19: retval = "powerpc_spr_dar"; break;
        case 22: retval = "powerpc_spr_dec"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(PowerpcSpecialPurposeRegister)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PowerpcSpecialPurposeRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// PowerpcTimeBaseRegister is defined at src/frontend/BinaryDisassembly/powerpcInstructionEnum.h:488
/** Converts an enum of type PowerpcTimeBaseRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPowerpcTimeBaseRegister(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 268: retval = "powerpc_tbr_tbl"; break;
        case 269: retval = "powerpc_tbr_tbu"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(PowerpcTimeBaseRegister)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PowerpcTimeBaseRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// PreprocessingInfo::DirectiveType is defined at src/frontend/SageIII/rose_attributes_list.h:131
/** Converts an enum of type PreprocessingInfo::DirectiveType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPreprocessingInfoDirectiveType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "CpreprocessorUnknownDeclaration"; break;
        case 1: retval = "C_StyleComment"; break;
        case 2: retval = "CplusplusStyleComment"; break;
        case 3: retval = "FortranStyleComment"; break;
        case 4: retval = "F90StyleComment"; break;
        case 5: retval = "CpreprocessorBlankLine"; break;
        case 6: retval = "CpreprocessorIncludeDeclaration"; break;
        case 7: retval = "CpreprocessorIncludeNextDeclaration"; break;
        case 8: retval = "CpreprocessorDefineDeclaration"; break;
        case 9: retval = "CpreprocessorUndefDeclaration"; break;
        case 10: retval = "CpreprocessorIfdefDeclaration"; break;
        case 11: retval = "CpreprocessorIfndefDeclaration"; break;
        case 12: retval = "CpreprocessorIfDeclaration"; break;
        case 13: retval = "CpreprocessorDeadIfDeclaration"; break;
        case 14: retval = "CpreprocessorElseDeclaration"; break;
        case 15: retval = "CpreprocessorElifDeclaration"; break;
        case 16: retval = "CpreprocessorEndifDeclaration"; break;
        case 17: retval = "CpreprocessorLineDeclaration"; break;
        case 18: retval = "CpreprocessorErrorDeclaration"; break;
        case 19: retval = "CpreprocessorWarningDeclaration"; break;
        case 20: retval = "CpreprocessorEmptyDeclaration"; break;
        case 21: retval = "CSkippedToken"; break;
        case 22: retval = "CMacroCall"; break;
        case 23: retval = "CMacroCallStatement"; break;
        case 24: retval = "LineReplacement"; break;
        case 25: retval = "ClinkageSpecificationStart"; break;
        case 26: retval = "ClinkageSpecificationEnd"; break;
        case 27: retval = "CpreprocessorIdentDeclaration"; break;
        case 28: retval = "CpreprocessorCompilerGeneratedLinemarker"; break;
        case 29: retval = "LastDirectiveType"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(PreprocessingInfo::DirectiveType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PreprocessingInfo::DirectiveType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// PreprocessingInfo::RelativePositionType is defined at src/frontend/SageIII/rose_attributes_list.h:110
/** Converts an enum of type PreprocessingInfo::RelativePositionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPreprocessingInfoRelativePositionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "defaultValue"; break;
        case 1: retval = "undef"; break;
        case 2: retval = "before"; break;
        case 3: retval = "after"; break;
        case 4: retval = "inside"; break;
        case 6: retval = "before_syntax"; break;
        case 7: retval = "after_syntax"; break;
    }
    if (retval.empty()) {
        char buf[103];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(PreprocessingInfo::RelativePositionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PreprocessingInfo::RelativePositionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QCodeEdit::Position is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qcodeedit.h:47
/** Converts an enum of type QCodeEdit::Position to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQCodeEditPosition(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "West"; break;
        case 1: retval = "North"; break;
        case 2: retval = "South"; break;
        case 3: retval = "East"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QCodeEdit::Position)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QCodeEdit::Position::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QDocument::LineEnding is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocument.h:85
/** Converts an enum of type QDocument::LineEnding to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentLineEnding(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Conservative"; break;
        case 1: retval = "Local"; break;
        case 2: retval = "Unix"; break;
        case 3: retval = "Windows"; break;
        case 4: retval = "Mac"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QDocument::LineEnding)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocument::LineEnding::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QDocument::TextProcessing is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocument.h:94
/** Converts an enum of type QDocument::TextProcessing to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentTextProcessing(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "RemoveTrailingWS"; break;
        case 2: retval = "PreserveIndent"; break;
        case 4: retval = "RestoreTrailingIndent"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QDocument::TextProcessing)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocument::TextProcessing::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QDocument::WhiteSpaceFlag is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocument.h:101
/** Converts an enum of type QDocument::WhiteSpaceFlag to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentWhiteSpaceFlag(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ShowNone"; break;
        case 1: retval = "ShowTrailing"; break;
        case 2: retval = "ShowLeading"; break;
        case 4: retval = "ShowTabs"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QDocument::WhiteSpaceFlag)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocument::WhiteSpaceFlag::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QDocumentCommand::Command is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcommand.h:38
/** Converts an enum of type QDocumentCommand::Command to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentCommandCommand(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "None"; break;
        case 1: retval = "Insert"; break;
        case 2: retval = "Erase"; break;
        case 3: retval = "Replace"; break;
        case 4: retval = "Custom"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QDocumentCommand::Command)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentCommand::Command::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QDocumentCursor::MoveFlag is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor.h:40
/** Converts an enum of type QDocumentCursor::MoveFlag to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentCursorMoveFlag(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "MoveAnchor"; break;
        case 1: retval = "KeepAnchor"; break;
        case 2: retval = "ThroughWrap"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QDocumentCursor::MoveFlag)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentCursor::MoveFlag::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QDocumentCursor::MoveOperation is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor.h:49
/** Converts an enum of type QDocumentCursor::MoveOperation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentCursorMoveOperation(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NoMove"; break;
        case 1: retval = "Up"; break;
        case 2: retval = "Down"; break;
        case 3: retval = "Left"; break;
        case 4: retval = "Right"; break;
        case 5: retval = "Start"; break;
        case 6: retval = "StartOfLine"; break;
        case 7: retval = "StartOfWord"; break;
        case 8: retval = "PreviousBlock"; break;
        case 9: retval = "PreviousWord"; break;
        case 10: retval = "WordLeft"; break;
        case 11: retval = "WordRight"; break;
        case 12: retval = "End"; break;
        case 13: retval = "EndOfLine"; break;
        case 14: retval = "EndOfWord"; break;
        case 15: retval = "NextWord"; break;
        case 16: retval = "NextBlock"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QDocumentCursor::MoveOperation)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentCursor::MoveOperation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QDocumentCursor::SelectionType is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor.h:76
/** Converts an enum of type QDocumentCursor::SelectionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentCursorSelectionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "WordUnderCursor"; break;
        case 1: retval = "LineUnderCursor"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QDocumentCursor::SelectionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentCursor::SelectionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QDocumentCursorHandle::Flags is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor_p.h:53
/** Converts an enum of type QDocumentCursorHandle::Flags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentCursorHandleFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "Silent"; break;
        case 2: retval = "ColumnMemory"; break;
        case 4: retval = "MoveWithinWrapped"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QDocumentCursorHandle::Flags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentCursorHandle::Flags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QDocumentLine::State is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentline.h:70
/** Converts an enum of type QDocumentLine::State to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentLineState(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "None"; break;
        case 1: retval = "Hidden"; break;
        case 2: retval = "CollapsedBlockStart"; break;
        case 4: retval = "CollapsedBlockEnd"; break;
        case 16: retval = "LayoutDirty"; break;
        case 32: retval = "FormatsApplied"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QDocumentLine::State)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentLine::State::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QDocumentSearch::Option is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentsearch.h:41
/** Converts an enum of type QDocumentSearch::Option to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentSearchOption(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "WholeWords"; break;
        case 2: retval = "CaseSensitive"; break;
        case 4: retval = "RegExp"; break;
        case 8: retval = "Replace"; break;
        case 16: retval = "Prompt"; break;
        case 32: retval = "Silent"; break;
        case 64: retval = "HighlightAll"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QDocumentSearch::Option)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentSearch::Option::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QEditor::CodecUpdatePolicy is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qeditor.h:65
/** Converts an enum of type QEditor::CodecUpdatePolicy to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQEditorCodecUpdatePolicy(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NoUpdate"; break;
        case 1: retval = "UpdateOld"; break;
        case 2: retval = "UpdateDefault"; break;
        case 4: retval = "UpdateCustom"; break;
        case 7: retval = "UpdateAll"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QEditor::CodecUpdatePolicy)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QEditor::CodecUpdatePolicy::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QEditor::EditFlag is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qeditor.h:75
/** Converts an enum of type QEditor::EditFlag to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQEditorEditFlag(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "None"; break;
        case 1: retval = "Overwrite"; break;
        case 2: retval = "CursorOn"; break;
        case 4: retval = "ReadOnly"; break;
        case 8: retval = "MousePressed"; break;
        case 16: retval = "MaybeDrag"; break;
        case 32: retval = "Selection"; break;
        case 64: retval = "Persistent"; break;
        case 128: retval = "Multiline"; break;
        case 256: retval = "FoldedCursor"; break;
        case 4095: retval = "Internal"; break;
        case 4096: retval = "LineWrap"; break;
        case 65536: retval = "CtrlNavigation"; break;
        case 131072: retval = "CursorJumpPastWrap"; break;
        case 1048576: retval = "ReplaceTabs"; break;
        case 2097152: retval = "RemoveTrailing"; break;
        case 4194304: retval = "PreserveTrailingIndent"; break;
        case 16777216: retval = "AutoCloseChars"; break;
        case 33554432: retval = "AutoIndent"; break;
        case 4294963200: retval = "Accessible"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QEditor::EditFlag)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QEditor::EditFlag::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QEditor::SaveState is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qeditor.h:494
/** Converts an enum of type QEditor::SaveState to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQEditorSaveState(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Undefined"; break;
        case 1: retval = "Saving"; break;
        case 2: retval = "Saved"; break;
        case 3: retval = "Conflict"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QEditor::SaveState)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QEditor::SaveState::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QLanguageDefinition::CollapseFlag is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qlanguagedefinition.h:45
/** Converts an enum of type QLanguageDefinition::CollapseFlag to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQLanguageDefinitionCollapseFlag(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "None"; break;
        case 4095: retval = "OpenMask"; break;
        case 16773120: retval = "CloseMask"; break;
        case 268435456: retval = "Collapsible"; break;
        case 536870912: retval = "Collapsed"; break;
        case 1073741824: retval = "Closure"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QLanguageDefinition::CollapseFlag)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QLanguageDefinition::CollapseFlag::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QNFAAction::QNFAAction_ is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfadefinition.h:42
/** Converts an enum of type QNFAAction::QNFAAction_ to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQNFAActionQNFAAction_(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NoAction"; break;
        case 4095: retval = "FormatMask"; break;
        case 16773120: retval = "ParenMask"; break;
        case 16777216: retval = "Highlight"; break;
        case 33554432: retval = "Indent"; break;
        case 67108864: retval = "ParenOpen"; break;
        case 134217728: retval = "ParenClose"; break;
        case 268435456: retval = "MatchParen"; break;
        case 536870912: retval = "Fold"; break;
        case 1073741824: retval = "Ambiguous"; break;
        case 2147483648: retval = "Content"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QNFAAction::QNFAAction_)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QNFAAction::QNFAAction_::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QNFADefinition::PMatch::Type is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfadefinition.h:130
/** Converts an enum of type QNFADefinition::PMatch::Type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQNFADefinitionPMatchType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Invalid"; break;
        case 1: retval = "Match"; break;
        case 2: retval = "Mismatch"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QNFADefinition::PMatch::Type)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QNFADefinition::PMatch::Type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QPanelLayout::Position is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qpanellayout.h:39
/** Converts an enum of type QPanelLayout::Position to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQPanelLayoutPosition(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "West"; break;
        case 1: retval = "North"; break;
        case 2: retval = "South"; break;
        case 3: retval = "East"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QPanelLayout::Position)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QPanelLayout::Position::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QPanelLayout::SizeType is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qpanellayout.h:87
/** Converts an enum of type QPanelLayout::SizeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQPanelLayoutSizeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "MinimumSize"; break;
        case 1: retval = "SizeHint"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QPanelLayout::SizeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QPanelLayout::SizeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QParenthesis::Role is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentline.h:39
/** Converts an enum of type QParenthesis::Role to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQParenthesisRole(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "Open"; break;
        case 2: retval = "Close"; break;
        case 4: retval = "Indent"; break;
        case 8: retval = "Fold"; break;
        case 16: retval = "Match"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QParenthesis::Role)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QParenthesis::Role::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QReliableFileWatch::State is defined at src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qreliablefilewatch.h:53
/** Converts an enum of type QReliableFileWatch::State to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQReliableFileWatchState(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Clean"; break;
        case 1: retval = "Recent"; break;
        case 2: retval = "Duplicate"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QReliableFileWatch::State)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QReliableFileWatch::State::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QtColorLine::ColorComponent is defined at src/roseExtensions/qtWidgets/QtGradientEditor/qtcolorline.h:63
/** Converts an enum of type QtColorLine::ColorComponent to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQtColorLineColorComponent(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Red"; break;
        case 1: retval = "Green"; break;
        case 2: retval = "Blue"; break;
        case 3: retval = "Hue"; break;
        case 4: retval = "Saturation"; break;
        case 5: retval = "Value"; break;
        case 6: retval = "Alpha"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QtColorLine::ColorComponent)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QtColorLine::ColorComponent::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// QtGradientWidgetPrivate::Handle is defined at src/roseExtensions/qtWidgets/QtGradientEditor/qtgradientwidget.cpp:92
/** Converts an enum of type QtGradientWidgetPrivate::Handle to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQtGradientWidgetPrivateHandle(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NoHandle"; break;
        case 1: retval = "StartLinearHandle"; break;
        case 2: retval = "EndLinearHandle"; break;
        case 3: retval = "CentralRadialHandle"; break;
        case 4: retval = "FocalRadialHandle"; break;
        case 5: retval = "RadiusRadialHandle"; break;
        case 6: retval = "CentralConicalHandle"; break;
        case 7: retval = "AngleConicalHandle"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(QtGradientWidgetPrivate::Handle)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QtGradientWidgetPrivate::Handle::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// RIFG::EdgeDirection is defined at src/midend/programAnalysis/OpenAnalysis/CFG/RIFG.h:63
/** Converts an enum of type RIFG::EdgeDirection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRIFG_EdgeDirection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ED_INCOMING"; break;
        case 1: retval = "ED_OUTGOING"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(RIFG::EdgeDirection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RIFG::EdgeDirection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// RIFG::ForwardBackward is defined at src/midend/programAnalysis/OpenAnalysis/CFG/RIFG.h:64
/** Converts an enum of type RIFG::ForwardBackward to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRIFG_ForwardBackward(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FORWARD"; break;
        case 1: retval = "BACKWARD"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(RIFG::ForwardBackward)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RIFG::ForwardBackward::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// RITarjEdgeType is defined at src/midend/programAnalysis/OpenAnalysis/CFG/TarjanIntervals.h:67
/** Converts an enum of type RITarjEdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRITarjEdgeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "RI_TARJ_NORMAL"; break;
        case 1: retval = "RI_TARJ_LOOP_ENTRY"; break;
        case 2: retval = "RI_TARJ_IRRED_ENTRY"; break;
        case 3: retval = "RI_TARJ_ITERATE"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(RITarjEdgeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RITarjEdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// RITarjType is defined at src/midend/programAnalysis/OpenAnalysis/CFG/TarjanIntervals.h:65
/** Converts an enum of type RITarjType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRITarjType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "RI_TARJ_NOTHING"; break;
        case 1: retval = "RI_TARJ_ACYCLIC"; break;
        case 2: retval = "RI_TARJ_INTERVAL"; break;
        case 3: retval = "RI_TARJ_IRREDUCIBLE"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(RITarjType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RITarjType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// ROSEAttributesList::languageTypeEnum is defined at src/frontend/SageIII/rose_attributes_list.h:437
/** Converts an enum of type ROSEAttributesList::languageTypeEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSEAttributesList_languageTypeEnum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown_language"; break;
        case 1: retval = "e_C_language"; break;
        case 2: retval = "e_Cxx_language"; break;
        case 3: retval = "e_Fortran77_language"; break;
        case 4: retval = "e_Fortran9x_language"; break;
        case 5: retval = "e_lastLanguage"; break;
    }
    if (retval.empty()) {
        char buf[100];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(ROSEAttributesList::languageTypeEnum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSEAttributesList::languageTypeEnum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// ROSE_Fortran_Additional_Info is defined at src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h:168
/** Converts an enum of type ROSE_Fortran_Additional_Info to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_Additional_Info(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 10001: retval = "ROSE_FORT_COMMENTS"; break;
        case 10002: retval = "ROSE_STRING_LITERALS"; break;
        case 10003: retval = "ROSE_IDENTIFIER"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(ROSE_Fortran_Additional_Info)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_Additional_Info::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// ROSE_Fortran_Identifiers is defined at src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h:11
/** Converts an enum of type ROSE_Fortran_Identifiers to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_Identifiers(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 2: retval = "ROSE_ABSTRACT"; break;
        case 3: retval = "ROSE_ACCESS"; break;
        case 4: retval = "ROSE_ACTION"; break;
        case 5: retval = "ROSE_ALLOCATE"; break;
        case 6: retval = "ROSE_ALLOCATABLE"; break;
        case 7: retval = "ROSE_ASSIGN"; break;
        case 8: retval = "ROSE_ASSOCIATE"; break;
        case 9: retval = "ROSE_ASYNCHRONOUS"; break;
        case 10: retval = "ROSE_BACKSPACE"; break;
        case 11: retval = "ROSE_BIND"; break;
        case 12: retval = "ROSE_BLANK"; break;
        case 13: retval = "ROSE_BLOCK_DATA"; break;
        case 14: retval = "ROSE_CALL"; break;
        case 15: retval = "ROSE_CHARACTER"; break;
        case 16: retval = "ROSE_CLASS"; break;
        case 17: retval = "ROSE_CLOSE"; break;
        case 18: retval = "ROSE_CONTINUE"; break;
        case 19: retval = "ROSE_CYCLE"; break;
        case 20: retval = "ROSE_CASE"; break;
        case 21: retval = "ROSE_COMMON"; break;
        case 22: retval = "ROSE_COMPLEX"; break;
        case 23: retval = "ROSE_CONTAINS"; break;
        case 24: retval = "ROSE_DEALLOCATE"; break;
        case 25: retval = "ROSE_DATA"; break;
        case 26: retval = "ROSE_DEFERRED"; break;
        case 27: retval = "ROSE_DELIM"; break;
        case 28: retval = "ROSE_DIMENSION"; break;
        case 29: retval = "ROSE_DO"; break;
        case 30: retval = "ROSE_DT"; break;
        case 31: retval = "ROSE_DOUBLEPRECISION"; break;
        case 32: retval = "ROSE_ENCODING"; break;
        case 33: retval = "ROSE_END_CASE"; break;
        case 34: retval = "ROSE_ENDDO"; break;
        case 35: retval = "ROSE_END_FILE"; break;
        case 36: retval = "ROSE_END_ENUM"; break;
        case 37: retval = "ROSE_END_INTERFACE"; break;
        case 38: retval = "ROSE_END_TYPE"; break;
        case 39: retval = "ROSE_ERR"; break;
        case 40: retval = "ROSE_ERRMSG"; break;
        case 41: retval = "ROSE_EXIT"; break;
        case 42: retval = "ROSE_ELSE"; break;
        case 43: retval = "ROSE_ELSEWHERE"; break;
        case 44: retval = "ROSE_ELSEIF"; break;
        case 45: retval = "ROSE_ENDIF"; break;
        case 46: retval = "ROSE_ENTRY"; break;
        case 47: retval = "ROSE_END"; break;
        case 49: retval = "ROSE_ENUMERATOR"; break;
        case 50: retval = "ROSE_EQUIVALENCE"; break;
        case 51: retval = "ROSE_EXTERNAL"; break;
        case 52: retval = "ROSE_EXTENDS"; break;
        case 53: retval = "ROSE_FILE"; break;
        case 54: retval = "ROSE_FINAL"; break;
        case 55: retval = "ROSE_FMT"; break;
        case 56: retval = "ROSE_FORALL"; break;
        case 57: retval = "ROSE_FORM"; break;
        case 58: retval = "ROSE_FORMATTED"; break;
        case 59: retval = "ROSE_FORMAT"; break;
        case 60: retval = "ROSE_FLUSH"; break;
        case 61: retval = "ROSE_FUNCTION"; break;
        case 62: retval = "ROSE_GENERIC"; break;
        case 63: retval = "ROSE_GOTO"; break;
        case 64: retval = "ROSE_ID"; break;
        case 65: retval = "ROSE_IF"; break;
        case 66: retval = "ROSE_INQUIRE"; break;
        case 67: retval = "ROSE_INTEGER"; break;
        case 68: retval = "ROSE_IOMSG"; break;
        case 69: retval = "ROSE_IOSTAT"; break;
        case 70: retval = "ROSE_IMPLICIT"; break;
        case 71: retval = "ROSE_IMPLICIT_NONE"; break;
        case 72: retval = "ROSE_IMPORT"; break;
        case 73: retval = "ROSE_INTERFACE"; break;
        case 74: retval = "ROSE_INTENT"; break;
        case 75: retval = "ROSE_INTRINSIC"; break;
        case 76: retval = "ROSE_LEN"; break;
        case 77: retval = "ROSE_LOGICAL"; break;
        case 78: retval = "ROSE_KIND"; break;
        case 79: retval = "ROSE_MODULE_PROC"; break;
        case 80: retval = "ROSE_MODULE"; break;
        case 81: retval = "ROSE_NON_INTRINSIC"; break;
        case 82: retval = "ROSE_NON_OVERRIDABLE"; break;
        case 83: retval = "ROSE_NULL"; break;
        case 84: retval = "ROSE_NULLIFY"; break;
        case 85: retval = "ROSE_NAMELIST"; break;
        case 86: retval = "ROSE_NML"; break;
        case 87: retval = "ROSE_NONE"; break;
        case 88: retval = "ROSE_NOPASS"; break;
        case 89: retval = "ROSE_ONLY"; break;
        case 90: retval = "ROSE_OPEN"; break;
        case 91: retval = "ROSE_PARAMETER"; break;
        case 92: retval = "ROSE_PASS"; break;
        case 93: retval = "ROSE_PAUSE"; break;
        case 94: retval = "ROSE_POINTER"; break;
        case 96: retval = "ROSE_PRINT"; break;
        case 97: retval = "ROSE_PRIVATE"; break;
        case 98: retval = "ROSE_PROCEDURE"; break;
        case 99: retval = "ROSE_PROGRAM"; break;
        case 100: retval = "ROSE_PROTECTED"; break;
        case 101: retval = "ROSE_READ"; break;
        case 102: retval = "ROSE_REAL"; break;
        case 103: retval = "ROSE_RETURN"; break;
        case 104: retval = "ROSE_REWIND"; break;
        case 105: retval = "ROSE_ROUND"; break;
        case 106: retval = "ROSE_SELECTCASE"; break;
        case 107: retval = "ROSE_SELECTTYPE"; break;
        case 108: retval = "ROSE_SEQUENCE"; break;
        case 109: retval = "ROSE_SAVE"; break;
        case 110: retval = "ROSE_SIGN"; break;
        case 111: retval = "ROSE_SIZE"; break;
        case 112: retval = "ROSE_SOURCE"; break;
        case 113: retval = "ROSE_STAT"; break;
        case 114: retval = "ROSE_STOP"; break;
        case 115: retval = "ROSE_SUBROUTINE"; break;
        case 116: retval = "ROSE_TARGET"; break;
        case 117: retval = "ROSE_THEN"; break;
        case 118: retval = "ROSE_DERIVED_DECL"; break;
        case 119: retval = "ROSE_TYPEIS"; break;
        case 120: retval = "ROSE_UNFORMATTED"; break;
        case 121: retval = "ROSE_UNIT"; break;
        case 122: retval = "ROSE_USE"; break;
        case 123: retval = "ROSE_VALUE"; break;
        case 124: retval = "ROSE_VOLATILE"; break;
        case 125: retval = "ROSE_WAIT"; break;
        case 126: retval = "ROSE_WHERE"; break;
        case 127: retval = "ROSE_WRITE"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(ROSE_Fortran_Identifiers)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_Identifiers::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// ROSE_Fortran_Operators is defined at src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h:141
/** Converts an enum of type ROSE_Fortran_Operators to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_Operators(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1001: retval = "ROSE_INTRINSIC_PLUS"; break;
        case 1002: retval = "ROSE_INTRINSIC_MINUS"; break;
        case 1003: retval = "ROSE_INTRINSIC_POWER"; break;
        case 1004: retval = "ROSE_INTRINSIC_CONCAT"; break;
        case 1005: retval = "ROSE_INTRINSIC_TIMES"; break;
        case 1006: retval = "ROSE_INTRINSIC_DIVIDE"; break;
        case 1007: retval = "ROSE_INTRINSIC_AND"; break;
        case 1008: retval = "ROSE_INTRINSIC_OR"; break;
        case 1009: retval = "ROSE_INTRINSIC_EQV"; break;
        case 1010: retval = "ROSE_INTRINSIC_NEQV"; break;
        case 1011: retval = "ROSE_INTRINSIC_EQ"; break;
        case 1012: retval = "ROSE_INTRINSIC_NE"; break;
        case 1013: retval = "ROSE_INTRINSIC_GE"; break;
        case 1014: retval = "ROSE_INTRINSIC_LE"; break;
        case 1015: retval = "ROSE_INTRINSIC_LT"; break;
        case 1016: retval = "ROSE_INTRINSIC_GT"; break;
        case 1017: retval = "ROSE_INTRINSIC_NOT"; break;
        case 1018: retval = "ROSE_INTRINSIC_OLDEQ"; break;
        case 1019: retval = "ROSE_INTRINSIC_OLDNE"; break;
        case 1020: retval = "ROSE_INTRINSIC_OLDGE"; break;
        case 1021: retval = "ROSE_INTRINSIC_OLDLE"; break;
        case 1022: retval = "ROSE_INTRINSIC_OLDLT"; break;
        case 1023: retval = "ROSE_INTRINSIC_OLDGT"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(ROSE_Fortran_Operators)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_Operators::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// ROSE_Fortran_defs::ROSE_C_CXX_keywords is defined at src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h:148
/** Converts an enum of type ROSE_Fortran_defs::ROSE_C_CXX_keywords to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_defsROSE_C_CXX_keywords(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 500: retval = "C_CXX_ASM"; break;
        case 501: retval = "C_CXX_AUTO"; break;
        case 502: retval = "C_CXX_BOOL"; break;
        case 503: retval = "C_CXX_BREAK"; break;
        case 504: retval = "C_CXX_CASE"; break;
        case 505: retval = "C_CXX_CATCH"; break;
        case 506: retval = "C_CXX_CHAR"; break;
        case 507: retval = "C_CXX_CLASS"; break;
        case 508: retval = "C_CXX_CONST"; break;
        case 509: retval = "C_CXX_CONSTCAST"; break;
        case 510: retval = "C_CXX_CONTINUE"; break;
        case 511: retval = "C_CXX_DEFAULT"; break;
        case 512: retval = "C_CXX_DEFINED"; break;
        case 513: retval = "C_CXX_DELETE"; break;
        case 514: retval = "C_CXX_DO"; break;
        case 515: retval = "C_CXX_DOUBLE"; break;
        case 516: retval = "C_CXX_DYNAMICCAST"; break;
        case 517: retval = "C_CXX_ELSE"; break;
        case 518: retval = "C_CXX_ENUM"; break;
        case 519: retval = "C_CXX_EXPLICIT"; break;
        case 520: retval = "C_CXX_EXPORT"; break;
        case 521: retval = "C_CXX_EXTERN"; break;
        case 522: retval = "C_CXX_FALSE"; break;
        case 523: retval = "C_CXX_FLOAT"; break;
        case 524: retval = "C_CXX_FOR"; break;
        case 525: retval = "C_CXX_FRIEND"; break;
        case 526: retval = "C_CXX_GOTO"; break;
        case 527: retval = "C_CXX_IF"; break;
        case 528: retval = "C_CXX_INLINE"; break;
        case 529: retval = "C_CXX_INT"; break;
        case 530: retval = "C_CXX_LONG"; break;
        case 531: retval = "C_CXX_MUTABLE"; break;
        case 532: retval = "C_CXX_NAMESPACE"; break;
        case 533: retval = "C_CXX_NEW"; break;
        case 534: retval = "C_CXX_OPERATOR"; break;
        case 535: retval = "C_CXX_PRIVATE"; break;
        case 536: retval = "C_CXX_PROTECTED"; break;
        case 537: retval = "C_CXX_PUBLIC"; break;
        case 538: retval = "C_CXX_REGISTER"; break;
        case 539: retval = "C_CXX_REINTERPRETCAST"; break;
        case 540: retval = "C_CXX_RETURN"; break;
        case 541: retval = "C_CXX_SHORT"; break;
        case 542: retval = "C_CXX_SIGNED"; break;
        case 543: retval = "C_CXX_SIZEOF"; break;
        case 544: retval = "C_CXX_STATIC"; break;
        case 545: retval = "C_CXX_STATICCAST"; break;
        case 546: retval = "C_CXX_STRUCT"; break;
        case 547: retval = "C_CXX_SWITCH"; break;
        case 548: retval = "C_CXX_TEMPLATE"; break;
        case 549: retval = "C_CXX_THIS"; break;
        case 550: retval = "C_CXX_THROW"; break;
        case 551: retval = "C_CXX_TRY"; break;
        case 552: retval = "C_CXX_TRUE"; break;
        case 553: retval = "C_CXX_TYPEDEF"; break;
        case 554: retval = "C_CXX_TYPEID"; break;
        case 555: retval = "C_CXX_TYPENAME"; break;
        case 556: retval = "C_CXX_UNION"; break;
        case 557: retval = "C_CXX_UNSIGNED"; break;
        case 558: retval = "C_CXX_USING"; break;
        case 559: retval = "C_CXX_VIRTUAL"; break;
        case 560: retval = "C_CXX_VOID"; break;
        case 561: retval = "C_CXX_VOLATILE"; break;
        case 562: retval = "C_CXX_WCHART"; break;
        case 563: retval = "C_CXX_WHILE"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(ROSE_Fortran_defs::ROSE_C_CXX_keywords)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_defs::ROSE_C_CXX_keywords::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// ROSE_Fortran_defs::ROSE_C_CXX_operators is defined at src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h:243
/** Converts an enum of type ROSE_Fortran_defs::ROSE_C_CXX_operators to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_defsROSE_C_CXX_operators(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 50000: retval = "C_CXX_AND"; break;
        case 50001: retval = "C_CXX_ANDAND"; break;
        case 50002: retval = "C_CXX_ASSIGN"; break;
        case 50003: retval = "C_CXX_ANDASSIGN"; break;
        case 50004: retval = "C_CXX_OR"; break;
        case 50005: retval = "C_CXX_ORASSIGN"; break;
        case 50006: retval = "C_CXX_XOR"; break;
        case 50007: retval = "C_CXX_XORASSIGN"; break;
        case 50008: retval = "C_CXX_COMMA"; break;
        case 50009: retval = "C_CXX_COLON"; break;
        case 50010: retval = "C_CXX_DIVIDE"; break;
        case 50011: retval = "C_CXX_DIVIDEASSIGN"; break;
        case 50012: retval = "C_CXX_DOT"; break;
        case 50013: retval = "C_CXX_DOTSTAR"; break;
        case 50014: retval = "C_CXX_ELLIPSIS"; break;
        case 50015: retval = "C_CXX_EQUAL"; break;
        case 50016: retval = "C_CXX_GREATER"; break;
        case 50017: retval = "C_CXX_GREATEREQUAL"; break;
        case 50018: retval = "C_CXX_LEFTBRACE"; break;
        case 50019: retval = "C_CXX_LESS"; break;
        case 50020: retval = "C_CXX_LESSEQUAL"; break;
        case 50021: retval = "C_CXX_LEFTPAREN"; break;
        case 50022: retval = "C_CXX_LEFTBRACKET"; break;
        case 50023: retval = "C_CXX_MINUS"; break;
        case 50024: retval = "C_CXX_MINUSASSIGN"; break;
        case 50025: retval = "C_CXX_MINUSMINUS"; break;
        case 50026: retval = "C_CXX_PERCENT"; break;
        case 50027: retval = "C_CXX_PERCENTASSIGN"; break;
        case 50028: retval = "C_CXX_NOT"; break;
        case 50029: retval = "C_CXX_NOTEQUAL"; break;
        case 50030: retval = "C_CXX_OROR"; break;
        case 50031: retval = "C_CXX_PLUS"; break;
        case 50032: retval = "C_CXX_PLUSASSIGN"; break;
        case 50033: retval = "C_CXX_PLUSPLUS"; break;
        case 50034: retval = "C_CXX_ARROW"; break;
        case 50035: retval = "C_CXX_ARROWSTAR"; break;
        case 50036: retval = "C_CXX_QUESTION_MARK"; break;
        case 50037: retval = "C_CXX_RIGHTBRACE"; break;
        case 50038: retval = "C_CXX_RIGHTPAREN"; break;
        case 50039: retval = "C_CXX_RIGHTBRACKET"; break;
        case 50040: retval = "C_CXX_COLON_COLON"; break;
        case 50041: retval = "C_CXX_SEMICOLON"; break;
        case 50042: retval = "C_CXX_SHIFTLEFT"; break;
        case 50043: retval = "C_CXX_SHIFTLEFTASSIGN"; break;
        case 50044: retval = "C_CXX_SHIFTRIGHT"; break;
        case 50045: retval = "C_CXX_SHIFTRIGHTASSIGN"; break;
        case 50046: retval = "C_CXX_STAR"; break;
        case 50047: retval = "C_CXX_COMPL"; break;
        case 50048: retval = "C_CXX_STARASSIGN"; break;
        case 50049: retval = "C_CXX_POUND_POUND"; break;
        case 50050: retval = "C_CXX_POUND"; break;
        case 50051: retval = "C_CXX_AND_ALT"; break;
        case 50052: retval = "C_CXX_ANDASSIGN_ALT"; break;
        case 50053: retval = "C_CXX_OR_ALT"; break;
        case 50054: retval = "C_CXX_ORASSIGN_ALT"; break;
        case 50055: retval = "C_CXX_XOR_ALT"; break;
        case 50056: retval = "C_CXX_XORASSIGN_ALT"; break;
        case 50057: retval = "C_CXX_LEFTBRACE_ALT"; break;
        case 50058: retval = "C_CXX_LEFTBRACKET_ALT"; break;
        case 50059: retval = "C_CXX_NOT_ALT"; break;
        case 50060: retval = "C_CXX_NOTEQUAL_ALT"; break;
        case 50061: retval = "C_CXX_RIGHTBRACE_ALT"; break;
        case 50062: retval = "C_CXX_RIGHTBRACKET_ALT"; break;
        case 50063: retval = "C_CXX_COMPL_ALT"; break;
        case 50064: retval = "C_CXX_POUND_POUND_ALT"; break;
        case 50065: retval = "C_CXX_POUND_ALT"; break;
        case 50066: retval = "C_CXX_OR_TRIGRAPH"; break;
        case 50067: retval = "C_CXX_XOR_TRIGRAPH"; break;
        case 50068: retval = "C_CXX_LEFTBRACE_TRIGRAPH"; break;
        case 50069: retval = "C_CXX_LEFTBRACKET_TRIGRAPH"; break;
        case 50070: retval = "C_CXX_RIGHTBRACE_TRIGRAPH"; break;
        case 50071: retval = "C_CXX_RIGHTBRACKET_TRIGRAPH"; break;
        case 50072: retval = "C_CXX_COMPL_TRIGRAPH"; break;
        case 50073: retval = "C_CXX_POUND_POUND_TRIGRAPH"; break;
        case 50074: retval = "C_CXX_POUND_TRIGRAPH"; break;
    }
    if (retval.empty()) {
        char buf[103];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(ROSE_Fortran_defs::ROSE_C_CXX_operators)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_defs::ROSE_C_CXX_operators::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// ROSE_Fortran_defs::ROSE_Fortran_Additional_Info is defined at src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h:322
/** Converts an enum of type ROSE_Fortran_defs::ROSE_Fortran_Additional_Info to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_defsROSE_Fortran_Additional_Info(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 100000: retval = "FORTRAN_COMMENTS"; break;
        case 100001: retval = "FORTRAN_STRING_LITERALS"; break;
        case 100002: retval = "FORTRAN_IDENTIFIER"; break;
        case 100003: retval = "FORTRAN_UNIDENTIFIED_TOKEN"; break;
        case 100004: retval = "FORTRAN_ERROR"; break;
    }
    if (retval.empty()) {
        char buf[111];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(ROSE_Fortran_defs::ROSE_Fortran_Additional_Info)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_defs::ROSE_Fortran_Additional_Info::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// ROSE_Fortran_defs::ROSE_Fortran_Operators is defined at src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h:216
/** Converts an enum of type ROSE_Fortran_defs::ROSE_Fortran_Operators to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_defsROSE_Fortran_Operators(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 10000: retval = "FORTRAN_INTRINSIC_PLUS"; break;
        case 10001: retval = "FORTRAN_INTRINSIC_MINUS"; break;
        case 10002: retval = "FORTRAN_INTRINSIC_POWER"; break;
        case 10003: retval = "FORTRAN_INTRINSIC_CONCAT"; break;
        case 10004: retval = "FORTRAN_INTRINSIC_TIMES"; break;
        case 10005: retval = "FORTRAN_INTRINSIC_DIVIDE"; break;
        case 10006: retval = "FORTRAN_INTRINSIC_AND"; break;
        case 10007: retval = "FORTRAN_INTRINSIC_OR"; break;
        case 10008: retval = "FORTRAN_INTRINSIC_EQV"; break;
        case 10009: retval = "FORTRAN_INTRINSIC_NEQV"; break;
        case 10010: retval = "FORTRAN_INTRINSIC_EQ"; break;
        case 10011: retval = "FORTRAN_INTRINSIC_NE"; break;
        case 10012: retval = "FORTRAN_INTRINSIC_GE"; break;
        case 10013: retval = "FORTRAN_INTRINSIC_LE"; break;
        case 10014: retval = "FORTRAN_INTRINSIC_LT"; break;
        case 10015: retval = "FORTRAN_INTRINSIC_GT"; break;
        case 10016: retval = "FORTRAN_INTRINSIC_NOT"; break;
        case 10017: retval = "FORTRAN_INTRINSIC_OLDEQ"; break;
        case 10018: retval = "FORTRAN_INTRINSIC_OLDNE"; break;
        case 10019: retval = "FORTRAN_INTRINSIC_OLDGE"; break;
        case 10020: retval = "FORTRAN_INTRINSIC_OLDLE"; break;
        case 10021: retval = "FORTRAN_INTRINSIC_OLDLT"; break;
        case 10022: retval = "FORTRAN_INTRINSIC_OLDGT"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(ROSE_Fortran_defs::ROSE_Fortran_Operators)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_defs::ROSE_Fortran_Operators::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// ROSE_Fortran_defs::ROSE_Fortran_keywords is defined at src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h:15
/** Converts an enum of type ROSE_Fortran_defs::ROSE_Fortran_keywords to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_defsROSE_Fortran_keywords(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FORTRAN_ABSTRACT"; break;
        case 1: retval = "FORTRAN_ACCESS"; break;
        case 2: retval = "FORTRAN_ACTION"; break;
        case 3: retval = "FORTRAN_ALLOCATE"; break;
        case 4: retval = "FORTRAN_ALLOCATABLE"; break;
        case 5: retval = "FORTRAN_ASSIGN"; break;
        case 6: retval = "FORTRAN_ASSOCIATE"; break;
        case 7: retval = "FORTRAN_ASYNCHRONOUS"; break;
        case 8: retval = "FORTRAN_BACKSPACE"; break;
        case 9: retval = "FORTRAN_BIND"; break;
        case 10: retval = "FORTRAN_BLANK"; break;
        case 11: retval = "FORTRAN_BLOCK_DATA"; break;
        case 12: retval = "FORTRAN_CALL"; break;
        case 13: retval = "FORTRAN_CHARACTER"; break;
        case 14: retval = "FORTRAN_CLASS"; break;
        case 15: retval = "FORTRAN_CLOSE"; break;
        case 16: retval = "FORTRAN_CONTINUE"; break;
        case 17: retval = "FORTRAN_CYCLE"; break;
        case 18: retval = "FORTRAN_CASE"; break;
        case 19: retval = "FORTRAN_COMMON"; break;
        case 20: retval = "FORTRAN_COMPLEX"; break;
        case 21: retval = "FORTRAN_CONTAINS"; break;
        case 22: retval = "FORTRAN_DEALLOCATE"; break;
        case 23: retval = "FORTRAN_DATA"; break;
        case 24: retval = "FORTRAN_DEFERRED"; break;
        case 25: retval = "FORTRAN_DELIM"; break;
        case 26: retval = "FORTRAN_DIMENSION"; break;
        case 27: retval = "FORTRAN_DO"; break;
        case 28: retval = "FORTRAN_DT"; break;
        case 29: retval = "FORTRAN_DOUBLEPRECISION"; break;
        case 30: retval = "FORTRAN_ENCODING"; break;
        case 31: retval = "FORTRAN_END_CASE"; break;
        case 32: retval = "FORTRAN_ENDDO"; break;
        case 33: retval = "FORTRAN_END_FILE"; break;
        case 34: retval = "FORTRAN_END_ENUM"; break;
        case 35: retval = "FORTRAN_END_INTERFACE"; break;
        case 36: retval = "FORTRAN_END_TYPE"; break;
        case 37: retval = "FORTRAN_ERR"; break;
        case 38: retval = "FORTRAN_ERRMSG"; break;
        case 39: retval = "FORTRAN_EXIT"; break;
        case 40: retval = "FORTRAN_ELSE"; break;
        case 41: retval = "FORTRAN_ELSEWHERE"; break;
        case 42: retval = "FORTRAN_ELSEIF"; break;
        case 43: retval = "FORTRAN_ENDIF"; break;
        case 44: retval = "FORTRAN_ENTRY"; break;
        case 45: retval = "FORTRAN_END"; break;
        case 46: retval = "FORTRAN_ENUM"; break;
        case 47: retval = "FORTRAN_ENUMERATOR"; break;
        case 48: retval = "FORTRAN_EQUIVALENCE"; break;
        case 49: retval = "FORTRAN_EXTERNAL"; break;
        case 50: retval = "FORTRAN_EXTENDS"; break;
        case 51: retval = "FORTRAN_FILE"; break;
        case 52: retval = "FORTRAN_FINAL"; break;
        case 53: retval = "FORTRAN_FMT"; break;
        case 54: retval = "FORTRAN_FORALL"; break;
        case 55: retval = "FORTRAN_FORM"; break;
        case 56: retval = "FORTRAN_FORMATTED"; break;
        case 57: retval = "FORTRAN_FORMAT"; break;
        case 58: retval = "FORTRAN_FLUSH"; break;
        case 59: retval = "FORTRAN_FUNCTION"; break;
        case 60: retval = "FORTRAN_GENERIC"; break;
        case 61: retval = "FORTRAN_GOTO"; break;
        case 62: retval = "FORTRAN_ID"; break;
        case 63: retval = "FORTRAN_IF"; break;
        case 64: retval = "FORTRAN_INQUIRE"; break;
        case 65: retval = "FORTRAN_INTEGER"; break;
        case 66: retval = "FORTRAN_IOMSG"; break;
        case 67: retval = "FORTRAN_IOSTAT"; break;
        case 68: retval = "FORTRAN_IMPLICIT"; break;
        case 69: retval = "FORTRAN_IMPLICIT_NONE"; break;
        case 70: retval = "FORTRAN_IMPORT"; break;
        case 71: retval = "FORTRAN_INTERFACE"; break;
        case 72: retval = "FORTRAN_INTENT"; break;
        case 73: retval = "FORTRAN_INTRINSIC"; break;
        case 74: retval = "FORTRAN_LEN"; break;
        case 75: retval = "FORTRAN_LOGICAL"; break;
        case 76: retval = "FORTRAN_KIND"; break;
        case 77: retval = "FORTRAN_MODULE_PROC"; break;
        case 78: retval = "FORTRAN_MODULE"; break;
        case 79: retval = "FORTRAN_NON_INTRINSIC"; break;
        case 80: retval = "FORTRAN_NON_OVERRIDABLE"; break;
        case 81: retval = "FORTRAN_NULL"; break;
        case 82: retval = "FORTRAN_NULLIFY"; break;
        case 83: retval = "FORTRAN_NAMELIST"; break;
        case 84: retval = "FORTRAN_NML"; break;
        case 85: retval = "FORTRAN_NONE"; break;
        case 86: retval = "FORTRAN_NOPASS"; break;
        case 87: retval = "FORTRAN_ONLY"; break;
        case 88: retval = "FORTRAN_OPEN"; break;
        case 89: retval = "FORTRAN_OPTIONAL"; break;
        case 90: retval = "FORTRAN_PARAMETER"; break;
        case 91: retval = "FORTRAN_PASS"; break;
        case 92: retval = "FORTRAN_PAUSE"; break;
        case 93: retval = "FORTRAN_POINTER"; break;
        case 94: retval = "FORTRAN_PRINT"; break;
        case 95: retval = "FORTRAN_PRIVATE"; break;
        case 96: retval = "FORTRAN_PROCEDURE"; break;
        case 97: retval = "FORTRAN_PROGRAM"; break;
        case 98: retval = "FORTRAN_PROTECTED"; break;
        case 99: retval = "FORTRAN_READ"; break;
        case 100: retval = "FORTRAN_REAL"; break;
        case 101: retval = "FORTRAN_RETURN"; break;
        case 102: retval = "FORTRAN_REWIND"; break;
        case 103: retval = "FORTRAN_ROUND"; break;
        case 104: retval = "FORTRAN_SELECTCASE"; break;
        case 105: retval = "FORTRAN_SELECTTYPE"; break;
        case 106: retval = "FORTRAN_SEQUENCE"; break;
        case 107: retval = "FORTRAN_SAVE"; break;
        case 108: retval = "FORTRAN_SIGN"; break;
        case 109: retval = "FORTRAN_SIZE"; break;
        case 110: retval = "FORTRAN_SOURCE"; break;
        case 111: retval = "FORTRAN_STAT"; break;
        case 112: retval = "FORTRAN_STOP"; break;
        case 113: retval = "FORTRAN_SUBROUTINE"; break;
        case 114: retval = "FORTRAN_TARGET"; break;
        case 115: retval = "FORTRAN_THEN"; break;
        case 116: retval = "FORTRAN_DERIVED_DECL"; break;
        case 117: retval = "FORTRAN_TYPEIS"; break;
        case 118: retval = "FORTRAN_UNFORMATTED"; break;
        case 119: retval = "FORTRAN_UNIT"; break;
        case 120: retval = "FORTRAN_USE"; break;
        case 121: retval = "FORTRAN_VALUE"; break;
        case 122: retval = "FORTRAN_VOLATILE"; break;
        case 123: retval = "FORTRAN_WAIT"; break;
        case 124: retval = "FORTRAN_WHERE"; break;
        case 125: retval = "FORTRAN_WRITE"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(ROSE_Fortran_defs::ROSE_Fortran_keywords)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_defs::ROSE_Fortran_keywords::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// RoseBin_Arch::Architecture is defined at src/frontend/BinaryDisassembly/RoseBin_support.h:50
/** Converts an enum of type RoseBin_Arch::Architecture to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRoseBin_ArchArchitecture(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "bit32"; break;
        case 1: retval = "bit64"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(RoseBin_Arch::Architecture)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RoseBin_Arch::Architecture::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// RoseBin_DataTypes::DataTypes is defined at src/frontend/BinaryDisassembly/RoseBin_support.h:85
/** Converts an enum of type RoseBin_DataTypes::DataTypes to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRoseBin_DataTypesDataTypes(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "unknown"; break;
        case 1: retval = "d_none"; break;
        case 2: retval = "d_int"; break;
        case 3: retval = "d_uint"; break;
        case 4: retval = "d_struct"; break;
        case 5: retval = "d_char_p"; break;
        case 6: retval = "d_size_t"; break;
        case 7: retval = "d_const_char_p"; break;
        case 8: retval = "d_pid_t"; break;
        case 9: retval = "d_uint_p"; break;
        case 10: retval = "d_long"; break;
        case 11: retval = "d_array"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(RoseBin_DataTypes::DataTypes)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RoseBin_DataTypes::DataTypes::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// RoseBin_Def::RoseLanguage is defined at src/frontend/BinaryDisassembly/RoseBin_support.h:31
/** Converts an enum of type RoseBin_Def::RoseLanguage to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRoseBin_DefRoseLanguage(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "none"; break;
        case 1: retval = "x86"; break;
        case 2: retval = "arm"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(RoseBin_Def::RoseLanguage)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RoseBin_Def::RoseLanguage::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// RoseBin_OS::OSSYSTEM is defined at src/frontend/BinaryDisassembly/RoseBin_support.h:41
/** Converts an enum of type RoseBin_OS::OSSYSTEM to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRoseBin_OS_OSSYSTEM(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "linux_op"; break;
        case 1: retval = "windows_op"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(RoseBin_OS::OSSYSTEM)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RoseBin_OS::OSSYSTEM::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// RoseBin_OS_VER::OS_VERSION is defined at src/frontend/BinaryDisassembly/RoseBin_support.h:59
/** Converts an enum of type RoseBin_OS_VER::OS_VERSION to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRoseBin_OS_VER_OS_VERSION(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "linux_22"; break;
        case 1: retval = "linux_24"; break;
        case 2: retval = "linux_26"; break;
        case 3: retval = "linux_27"; break;
        case 4: retval = "NT_SP3"; break;
        case 5: retval = "NT_SP4"; break;
        case 6: retval = "NT_SP5"; break;
        case 7: retval = "NT_SP6"; break;
        case 8: retval = "Win2000_SP0"; break;
        case 9: retval = "Win2000_SP1"; break;
        case 10: retval = "Win2000_SP2"; break;
        case 11: retval = "Win2000_SP3"; break;
        case 12: retval = "Win2000_SP4"; break;
        case 13: retval = "WinXP_SP0"; break;
        case 14: retval = "WinXP_SP1"; break;
        case 15: retval = "WinXP_SP2"; break;
        case 16: retval = "WinVista_SP0"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(RoseBin_OS_VER::OS_VERSION)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RoseBin_OS_VER::OS_VERSION::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// RoseBin_support::X86PositionInRegister is defined at src/frontend/BinaryDisassembly/RoseBin_support.h:174
/** Converts an enum of type RoseBin_support::X86PositionInRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRoseBin_supportX86PositionInRegister(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_regpos_unknown"; break;
        case 1: retval = "x86_regpos_low_byte"; break;
        case 2: retval = "x86_regpos_high_byte"; break;
        case 3: retval = "x86_regpos_word"; break;
        case 4: retval = "x86_regpos_dword"; break;
        case 5: retval = "x86_regpos_qword"; break;
        case 6: retval = "x86_regpos_all"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(RoseBin_support::X86PositionInRegister)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RoseBin_support::X86PositionInRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAccessModifier::access_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:9358
/** Converts an enum of type SgAccessModifier::access_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAccessModifier_access_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_private"; break;
        case 2: retval = "e_protected"; break;
        case 3: retval = "e_public"; break;
        case 4: retval = "e_undefined"; break;
        case 5: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAccessModifier::access_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAccessModifier::access_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmArmRegisterReferenceExpression::arm_suffix_field_enum is defined at frontend/SageIII/Cxx_Grammar.h:209500
/** Converts an enum of type SgAsmArmRegisterReferenceExpression::arm_suffix_field_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmArmRegisterReferenceExpression_arm_suffix_field_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "undefined_position_in_suffix"; break;
        case 1: retval = "c"; break;
        case 2: retval = "x"; break;
        case 4: retval = "s"; break;
        case 8: retval = "f"; break;
        case 9: retval = "last_position_in_suffix"; break;
    }
    if (retval.empty()) {
        char buf[122];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmArmRegisterReferenceExpression::arm_suffix_field_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmArmRegisterReferenceExpression::arm_suffix_field_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmElfDynamicEntry::EntryType is defined at frontend/SageIII/Cxx_Grammar.h:247094
/** Converts an enum of type SgAsmElfDynamicEntry::EntryType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfDynamicEntryEntryType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "DT_NULL"; break;
        case 1: retval = "DT_NEEDED"; break;
        case 2: retval = "DT_PLTRELSZ"; break;
        case 3: retval = "DT_PLTGOT"; break;
        case 4: retval = "DT_HASH"; break;
        case 5: retval = "DT_STRTAB"; break;
        case 6: retval = "DT_SYMTAB"; break;
        case 7: retval = "DT_RELA"; break;
        case 8: retval = "DT_RELASZ"; break;
        case 9: retval = "DT_RELAENT"; break;
        case 10: retval = "DT_STRSZ"; break;
        case 11: retval = "DT_SYMENT"; break;
        case 12: retval = "DT_INIT"; break;
        case 13: retval = "DT_FINI"; break;
        case 14: retval = "DT_SONAME"; break;
        case 15: retval = "DT_RPATH"; break;
        case 16: retval = "DT_SYMBOLIC"; break;
        case 17: retval = "DT_REL"; break;
        case 18: retval = "DT_RELSZ"; break;
        case 19: retval = "DT_RELENT"; break;
        case 20: retval = "DT_PLTREL"; break;
        case 21: retval = "DT_DEBUG"; break;
        case 22: retval = "DT_TEXTREL"; break;
        case 23: retval = "DT_JMPREL"; break;
        case 24: retval = "DT_BIND_NOW"; break;
        case 25: retval = "DT_INIT_ARRAY"; break;
        case 26: retval = "DT_FINI_ARRAY"; break;
        case 27: retval = "DT_INIT_ARRAYSZ"; break;
        case 28: retval = "DT_FINI_ARRAYSZ"; break;
        case 29: retval = "DT_RUNPATH"; break;
        case 30: retval = "DT_FLAGS"; break;
        case 32: retval = "DT_PREINIT_ARRAY"; break;
        case 33: retval = "DT_PREINIT_ARRAYSZ"; break;
        case 34: retval = "DT_NUM"; break;
        case 1879047669: retval = "DT_GNU_PRELINKED"; break;
        case 1879047670: retval = "DT_GNU_CONFLICTSZ"; break;
        case 1879047671: retval = "DT_GNU_LIBLISTSZ"; break;
        case 1879047672: retval = "DT_CHECKSUM"; break;
        case 1879047673: retval = "DT_PLTPADSZ"; break;
        case 1879047674: retval = "DT_MOVEENT"; break;
        case 1879047675: retval = "DT_MOVESZ"; break;
        case 1879047676: retval = "DT_FEATURE_1"; break;
        case 1879047677: retval = "DT_POSFLAG_1"; break;
        case 1879047678: retval = "DT_SYMINSZ"; break;
        case 1879047679: retval = "DT_SYMINENT"; break;
        case 1879047925: retval = "DT_GNU_HASH"; break;
        case 1879047926: retval = "DT_TLSDESC_PLT"; break;
        case 1879047927: retval = "DT_TLSDESC_GOT"; break;
        case 1879047928: retval = "DT_GNU_CONFLICT"; break;
        case 1879047929: retval = "DT_GNU_LIBLIST"; break;
        case 1879047930: retval = "DT_CONFIG"; break;
        case 1879047931: retval = "DT_DEPAUDIT"; break;
        case 1879047932: retval = "DT_AUDIT"; break;
        case 1879047933: retval = "DT_PLTPAD"; break;
        case 1879047934: retval = "DT_MOVETAB"; break;
        case 1879047935: retval = "DT_SYMINFO"; break;
        case 1879048176: retval = "DT_VERSYM"; break;
        case 1879048185: retval = "DT_RELACOUNT"; break;
        case 1879048186: retval = "DT_RELCOUNT"; break;
        case 1879048187: retval = "DT_FLAGS_1"; break;
        case 1879048188: retval = "DT_VERDEF"; break;
        case 1879048189: retval = "DT_VERDEFNUM"; break;
        case 1879048190: retval = "DT_VERNEED"; break;
        case 1879048191: retval = "DT_VERNEEDNUM"; break;
        case 2147483645: retval = "DT_AUXILIARY"; break;
        case 2147483647: retval = "DT_FILTER"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmElfDynamicEntry::EntryType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfDynamicEntry::EntryType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmElfFileHeader::ObjectType is defined at frontend/SageIII/Cxx_Grammar.h:224099
/** Converts an enum of type SgAsmElfFileHeader::ObjectType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfFileHeaderObjectType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ET_NONE"; break;
        case 1: retval = "ET_REL"; break;
        case 2: retval = "ET_EXEC"; break;
        case 3: retval = "ET_DYN"; break;
        case 4: retval = "ET_CORE"; break;
        case 65024: retval = "ET_LOOS"; break;
        case 65279: retval = "ET_HIOS"; break;
        case 65280: retval = "ET_LOPROC"; break;
        case 65535: retval = "ET_HIPROC"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmElfFileHeader::ObjectType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfFileHeader::ObjectType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmElfRelocEntry::RelocType is defined at frontend/SageIII/Cxx_Grammar.h:245305
/** Converts an enum of type SgAsmElfRelocEntry::RelocType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfRelocEntryRelocType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "R_386_NONE"; break;
        case 1: retval = "R_386_32"; break;
        case 2: retval = "R_386_PC32"; break;
        case 3: retval = "R_386_GOT32"; break;
        case 4: retval = "R_386_PLT32"; break;
        case 5: retval = "R_386_COPY"; break;
        case 6: retval = "R_386_GLOB_DAT"; break;
        case 7: retval = "R_386_JMP_SLOT"; break;
        case 8: retval = "R_386_RELATIVE"; break;
        case 9: retval = "R_386_GOTOFF"; break;
        case 10: retval = "R_386_GOTPC"; break;
        case 11: retval = "R_386_32PLT"; break;
        case 14: retval = "R_386_TLS_TPOFF"; break;
        case 15: retval = "R_386_TLS_IE"; break;
        case 16: retval = "R_386_TLS_GOTIE"; break;
        case 17: retval = "R_386_TLS_LE"; break;
        case 18: retval = "R_386_TLS_GD"; break;
        case 19: retval = "R_386_TLS_LDM"; break;
        case 20: retval = "R_386_16"; break;
        case 21: retval = "R_386_PC16"; break;
        case 22: retval = "R_386_8"; break;
        case 23: retval = "R_386_PC8"; break;
        case 24: retval = "R_386_TLS_GD_32"; break;
        case 25: retval = "R_386_TLS_GD_PUSH"; break;
        case 26: retval = "R_386_TLS_GD_CALL"; break;
        case 27: retval = "R_386_TLS_GD_POP"; break;
        case 28: retval = "R_386_TLS_LDM_32"; break;
        case 29: retval = "R_386_TLS_LDM_PUSH"; break;
        case 30: retval = "R_386_TLS_LDM_CALL"; break;
        case 31: retval = "R_386_TLS_LDM_POP"; break;
        case 32: retval = "R_386_TLS_LDO_32"; break;
        case 33: retval = "R_386_TLS_IE_32"; break;
        case 34: retval = "R_386_TLS_LE_32"; break;
        case 35: retval = "R_386_TLS_DTPMOD32"; break;
        case 36: retval = "R_386_TLS_DTPOFF32"; break;
        case 37: retval = "R_386_TLS_TPOFF32"; break;
        case 100: retval = "R_X86_64_NONE"; break;
        case 101: retval = "R_X86_64_64"; break;
        case 102: retval = "R_X86_64_PC32"; break;
        case 103: retval = "R_X86_64_GOT32"; break;
        case 104: retval = "R_X86_64_PLT32"; break;
        case 105: retval = "R_X86_64_COPY"; break;
        case 106: retval = "R_X86_64_GLOB_DAT"; break;
        case 107: retval = "R_X86_64_JUMP_SLOT"; break;
        case 108: retval = "R_X86_64_RELATIVE"; break;
        case 109: retval = "R_X86_64_GOTPCREL"; break;
        case 110: retval = "R_X86_64_32"; break;
        case 111: retval = "R_X86_64_32S"; break;
        case 112: retval = "R_X86_64_16"; break;
        case 113: retval = "R_X86_64_PC16"; break;
        case 114: retval = "R_X86_64_8"; break;
        case 115: retval = "R_X86_64_PC8"; break;
        case 116: retval = "R_X86_64_DTPMOD64"; break;
        case 117: retval = "R_X86_64_DTPOFF64"; break;
        case 118: retval = "R_X86_64_TPOFF64"; break;
        case 119: retval = "R_X86_64_TLSGD"; break;
        case 120: retval = "R_X86_64_TLSLD"; break;
        case 121: retval = "R_X86_64_DTPOFF32"; break;
        case 122: retval = "R_X86_64_GOTTPOFF"; break;
        case 123: retval = "R_X86_64_TPOFF32"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmElfRelocEntry::RelocType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfRelocEntry::RelocType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmElfSectionTableEntry::SectionFlags is defined at frontend/SageIII/Cxx_Grammar.h:243308
/** Converts an enum of type SgAsmElfSectionTableEntry::SectionFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfSectionTableEntrySectionFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SHF_NULL"; break;
        case 1: retval = "SHF_WRITE"; break;
        case 2: retval = "SHF_ALLOC"; break;
        case 4: retval = "SHF_EXECINSTR"; break;
        case 16: retval = "SHF_MERGE"; break;
        case 32: retval = "SHF_STRINGS"; break;
        case 64: retval = "SHF_INFO_LINK"; break;
        case 128: retval = "SHF_LINK_ORDER"; break;
        case 256: retval = "SHF_OS_NONCONFORMING"; break;
        case 512: retval = "SHF_GROUP"; break;
        case 1024: retval = "SHF_TLS"; break;
        case 267386880: retval = "SHF_MASKOS"; break;
        case 4026531840: retval = "SHF_MASKPROC"; break;
    }
    if (retval.empty()) {
        char buf[103];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmElfSectionTableEntry::SectionFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfSectionTableEntry::SectionFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmElfSectionTableEntry::SectionType is defined at frontend/SageIII/Cxx_Grammar.h:243281
/** Converts an enum of type SgAsmElfSectionTableEntry::SectionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfSectionTableEntrySectionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SHT_NULL"; break;
        case 1: retval = "SHT_PROGBITS"; break;
        case 2: retval = "SHT_SYMTAB"; break;
        case 3: retval = "SHT_STRTAB"; break;
        case 4: retval = "SHT_RELA"; break;
        case 5: retval = "SHT_HASH"; break;
        case 6: retval = "SHT_DYNAMIC"; break;
        case 7: retval = "SHT_NOTE"; break;
        case 8: retval = "SHT_NOBITS"; break;
        case 9: retval = "SHT_REL"; break;
        case 10: retval = "SHT_SHLIB"; break;
        case 11: retval = "SHT_DYNSYM"; break;
        case 1610612736: retval = "SHT_LOOS"; break;
        case 1879048189: retval = "SHT_GNU_verdef"; break;
        case 1879048190: retval = "SHT_GNU_verneed"; break;
        case 1879048191: retval = "SHT_GNU_versym"; break;
        case 1879048192: retval = "SHT_LOPROC"; break;
        case 2147483647: retval = "SHT_HIPROC"; break;
        case 2147483648: retval = "SHT_LOUSER"; break;
        case 4294967295: retval = "SHT_HIUSER"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmElfSectionTableEntry::SectionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfSectionTableEntry::SectionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmElfSegmentTableEntry::SegmentFlags is defined at frontend/SageIII/Cxx_Grammar.h:243896
/** Converts an enum of type SgAsmElfSegmentTableEntry::SegmentFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfSegmentTableEntrySegmentFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "PF_NONE"; break;
        case 1: retval = "PF_XPERM"; break;
        case 2: retval = "PF_WPERM"; break;
        case 4: retval = "PF_RPERM"; break;
        case 1048568: retval = "PF_RESERVED"; break;
        case 267386880: retval = "PF_OS_MASK"; break;
        case 4026531840: retval = "PF_PROC_MASK"; break;
    }
    if (retval.empty()) {
        char buf[103];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmElfSegmentTableEntry::SegmentFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfSegmentTableEntry::SegmentFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmElfSegmentTableEntry::SegmentType is defined at frontend/SageIII/Cxx_Grammar.h:243868
/** Converts an enum of type SgAsmElfSegmentTableEntry::SegmentType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfSegmentTableEntrySegmentType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "PT_NULL"; break;
        case 1: retval = "PT_LOAD"; break;
        case 2: retval = "PT_DYNAMIC"; break;
        case 3: retval = "PT_INTERP"; break;
        case 4: retval = "PT_NOTE"; break;
        case 5: retval = "PT_SHLIB"; break;
        case 6: retval = "PT_PHDR"; break;
        case 7: retval = "PT_TLS"; break;
        case 1610612736: retval = "PT_LOOS"; break;
        case 1685382480: retval = "PT_GNU_EH_FRAME"; break;
        case 1685382481: retval = "PT_GNU_STACK"; break;
        case 1685382482: retval = "PT_GNU_RELRO"; break;
        case 1694766464: retval = "PT_PAX_FLAGS"; break;
        case 1879048186: retval = "PT_SUNWBSS"; break;
        case 1879048187: retval = "PT_SUNWSTACK"; break;
        case 1879048191: retval = "PT_HIOS"; break;
        case 1879048192: retval = "PT_LOPROC"; break;
        case 2147483647: retval = "PT_HIPROC"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmElfSegmentTableEntry::SegmentType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfSegmentTableEntry::SegmentType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmElfSymbol::ElfSymBinding is defined at frontend/SageIII/Cxx_Grammar.h:239090
/** Converts an enum of type SgAsmElfSymbol::ElfSymBinding to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfSymbolElfSymBinding(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "STB_LOCAL"; break;
        case 1: retval = "STB_GLOBAL"; break;
        case 2: retval = "STB_WEAK"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmElfSymbol::ElfSymBinding)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfSymbol::ElfSymBinding::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmElfSymbol::ElfSymType is defined at frontend/SageIII/Cxx_Grammar.h:239096
/** Converts an enum of type SgAsmElfSymbol::ElfSymType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfSymbolElfSymType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "STT_NOTYPE"; break;
        case 1: retval = "STT_OBJECT"; break;
        case 2: retval = "STT_FUNC"; break;
        case 3: retval = "STT_SECTION"; break;
        case 4: retval = "STT_FILE"; break;
        case 5: retval = "STT_COMMON"; break;
        case 6: retval = "STT_TLS"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmElfSymbol::ElfSymType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfSymbol::ElfSymType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmExecutableFileFormat::ByteOrder is defined at frontend/SageIII/Cxx_Grammar.h:216819
/** Converts an enum of type SgAsmExecutableFileFormat::ByteOrder to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmExecutableFileFormatByteOrder(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ORDER_UNSPECIFIED"; break;
        case 1: retval = "ORDER_LSB"; break;
        case 2: retval = "ORDER_MSB"; break;
    }
    if (retval.empty()) {
        char buf[100];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmExecutableFileFormat::ByteOrder)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmExecutableFileFormat::ByteOrder::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmExecutableFileFormat::ExecABI is defined at frontend/SageIII/Cxx_Grammar.h:216835
/** Converts an enum of type SgAsmExecutableFileFormat::ExecABI to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmExecutableFileFormatExecABI(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ABI_UNSPECIFIED"; break;
        case 1: retval = "ABI_OTHER"; break;
        case 2: retval = "ABI_86OPEN"; break;
        case 3: retval = "ABI_AIX"; break;
        case 4: retval = "ABI_ARM"; break;
        case 5: retval = "ABI_FREEBSD"; break;
        case 6: retval = "ABI_HPUX"; break;
        case 7: retval = "ABI_IRIX"; break;
        case 8: retval = "ABI_HURD"; break;
        case 9: retval = "ABI_LINUX"; break;
        case 10: retval = "ABI_MODESTO"; break;
        case 11: retval = "ABI_MONTEREY"; break;
        case 12: retval = "ABI_MSDOS"; break;
        case 13: retval = "ABI_NT"; break;
        case 14: retval = "ABI_NETBSD"; break;
        case 15: retval = "ABI_OS2"; break;
        case 16: retval = "ABI_SOLARIS"; break;
        case 17: retval = "ABI_SYSV"; break;
        case 18: retval = "ABI_TRU64"; break;
        case 19: retval = "ABI_WIN386"; break;
    }
    if (retval.empty()) {
        char buf[98];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmExecutableFileFormat::ExecABI)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmExecutableFileFormat::ExecABI::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmExecutableFileFormat::ExecFamily is defined at frontend/SageIII/Cxx_Grammar.h:216825
/** Converts an enum of type SgAsmExecutableFileFormat::ExecFamily to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmExecutableFileFormatExecFamily(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FAMILY_UNSPECIFIED"; break;
        case 1: retval = "FAMILY_DOS"; break;
        case 2: retval = "FAMILY_ELF"; break;
        case 3: retval = "FAMILY_LE"; break;
        case 4: retval = "FAMILY_LX"; break;
        case 5: retval = "FAMILY_NE"; break;
        case 6: retval = "FAMILY_PE"; break;
    }
    if (retval.empty()) {
        char buf[101];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmExecutableFileFormat::ExecFamily)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmExecutableFileFormat::ExecFamily::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmExecutableFileFormat::ExecPurpose is defined at frontend/SageIII/Cxx_Grammar.h:217038
/** Converts an enum of type SgAsmExecutableFileFormat::ExecPurpose to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmExecutableFileFormatExecPurpose(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "PURPOSE_UNSPECIFIED"; break;
        case 1: retval = "PURPOSE_OTHER"; break;
        case 2: retval = "PURPOSE_EXECUTABLE"; break;
        case 3: retval = "PURPOSE_LIBRARY"; break;
        case 4: retval = "PURPOSE_CORE_DUMP"; break;
        case 5: retval = "PURPOSE_OS_SPECIFIC"; break;
        case 6: retval = "PURPOSE_PROC_SPECIFIC"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmExecutableFileFormat::ExecPurpose)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmExecutableFileFormat::ExecPurpose::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmExecutableFileFormat::InsSetArchitecture is defined at frontend/SageIII/Cxx_Grammar.h:216859
/** Converts an enum of type SgAsmExecutableFileFormat::InsSetArchitecture to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmExecutableFileFormatInsSetArchitecture(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ISA_UNSPECIFIED"; break;
        case 256: retval = "ISA_IA32_Family"; break;
        case 257: retval = "ISA_IA32_286"; break;
        case 258: retval = "ISA_IA32_386"; break;
        case 259: retval = "ISA_IA32_486"; break;
        case 260: retval = "ISA_IA32_Pentium"; break;
        case 261: retval = "ISA_IA32_Cyrix6x86"; break;
        case 262: retval = "ISA_IA32_AMDK5"; break;
        case 263: retval = "ISA_IA32_PentiumPro"; break;
        case 264: retval = "ISA_IA32_PentiumII"; break;
        case 265: retval = "ISA_IA32_Athlon"; break;
        case 266: retval = "ISA_IA32_Pentium4"; break;
        case 267: retval = "ISA_IA32_PentiumM"; break;
        case 512: retval = "ISA_X8664_Family"; break;
        case 513: retval = "ISA_X8664_Athlon64"; break;
        case 514: retval = "ISA_X8664_Prescott"; break;
        case 515: retval = "ISA_X8664_IntelCore"; break;
        case 516: retval = "ISA_X8664_AMDPhenom"; break;
        case 768: retval = "ISA_SPARC_Family"; break;
        case 769: retval = "ISA_SPARC_V7"; break;
        case 770: retval = "ISA_SPARC_V8"; break;
        case 771: retval = "ISA_SPARC_V8E"; break;
        case 772: retval = "ISA_SPARC_V9"; break;
        case 773: retval = "ISA_SPARC_V9JPS1"; break;
        case 774: retval = "ISA_SPARC_V9UA"; break;
        case 775: retval = "ISA_SPARC_V9JPS2"; break;
        case 1024: retval = "ISA_M68K_Family"; break;
        case 1025: retval = "ISA_M68K_68000"; break;
        case 1026: retval = "ISA_M68K_68EC000"; break;
        case 1027: retval = "ISA_M68K_68HC000"; break;
        case 1028: retval = "ISA_M68K_68008"; break;
        case 1029: retval = "ISA_M68K_68010"; break;
        case 1030: retval = "ISA_M68K_68012"; break;
        case 1031: retval = "ISA_M68K_68020"; break;
        case 1032: retval = "ISA_M68K_68EC020"; break;
        case 1033: retval = "ISA_M68K_68030"; break;
        case 1034: retval = "ISA_M68K_68EC030"; break;
        case 1035: retval = "ISA_M68K_68040"; break;
        case 1036: retval = "ISA_M68K_68EC040"; break;
        case 1037: retval = "ISA_M68K_68LC040"; break;
        case 1038: retval = "ISA_M68K_68060"; break;
        case 1039: retval = "ISA_M68K_ColdFire"; break;
        case 1040: retval = "ISA_M68K_DragonBall"; break;
        case 1280: retval = "ISA_M88K_Family"; break;
        case 1281: retval = "ISA_M88K_88100"; break;
        case 1282: retval = "ISA_M88K_88110"; break;
        case 1283: retval = "ISA_M88K_88110MP"; break;
        case 1284: retval = "ISA_M88K_88120"; break;
        case 1536: retval = "ISA_MIPS_Family"; break;
        case 1537: retval = "ISA_MIPS_MarkI"; break;
        case 1538: retval = "ISA_MIPS_MarkII"; break;
        case 1539: retval = "ISA_MIPS_MarkIII"; break;
        case 1540: retval = "ISA_MIPS_R2000"; break;
        case 1541: retval = "ISA_MIPS_R3000"; break;
        case 1542: retval = "ISA_MIPS_R4000"; break;
        case 1543: retval = "ISA_MIPS_R4200"; break;
        case 1544: retval = "ISA_MIPS_R4300"; break;
        case 1545: retval = "ISA_MIPS_R4600"; break;
        case 1546: retval = "ISA_MIPS_R4650"; break;
        case 1547: retval = "ISA_MIPS_R4700"; break;
        case 1548: retval = "ISA_MIPS_R5000"; break;
        case 1549: retval = "ISA_MIPS_RM7000"; break;
        case 1550: retval = "ISA_MIPS_R8000"; break;
        case 1551: retval = "ISA_MIPS_R10000"; break;
        case 1552: retval = "ISA_MIPS_R12000"; break;
        case 1553: retval = "ISA_MIPS_R14000"; break;
        case 1554: retval = "ISA_MIPS_R16000"; break;
        case 1555: retval = "ISA_MIPS_R16000A"; break;
        case 1556: retval = "ISA_MIPS_16"; break;
        case 1557: retval = "ISA_MIPS_FPU"; break;
        case 1558: retval = "ISA_MIPS_16FPU"; break;
        case 1792: retval = "ISA_I860_Family"; break;
        case 1793: retval = "ISA_I860_860XR"; break;
        case 1794: retval = "ISA_I860_860XP"; break;
        case 2048: retval = "ISA_IA64_Family"; break;
        case 2049: retval = "ISA_IA64_Itanium"; break;
        case 2050: retval = "ISA_IA64_Itanium2"; break;
        case 2304: retval = "ISA_ARM_Family"; break;
        case 2305: retval = "ISA_ARM_ARM1"; break;
        case 2306: retval = "ISA_ARM_ARM2"; break;
        case 2307: retval = "ISA_ARM_ARM3"; break;
        case 2308: retval = "ISA_ARM_ARM6"; break;
        case 2309: retval = "ISA_ARM_ARM7"; break;
        case 2310: retval = "ISA_ARM_ARM7TDMI"; break;
        case 2311: retval = "ISA_ARM_StrongARM"; break;
        case 2312: retval = "ISA_ARM_ARM8"; break;
        case 2313: retval = "ISA_ARM_ARM9TDMI"; break;
        case 2314: retval = "ISA_ARM_ARM9E"; break;
        case 2315: retval = "ISA_ARM_ARM10E"; break;
        case 2316: retval = "ISA_ARM_XScale"; break;
        case 2317: retval = "ISA_ARM_ARM11"; break;
        case 2318: retval = "ISA_ARM_Cortex"; break;
        case 61440: retval = "ISA_OTHER_Family"; break;
        case 61441: retval = "ISA_ATT_WE_32100"; break;
        case 61442: retval = "ISA_IBM_System_370"; break;
        case 61443: retval = "ISA_HPPA"; break;
        case 61444: retval = "ISA_Fujitsu_VPP500"; break;
        case 61445: retval = "ISA_Sun_v8plus"; break;
        case 61446: retval = "ISA_PowerPC"; break;
        case 61447: retval = "ISA_PowerPC_64bit"; break;
        case 61448: retval = "ISA_IBM_S390"; break;
        case 61449: retval = "ISA_NEC_V800_series"; break;
        case 61450: retval = "ISA_Fujitsu_FR20"; break;
        case 61451: retval = "ISA_TRW_RH_32"; break;
        case 61452: retval = "ISA_Motorola_RCE"; break;
        case 61454: retval = "ISA_Digital_Alpha_fake"; break;
        case 61455: retval = "ISA_Hitachi_SH"; break;
        case 61456: retval = "ISA_Siemens_Tricore"; break;
        case 61457: retval = "ISA_Argonaut_RISC_Core"; break;
        case 61458: retval = "ISA_Hitachi_H8_300"; break;
        case 61459: retval = "ISA_Hitachi_H8_300H"; break;
        case 61460: retval = "ISA_Hitachi_H8S"; break;
        case 61461: retval = "ISA_Hitachi_H8_500"; break;
        case 61462: retval = "ISA_Stanford_MIPS_X"; break;
        case 61463: retval = "ISA_Motorola_M68HC12"; break;
        case 61464: retval = "ISA_Fujitsu_MMA_Multimedia_Accelerator"; break;
        case 61465: retval = "ISA_Siemens_PCP"; break;
        case 61466: retval = "ISA_Sony_nCPU_embeeded_RISC"; break;
        case 61467: retval = "ISA_Denso_NDR1_microprocessor"; break;
        case 61468: retval = "ISA_Motorola_Start_Core_processor"; break;
        case 61469: retval = "ISA_Toyota_ME16_processor"; break;
        case 61470: retval = "ISA_STMicroelectronic_ST100_processor"; break;
        case 61471: retval = "ISA_Advanced_Logic_Corp_Tinyj_emb_family"; break;
        case 61472: retval = "ISA_AMD_x86_64_architecture"; break;
        case 61473: retval = "ISA_Sony_DSP_Processor"; break;
        case 61474: retval = "ISA_Siemens_FX66_microcontroller"; break;
        case 61475: retval = "ISA_STMicroelectronics_ST9_plus_8_16_microcontroller"; break;
        case 61476: retval = "ISA_STMicroelectronics_ST7_8bit_microcontroller"; break;
        case 61477: retval = "ISA_Motorola_MC68HC16_microcontroller"; break;
        case 61478: retval = "ISA_Motorola_MC68HC11_microcontroller"; break;
        case 61479: retval = "ISA_Motorola_MC68HC08_microcontroller"; break;
        case 61480: retval = "ISA_Motorola_MC68HC05_microcontroller"; break;
        case 61481: retval = "ISA_Silicon_Graphics_SVx"; break;
        case 61482: retval = "ISA_STMicroelectronics_ST19_8bit_microcontroller"; break;
        case 61483: retval = "ISA_Digital_VAX"; break;
        case 61484: retval = "ISA_Axis_Communications_32bit_embedded_processor"; break;
        case 61485: retval = "ISA_Infineon_Technologies_32bit_embedded_processor"; break;
        case 61486: retval = "ISA_Element_14_64bit_DSP_Processor"; break;
        case 61487: retval = "ISA_LSI_Logic_16bit_DSP_Processor"; break;
        case 61488: retval = "ISA_Donald_Knuths_educational_64bit_processor"; break;
        case 61489: retval = "ISA_Harvard_University_machine_independent_object_files"; break;
        case 61490: retval = "ISA_SiTera_Prism"; break;
        case 61491: retval = "ISA_Atmel_AVR_8bit_microcontroller"; break;
        case 61492: retval = "ISA_Fujitsu_FR30"; break;
        case 61493: retval = "ISA_Mitsubishi_D10V"; break;
        case 61494: retval = "ISA_Mitsubishi_D30V"; break;
        case 61495: retval = "ISA_NEC_v850"; break;
        case 61496: retval = "ISA_Mitsubishi_M32R"; break;
        case 61497: retval = "ISA_Matsushita_MN10300"; break;
        case 61498: retval = "ISA_Matsushita_MN10200"; break;
        case 61499: retval = "ISA_picoJava"; break;
        case 61500: retval = "ISA_OpenRISC_32bit_embedded_processor"; break;
        case 61501: retval = "ISA_ARC_Cores_Tangent_A5"; break;
        case 61502: retval = "ISA_Tensilica_Xtensa_Architecture"; break;
        case 61503: retval = "ISA_Digital_Alpha"; break;
        case 61504: retval = "ISA_Matsushita_AM33"; break;
        case 61505: retval = "ISA_EFI_ByteCode"; break;
        case 65280: retval = "ISA_FAMILY_MASK"; break;
        case 65535: retval = "ISA_OTHER"; break;
    }
    if (retval.empty()) {
        char buf[109];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmExecutableFileFormat::InsSetArchitecture)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmExecutableFileFormat::InsSetArchitecture::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmFunctionDeclaration::FunctionReason is defined at frontend/SageIII/Cxx_Grammar.h:193897
/** Converts an enum of type SgAsmFunctionDeclaration::FunctionReason to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmFunctionDeclarationFunctionReason(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FUNC_NONE"; break;
        case 1: retval = "FUNC_ENTRY_POINT"; break;
        case 2: retval = "FUNC_CALL_TARGET"; break;
        case 4: retval = "FUNC_CALL_INSN"; break;
        case 8: retval = "FUNC_EH_FRAME"; break;
        case 16: retval = "FUNC_SYMBOL"; break;
        case 32: retval = "FUNC_PATTERN"; break;
        case 64: retval = "FUNC_GRAPH"; break;
        case 128: retval = "FUNC_USERDEF"; break;
        case 256: retval = "FUNC_INTERPAD"; break;
        case 512: retval = "FUNC_DISCONT"; break;
        case 1024: retval = "FUNC_INSNHEAD"; break;
        case 2048: retval = "FUNC_IMPORT"; break;
        case 4096: retval = "FUNC_LEFTOVERS"; break;
        case 8191: retval = "FUNC_DEFAULT"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmFunctionDeclaration::FunctionReason)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmFunctionDeclaration::FunctionReason::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmFunctionDeclaration::function_calling_convention_enum is defined at frontend/SageIII/Cxx_Grammar.h:193955
/** Converts an enum of type SgAsmFunctionDeclaration::function_calling_convention_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmFunctionDeclaration_function_calling_convention_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown_call"; break;
        case 1: retval = "e_std_call"; break;
        case 2: retval = "e_fast_call"; break;
        case 3: retval = "e_cdecl_call"; break;
        case 4: retval = "e_this_call"; break;
        case 5: retval = "e_last_call"; break;
    }
    if (retval.empty()) {
        char buf[122];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmFunctionDeclaration::function_calling_convention_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmFunctionDeclaration::function_calling_convention_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmFunctionDeclaration::function_kind_enum is defined at frontend/SageIII/Cxx_Grammar.h:193945
/** Converts an enum of type SgAsmFunctionDeclaration::function_kind_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmFunctionDeclaration_function_kind_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_standard"; break;
        case 2: retval = "e_library"; break;
        case 3: retval = "e_imported"; break;
        case 4: retval = "e_thunk"; break;
        case 5: retval = "e_last"; break;
    }
    if (retval.empty()) {
        char buf[108];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmFunctionDeclaration::function_kind_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmFunctionDeclaration::function_kind_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmGenericFile::AddressSpace is defined at frontend/SageIII/Cxx_Grammar.h:219333
/** Converts an enum of type SgAsmGenericFile::AddressSpace to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmGenericFileAddressSpace(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "ADDRSP_MEMORY"; break;
        case 2: retval = "ADDRSP_FILE"; break;
        case 3: retval = "ADDRSP_ALL"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmGenericFile::AddressSpace)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmGenericFile::AddressSpace::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmGenericFile::Elasticity is defined at frontend/SageIII/Cxx_Grammar.h:219338
/** Converts an enum of type SgAsmGenericFile::Elasticity to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmGenericFileElasticity(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ELASTIC_NONE"; break;
        case 1: retval = "ELASTIC_UNREF"; break;
        case 2: retval = "ELASTIC_HOLE"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmGenericFile::Elasticity)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmGenericFile::Elasticity::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmGenericSection::SectionPurpose is defined at frontend/SageIII/Cxx_Grammar.h:219857
/** Converts an enum of type SgAsmGenericSection::SectionPurpose to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmGenericSectionSectionPurpose(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SP_UNSPECIFIED"; break;
        case 1: retval = "SP_PROGRAM"; break;
        case 2: retval = "SP_HEADER"; break;
        case 3: retval = "SP_SYMTAB"; break;
        case 4: retval = "SP_OTHER"; break;
    }
    if (retval.empty()) {
        char buf[99];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmGenericSection::SectionPurpose)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmGenericSection::SectionPurpose::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmGenericSymbol::SymbolBinding is defined at frontend/SageIII/Cxx_Grammar.h:238126
/** Converts an enum of type SgAsmGenericSymbol::SymbolBinding to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmGenericSymbolSymbolBinding(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SYM_NO_BINDING"; break;
        case 1: retval = "SYM_LOCAL"; break;
        case 2: retval = "SYM_GLOBAL"; break;
        case 3: retval = "SYM_WEAK"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmGenericSymbol::SymbolBinding)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmGenericSymbol::SymbolBinding::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmGenericSymbol::SymbolDefState is defined at frontend/SageIII/Cxx_Grammar.h:238108
/** Converts an enum of type SgAsmGenericSymbol::SymbolDefState to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmGenericSymbolSymbolDefState(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SYM_UNDEFINED"; break;
        case 1: retval = "SYM_TENTATIVE"; break;
        case 2: retval = "SYM_DEFINED"; break;
    }
    if (retval.empty()) {
        char buf[98];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmGenericSymbol::SymbolDefState)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmGenericSymbol::SymbolDefState::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmGenericSymbol::SymbolType is defined at frontend/SageIII/Cxx_Grammar.h:238114
/** Converts an enum of type SgAsmGenericSymbol::SymbolType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmGenericSymbolSymbolType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SYM_NO_TYPE"; break;
        case 1: retval = "SYM_DATA"; break;
        case 2: retval = "SYM_FUNC"; break;
        case 3: retval = "SYM_SECTION"; break;
        case 4: retval = "SYM_FILE"; break;
        case 5: retval = "SYM_ARRAY"; break;
        case 6: retval = "SYM_TLS"; break;
        case 7: retval = "SYM_REGISTER"; break;
        case 8: retval = "SYM_COMMON"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmGenericSymbol::SymbolType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmGenericSymbol::SymbolType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmLEFileHeader::LEFileHeaderFlags is defined at frontend/SageIII/Cxx_Grammar.h:221907
/** Converts an enum of type SgAsmLEFileHeader::LEFileHeaderFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmLEFileHeaderLEFileHeaderFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "HF_MODTYPE_PROG"; break;
        case 4: retval = "HF_PROC_LIB_INIT"; break;
        case 16: retval = "HF_IFIXUPS_APPLIED"; break;
        case 32: retval = "HF_EFIXUPS_APPLIED"; break;
        case 256: retval = "HF_PM_WINDOW_NO"; break;
        case 512: retval = "HF_PM_WINDOW_OK"; break;
        case 768: retval = "HF_PM_WINDOW_USE"; break;
        case 8192: retval = "HF_NOT_LOADABLE"; break;
        case 32768: retval = "HF_MODTYPE_LIB"; break;
        case 98304: retval = "HF_MODTYPE_PLIB"; break;
        case 131072: retval = "HF_MODTYPE_PDEV"; break;
        case 163840: retval = "HF_MODTYPE_VDEV"; break;
        case 229376: retval = "HF_MODTYPE_MASK"; break;
        case 1073741824: retval = "HF_PROC_LIB_TERM"; break;
        case 3220987083: retval = "HF_RESERVED"; break;
    }
    if (retval.empty()) {
        char buf[100];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmLEFileHeader::LEFileHeaderFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmLEFileHeader::LEFileHeaderFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmLESectionTableEntry::LESectionFlags is defined at frontend/SageIII/Cxx_Grammar.h:262094
/** Converts an enum of type SgAsmLESectionTableEntry::LESectionFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmLESectionTableEntryLESectionFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SF_TYPE_NORMAL"; break;
        case 1: retval = "SF_READABLE"; break;
        case 2: retval = "SF_WRITABLE"; break;
        case 4: retval = "SF_EXECUTABLE"; break;
        case 8: retval = "SF_RESOURCE"; break;
        case 16: retval = "SF_DISCARDABLE"; break;
        case 32: retval = "SF_SHARED"; break;
        case 64: retval = "SF_PRELOAD_PAGES"; break;
        case 128: retval = "SF_INVALID_PAGES"; break;
        case 256: retval = "SF_TYPE_ZERO"; break;
        case 512: retval = "SF_TYPE_RESIDENT"; break;
        case 768: retval = "SF_TYPE_RESCONT"; break;
        case 1024: retval = "SF_RES_LONG_LOCK"; break;
        case 4096: retval = "SF_1616_ALIAS"; break;
        case 8192: retval = "SF_BIG_BIT"; break;
        case 16384: retval = "SF_CODE_CONFORM"; break;
        case 32768: retval = "SF_IO_PRIV"; break;
        case 4294903808: retval = "SF_RESERVED"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmLESectionTableEntry::LESectionFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmLESectionTableEntry::LESectionFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmNEEntryPoint::NEEntryFlags is defined at frontend/SageIII/Cxx_Grammar.h:259262
/** Converts an enum of type SgAsmNEEntryPoint::NEEntryFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNEEntryPointNEEntryFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "EF_ZERO"; break;
        case 1: retval = "EF_EXPORTED"; break;
        case 2: retval = "EF_GLOBAL"; break;
        case 252: retval = "EF_RESERVED"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmNEEntryPoint::NEEntryFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNEEntryPoint::NEEntryFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmNEFileHeader::HeaderFlags1 is defined at frontend/SageIII/Cxx_Grammar.h:222814
/** Converts an enum of type SgAsmNEFileHeader::HeaderFlags1 to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNEFileHeaderHeaderFlags1(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "HF1_NO_DATA"; break;
        case 1: retval = "HF1_SINGLE_DATA"; break;
        case 2: retval = "HF1_MULTIPLE_DATA"; break;
        case 2048: retval = "HF1_LOADER_SEGMENT"; break;
        case 8192: retval = "HF1_FATAL_ERRORS"; break;
        case 22516: retval = "HF1_RESERVED"; break;
        case 32768: retval = "HF1_LIBRARY"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmNEFileHeader::HeaderFlags1)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNEFileHeader::HeaderFlags1::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmNEFileHeader::HeaderFlags2 is defined at frontend/SageIII/Cxx_Grammar.h:222825
/** Converts an enum of type SgAsmNEFileHeader::HeaderFlags2 to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNEFileHeaderHeaderFlags2(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 2: retval = "HF2_PROTECTED_MODE"; break;
        case 4: retval = "HF2_PFONTS"; break;
        case 8: retval = "HF2_FASTLOAD"; break;
        case 241: retval = "HF2_RESERVED"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmNEFileHeader::HeaderFlags2)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNEFileHeader::HeaderFlags2::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmNERelocEntry::NERelocFlags is defined at frontend/SageIII/Cxx_Grammar.h:259734
/** Converts an enum of type SgAsmNERelocEntry::NERelocFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNERelocEntryNERelocFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "RF_ADDITIVE"; break;
        case 2: retval = "RF_RESERVED"; break;
        case 4: retval = "RF_2EXTRA"; break;
        case 8: retval = "RF_32ADD"; break;
        case 16: retval = "RF_16SECTION"; break;
        case 32: retval = "RF_8ORDINAL"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmNERelocEntry::NERelocFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNERelocEntry::NERelocFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmNERelocEntry::NERelocModifiers is defined at frontend/SageIII/Cxx_Grammar.h:259729
/** Converts an enum of type SgAsmNERelocEntry::NERelocModifiers to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNERelocEntryNERelocModifiers(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "RF_MODIFIER_SINGLE"; break;
        case 3: retval = "RF_MODIFIER_MULTI"; break;
    }
    if (retval.empty()) {
        char buf[99];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmNERelocEntry::NERelocModifiers)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNERelocEntry::NERelocModifiers::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmNERelocEntry::NERelocSrcType is defined at frontend/SageIII/Cxx_Grammar.h:259710
/** Converts an enum of type SgAsmNERelocEntry::NERelocSrcType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNERelocEntryNERelocSrcType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "RF_SRCTYPE_8OFF"; break;
        case 2: retval = "RF_SRCTYPE_WORDSEG"; break;
        case 3: retval = "RF_SRCTYPE_16PTR"; break;
        case 5: retval = "RF_SRCTYPE_16OFF"; break;
        case 6: retval = "RF_SRCTYPE_32PTR"; break;
        case 7: retval = "RF_SRCTYPE_32OFF"; break;
        case 8: retval = "RF_SRCTYPE_NEARCALL"; break;
        case 11: retval = "RF_SRCTYPE_48PTR"; break;
        case 13: retval = "RF_SRCTYPE_32OFF_b"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmNERelocEntry::NERelocSrcType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNERelocEntry::NERelocSrcType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmNERelocEntry::NERelocTgtType is defined at frontend/SageIII/Cxx_Grammar.h:259722
/** Converts an enum of type SgAsmNERelocEntry::NERelocTgtType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNERelocEntryNERelocTgtType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "RF_TGTTYPE_IREF"; break;
        case 1: retval = "RF_TGTTYPE_IORD"; break;
        case 2: retval = "RF_TGTTYPE_INAME"; break;
        case 3: retval = "RF_TGTTYPE_OSFIXUP"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmNERelocEntry::NERelocTgtType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNERelocEntry::NERelocTgtType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmNESectionTableEntry::NESectionFlags is defined at frontend/SageIII/Cxx_Grammar.h:260291
/** Converts an enum of type SgAsmNESectionTableEntry::NESectionFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNESectionTableEntryNESectionFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SF_CODE"; break;
        case 1: retval = "SF_DATA"; break;
        case 2: retval = "SF_ALLOC"; break;
        case 4: retval = "SF_LOAD"; break;
        case 7: retval = "SF_TYPE_MASK"; break;
        case 16: retval = "SF_MOVABLE"; break;
        case 32: retval = "SF_PURE"; break;
        case 64: retval = "SF_PRELOAD"; break;
        case 128: retval = "SF_NOT_WRITABLE"; break;
        case 256: retval = "SF_RELOCINFO"; break;
        case 3592: retval = "SF_RESERVED"; break;
        case 4096: retval = "SF_DISCARDABLE"; break;
        case 61440: retval = "SF_DISCARD"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmNESectionTableEntry::NESectionFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNESectionTableEntry::NESectionFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmOp::asm_operand_constraint_enum is defined at frontend/SageIII/Cxx_Grammar.h:179031
/** Converts an enum of type SgAsmOp::asm_operand_constraint_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmOp_asm_operand_constraint_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_invalid"; break;
        case 1: retval = "e_any"; break;
        case 2: retval = "e_general"; break;
        case 3: retval = "e_match_0"; break;
        case 4: retval = "aoc_match_1"; break;
        case 5: retval = "aoc_match_2"; break;
        case 6: retval = "aoc_match_3"; break;
        case 7: retval = "aoc_match_4"; break;
        case 8: retval = "e_match_5"; break;
        case 9: retval = "aoc_match_6"; break;
        case 10: retval = "aoc_match_7"; break;
        case 11: retval = "aoc_match_8"; break;
        case 12: retval = "aoc_match_9"; break;
        case 13: retval = "e_reg_integer"; break;
        case 14: retval = "e_reg_float"; break;
        case 15: retval = "e_mem_any"; break;
        case 16: retval = "e_mem_offset"; break;
        case 17: retval = "e_mem_nonoffset"; break;
        case 18: retval = "e_mem_autoinc"; break;
        case 19: retval = "e_mem_autodec"; break;
        case 20: retval = "e_imm_int"; break;
        case 21: retval = "e_imm_number"; break;
        case 22: retval = "e_imm_symbol"; break;
        case 23: retval = "e_imm_float"; break;
        case 24: retval = "e_reg_a"; break;
        case 25: retval = "e_reg_b"; break;
        case 26: retval = "e_reg_c"; break;
        case 27: retval = "e_reg_d"; break;
        case 28: retval = "e_reg_si"; break;
        case 29: retval = "e_reg_di"; break;
        case 30: retval = "e_reg_legacy"; break;
        case 31: retval = "e_reg_q"; break;
        case 32: retval = "e_reg_ad"; break;
        case 33: retval = "e_reg_float_tos"; break;
        case 34: retval = "e_reg_float_second"; break;
        case 35: retval = "e_reg_sse"; break;
        case 36: retval = "e_reg_sse2"; break;
        case 37: retval = "e_reg_mmx"; break;
        case 38: retval = "e_imm_short_shift"; break;
        case 39: retval = "e_imm_long_shift"; break;
        case 40: retval = "e_imm_lea_shift"; break;
        case 41: retval = "e_imm_signed8"; break;
        case 42: retval = "e_imm_unsigned8"; break;
        case 43: retval = "e_imm_and_zext"; break;
        case 44: retval = "e_imm_80387"; break;
        case 45: retval = "e_imm_sse"; break;
        case 46: retval = "e_imm_sext32"; break;
        case 47: retval = "e_imm_zext32"; break;
        case 48: retval = "e_last"; break;
    }
    if (retval.empty()) {
        char buf[100];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmOp::asm_operand_constraint_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmOp::asm_operand_constraint_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmOp::asm_operand_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:179012
/** Converts an enum of type SgAsmOp::asm_operand_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmOp_asm_operand_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_input"; break;
        case 2: retval = "e_output"; break;
        case 3: retval = "e_modify"; break;
        case 4: retval = "e_earlyclobber"; break;
        case 8: retval = "e_commutative"; break;
        case 16: retval = "e_ignore_next"; break;
        case 32: retval = "e_ignore_till_comma"; break;
        case 64: retval = "e_poor_choice"; break;
        case 128: retval = "e_bad_choice"; break;
    }
    if (retval.empty()) {
        char buf[98];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmOp::asm_operand_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmOp::asm_operand_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmPEFileHeader::DLLFlags is defined at frontend/SageIII/Cxx_Grammar.h:221089
/** Converts an enum of type SgAsmPEFileHeader::DLLFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmPEFileHeaderDLLFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "DLL_PROC_INIT"; break;
        case 2: retval = "DLL_PROC_TERM"; break;
        case 4: retval = "DLL_THRD_INIT"; break;
        case 8: retval = "DLL_THRD_TERM"; break;
        case 65520: retval = "DLL_RESERVED_MASK"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmPEFileHeader::DLLFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmPEFileHeader::DLLFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmPEFileHeader::HeaderFlags is defined at frontend/SageIII/Cxx_Grammar.h:221070
/** Converts an enum of type SgAsmPEFileHeader::HeaderFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmPEFileHeaderHeaderFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "HF_PROGRAM"; break;
        case 2: retval = "HF_EXECUTABLE"; break;
        case 512: retval = "HF_FIXED"; break;
        case 8192: retval = "HF_LIBRARY"; break;
        case 56829: retval = "HF_RESERVED_MASK"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmPEFileHeader::HeaderFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmPEFileHeader::HeaderFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmPEFileHeader::PairPurpose is defined at frontend/SageIII/Cxx_Grammar.h:221098
/** Converts an enum of type SgAsmPEFileHeader::PairPurpose to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmPEFileHeaderPairPurpose(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "PAIR_EXPORTS"; break;
        case 1: retval = "PAIR_IMPORTS"; break;
        case 2: retval = "PAIR_RESOURCES"; break;
        case 3: retval = "PAIR_EXCEPTIONS"; break;
        case 4: retval = "PAIR_CERTIFICATES"; break;
        case 5: retval = "PAIR_BASERELOCS"; break;
        case 6: retval = "PAIR_DEBUG"; break;
        case 7: retval = "PAIR_ARCHITECTURE"; break;
        case 8: retval = "PAIR_GLOBALPTR"; break;
        case 9: retval = "PAIR_TLS"; break;
        case 10: retval = "PAIR_LOADCONFIG"; break;
        case 11: retval = "PAIR_BOUNDIMPORT"; break;
        case 12: retval = "PAIR_IAT"; break;
        case 13: retval = "PAIR_DELAYIMPORT"; break;
        case 14: retval = "PAIR_CLRRUNTIME"; break;
        case 15: retval = "PAIR_RESERVED15"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmPEFileHeader::PairPurpose)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmPEFileHeader::PairPurpose::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmPEFileHeader::Subsystem is defined at frontend/SageIII/Cxx_Grammar.h:221079
/** Converts an enum of type SgAsmPEFileHeader::Subsystem to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmPEFileHeaderSubsystem(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "HF_SPEC_UNKNOWN"; break;
        case 1: retval = "HF_NATIVE"; break;
        case 2: retval = "HF_WINGUI"; break;
        case 3: retval = "HF_WINCHAR"; break;
        case 5: retval = "HF_OS2CHAR"; break;
        case 7: retval = "HF_POSIX"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmPEFileHeader::Subsystem)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmPEFileHeader::Subsystem::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmPEImportILTEntry::ILTEntryType is defined at frontend/SageIII/Cxx_Grammar.h:244842
/** Converts an enum of type SgAsmPEImportILTEntry::ILTEntryType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmPEImportILTEntryILTEntryType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ILT_ORDINAL"; break;
        case 1: retval = "ILT_HNT_ENTRY_RVA"; break;
        case 2: retval = "ILT_BOUND_RVA"; break;
    }
    if (retval.empty()) {
        char buf[99];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmPEImportILTEntry::ILTEntryType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmPEImportILTEntry::ILTEntryType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmPEImportLookupTable::TableKind is defined at frontend/SageIII/Cxx_Grammar.h:258435
/** Converts an enum of type SgAsmPEImportLookupTable::TableKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmPEImportLookupTableTableKind(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ILT_LOOKUP_TABLE"; break;
        case 1: retval = "ILT_ADDRESS_TABLE"; break;
    }
    if (retval.empty()) {
        char buf[99];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmPEImportLookupTable::TableKind)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmPEImportLookupTable::TableKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmPESectionTableEntry::PESectionFlags is defined at frontend/SageIII/Cxx_Grammar.h:254841
/** Converts an enum of type SgAsmPESectionTableEntry::PESectionFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmPESectionTableEntryPESectionFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 32: retval = "OF_CODE"; break;
        case 64: retval = "OF_IDATA"; break;
        case 128: retval = "OF_UDATA"; break;
        case 512: retval = "OF_INFO"; break;
        case 2048: retval = "OF_REMOVE"; break;
        case 4096: retval = "OF_COMDAT"; break;
        case 16384: retval = "OF_NO_DEFER_SPEC_EXC"; break;
        case 32768: retval = "OF_GPREL"; break;
        case 1048576: retval = "OF_ALIGN_1"; break;
        case 2097152: retval = "OF_ALIGN_2"; break;
        case 3145728: retval = "OF_ALIGN_4"; break;
        case 4194304: retval = "OF_ALIGN_8"; break;
        case 5242880: retval = "OF_ALIGN_16"; break;
        case 6291456: retval = "OF_ALIGN_32"; break;
        case 7340032: retval = "OF_ALIGN_64"; break;
        case 8388608: retval = "OF_ALIGN_128"; break;
        case 9437184: retval = "OF_ALIGN_256"; break;
        case 10485760: retval = "OF_ALIGN_512"; break;
        case 11534336: retval = "OF_ALIGN_1k"; break;
        case 12582912: retval = "OF_ALIGN_2k"; break;
        case 13631488: retval = "OF_ALIGN_4k"; break;
        case 14680064: retval = "OF_ALIGN_8k"; break;
        case 15728640: retval = "OF_ALIGN_MASK"; break;
        case 16777216: retval = "OF_NRELOC_OVFL"; break;
        case 33554432: retval = "OF_DISCARDABLE"; break;
        case 67108864: retval = "OF_NO_CACHE"; break;
        case 134217728: retval = "OF_NO_PAGING"; break;
        case 268435456: retval = "OF_SHARED"; break;
        case 536870912: retval = "OF_EXECUTABLE"; break;
        case 1073741824: retval = "OF_READABLE"; break;
        case 2147483648: retval = "OF_WRITABLE"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmPESectionTableEntry::PESectionFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmPESectionTableEntry::PESectionFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmx86RegisterReferenceExpression::regnames16_enum is defined at frontend/SageIII/Cxx_Grammar.h:208994
/** Converts an enum of type SgAsmx86RegisterReferenceExpression::regnames16_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmx86RegisterReferenceExpression_regnames16_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_ax"; break;
        case 1: retval = "e_cx"; break;
        case 2: retval = "e_dx"; break;
        case 3: retval = "e_bx"; break;
        case 4: retval = "e_sp"; break;
        case 5: retval = "e_bp"; break;
        case 6: retval = "e_si"; break;
        case 7: retval = "e_di"; break;
        case 8: retval = "e_r8w"; break;
        case 9: retval = "e_r9w"; break;
        case 10: retval = "e_r10w"; break;
        case 11: retval = "e_r11w"; break;
        case 12: retval = "e_r12w"; break;
        case 13: retval = "e_r13w"; break;
        case 14: retval = "e_r14w"; break;
        case 15: retval = "e_r15w"; break;
        case 16: retval = "e_regname16_last_value"; break;
    }
    if (retval.empty()) {
        char buf[116];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmx86RegisterReferenceExpression::regnames16_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmx86RegisterReferenceExpression::regnames16_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmx86RegisterReferenceExpression::regnames32_enum is defined at frontend/SageIII/Cxx_Grammar.h:209018
/** Converts an enum of type SgAsmx86RegisterReferenceExpression::regnames32_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmx86RegisterReferenceExpression_regnames32_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_eax"; break;
        case 1: retval = "e_ecx"; break;
        case 2: retval = "e_edx"; break;
        case 3: retval = "e_ebx"; break;
        case 4: retval = "e_esp"; break;
        case 5: retval = "e_ebp"; break;
        case 6: retval = "e_esi"; break;
        case 7: retval = "e_edi"; break;
        case 8: retval = "e_r8d"; break;
        case 9: retval = "e_r9d"; break;
        case 10: retval = "e_r10d"; break;
        case 11: retval = "e_r11d"; break;
        case 12: retval = "e_r12d"; break;
        case 13: retval = "e_r13d"; break;
        case 14: retval = "e_r14d"; break;
        case 15: retval = "e_r15d"; break;
        case 16: retval = "e_regname32_last_value"; break;
    }
    if (retval.empty()) {
        char buf[116];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmx86RegisterReferenceExpression::regnames32_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmx86RegisterReferenceExpression::regnames32_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmx86RegisterReferenceExpression::regnames64_enum is defined at frontend/SageIII/Cxx_Grammar.h:209042
/** Converts an enum of type SgAsmx86RegisterReferenceExpression::regnames64_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmx86RegisterReferenceExpression_regnames64_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_rax"; break;
        case 1: retval = "e_rcx"; break;
        case 2: retval = "e_rdx"; break;
        case 3: retval = "e_rbx"; break;
        case 4: retval = "e_rsp"; break;
        case 5: retval = "e_rbp"; break;
        case 6: retval = "e_rsi"; break;
        case 7: retval = "e_rdi"; break;
        case 8: retval = "e_r8"; break;
        case 9: retval = "e_r9"; break;
        case 10: retval = "e_r10"; break;
        case 11: retval = "e_r11"; break;
        case 12: retval = "e_r12"; break;
        case 13: retval = "e_r13"; break;
        case 14: retval = "e_r14"; break;
        case 15: retval = "e_r15"; break;
        case 16: retval = "e_regname64_last_value"; break;
    }
    if (retval.empty()) {
        char buf[116];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmx86RegisterReferenceExpression::regnames64_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmx86RegisterReferenceExpression::regnames64_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmx86RegisterReferenceExpression::regnames8h_enum is defined at frontend/SageIII/Cxx_Grammar.h:208982
/** Converts an enum of type SgAsmx86RegisterReferenceExpression::regnames8h_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmx86RegisterReferenceExpression_regnames8h_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_ah"; break;
        case 1: retval = "e_ch"; break;
        case 2: retval = "e_dh"; break;
        case 3: retval = "e_bh"; break;
        case 4: retval = "e_regname8h_last_value"; break;
    }
    if (retval.empty()) {
        char buf[116];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmx86RegisterReferenceExpression::regnames8h_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmx86RegisterReferenceExpression::regnames8h_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmx86RegisterReferenceExpression::regnames8l_enum is defined at frontend/SageIII/Cxx_Grammar.h:208958
/** Converts an enum of type SgAsmx86RegisterReferenceExpression::regnames8l_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmx86RegisterReferenceExpression_regnames8l_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_al"; break;
        case 1: retval = "e_cl"; break;
        case 2: retval = "e_dl"; break;
        case 3: retval = "e_bl"; break;
        case 4: retval = "e_spl"; break;
        case 5: retval = "e_bpl"; break;
        case 6: retval = "e_sil"; break;
        case 7: retval = "e_dil"; break;
        case 8: retval = "e_r8b"; break;
        case 9: retval = "e_r9b"; break;
        case 10: retval = "e_r10b"; break;
        case 11: retval = "e_r11b"; break;
        case 12: retval = "e_r12b"; break;
        case 13: retval = "e_r13b"; break;
        case 14: retval = "e_r14b"; break;
        case 15: retval = "e_r15b"; break;
        case 16: retval = "e_regname8l_last_value"; break;
    }
    if (retval.empty()) {
        char buf[116];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmx86RegisterReferenceExpression::regnames8l_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmx86RegisterReferenceExpression::regnames8l_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAsmx86RegisterReferenceExpression::segregnames_enum is defined at frontend/SageIII/Cxx_Grammar.h:209066
/** Converts an enum of type SgAsmx86RegisterReferenceExpression::segregnames_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmx86RegisterReferenceExpression_segregnames_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_es"; break;
        case 1: retval = "e_cs"; break;
        case 2: retval = "e_ss"; break;
        case 3: retval = "e_ds"; break;
        case 4: retval = "e_fs"; break;
        case 5: retval = "e_gs"; break;
        case 6: retval = "e_segregnames_last_value"; break;
    }
    if (retval.empty()) {
        char buf[117];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAsmx86RegisterReferenceExpression::segregnames_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmx86RegisterReferenceExpression::segregnames_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgAttributeSpecificationStatement::attribute_spec_enum is defined at frontend/SageIII/Cxx_Grammar.h:83762
/** Converts an enum of type SgAttributeSpecificationStatement::attribute_spec_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAttributeSpecificationStatement_attribute_spec_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown_attribute_spec"; break;
        case 1: retval = "e_accessStatement_private"; break;
        case 2: retval = "e_accessStatement_public"; break;
        case 3: retval = "e_allocatableStatement"; break;
        case 4: retval = "e_asynchronousStatement"; break;
        case 5: retval = "e_bindStatement"; break;
        case 6: retval = "e_dataStatement"; break;
        case 7: retval = "e_dimensionStatement"; break;
        case 8: retval = "e_externalStatement"; break;
        case 9: retval = "e_intentStatement"; break;
        case 10: retval = "e_intrinsicStatement"; break;
        case 11: retval = "e_optionalStatement"; break;
        case 12: retval = "e_parameterStatement"; break;
        case 13: retval = "e_pointerStatement"; break;
        case 14: retval = "e_protectedStatement"; break;
        case 15: retval = "e_saveStatement"; break;
        case 16: retval = "e_targetStatement"; break;
        case 17: retval = "e_valueStatement"; break;
        case 18: retval = "e_volatileStatement"; break;
        case 19: retval = "e_last_attribute_spec"; break;
    }
    if (retval.empty()) {
        char buf[118];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgAttributeSpecificationStatement::attribute_spec_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAttributeSpecificationStatement::attribute_spec_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgBaseClassModifier::baseclass_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:12323
/** Converts an enum of type SgBaseClassModifier::baseclass_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgBaseClassModifier_baseclass_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_virtual"; break;
        case 3: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[108];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgBaseClassModifier::baseclass_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgBaseClassModifier::baseclass_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgCastExp::cast_type_enum is defined at frontend/SageIII/Cxx_Grammar.h:135381
/** Converts an enum of type SgCastExp::cast_type_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgCastExp_cast_type_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_C_style_cast"; break;
        case 3: retval = "e_const_cast"; break;
        case 4: retval = "e_static_cast"; break;
        case 5: retval = "e_dynamic_cast"; break;
        case 6: retval = "e_reinterpret_cast"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgCastExp::cast_type_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgCastExp::cast_type_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgClassDeclaration::class_types is defined at frontend/SageIII/Cxx_Grammar.h:90782
/** Converts an enum of type SgClassDeclaration::class_types to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgClassDeclaration_class_types(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_class"; break;
        case 1: retval = "e_struct"; break;
        case 2: retval = "e_union"; break;
        case 3: retval = "e_template_parameter"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgClassDeclaration::class_types)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgClassDeclaration::class_types::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgConstVolatileModifier::cv_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:8343
/** Converts an enum of type SgConstVolatileModifier::cv_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgConstVolatileModifier_cv_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_const"; break;
        case 3: retval = "e_volatile"; break;
        case 4: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgConstVolatileModifier::cv_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgConstVolatileModifier::cv_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgDataStatementValue::data_statement_value_enum is defined at frontend/SageIII/Cxx_Grammar.h:36592
/** Converts an enum of type SgDataStatementValue::data_statement_value_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgDataStatementValue_data_statement_value_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_explict_list"; break;
        case 3: retval = "e_implicit_list"; break;
        case 4: retval = "e_implied_do"; break;
        case 5: retval = "e_last_initializer_form"; break;
    }
    if (retval.empty()) {
        char buf[111];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgDataStatementValue::data_statement_value_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgDataStatementValue::data_statement_value_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgDeclarationModifier::declaration_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:13513
/** Converts an enum of type SgDeclarationModifier::declaration_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgDeclarationModifier_declaration_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_friend"; break;
        case 3: retval = "e_typedef"; break;
        case 4: retval = "e_export"; break;
        case 5: retval = "e_throw"; break;
        case 6: retval = "e_bind"; break;
        case 7: retval = "e_final"; break;
        case 8: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[112];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgDeclarationModifier::declaration_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgDeclarationModifier::declaration_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgDeclarationModifier::gnu_declaration_visability_enum is defined at frontend/SageIII/Cxx_Grammar.h:13533
/** Converts an enum of type SgDeclarationModifier::gnu_declaration_visability_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgDeclarationModifier_gnu_declaration_visability_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown_visibility"; break;
        case 1: retval = "e_error_visibility"; break;
        case 2: retval = "e_unspecified_visibility"; break;
        case 3: retval = "e_hidden_visibility"; break;
        case 4: retval = "e_protected_visibility"; break;
        case 5: retval = "e_internal_visibility"; break;
        case 6: retval = "e_default_visibility"; break;
        case 7: retval = "e_last_visibility_attribute"; break;
    }
    if (retval.empty()) {
        char buf[118];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgDeclarationModifier::gnu_declaration_visability_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgDeclarationModifier::gnu_declaration_visability_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgDeclarationStatement::gnu_extension_visability_attribute_enum is defined at frontend/SageIII/Cxx_Grammar.h:79415
/** Converts an enum of type SgDeclarationStatement::gnu_extension_visability_attribute_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgDeclarationStatement_gnu_extension_visability_attribute_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_gnu_attribute_visability_unknown"; break;
        case 1: retval = "e_gnu_attribute_visability_unspecified"; break;
        case 2: retval = "e_gnu_attribute_visability_hidden"; break;
        case 3: retval = "e_gnu_attribute_visability_protected"; break;
        case 4: retval = "e_gnu_attribute_visability_internal"; break;
        case 5: retval = "e_last_gnu_visability_attribute"; break;
    }
    if (retval.empty()) {
        char buf[127];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgDeclarationStatement::gnu_extension_visability_attribute_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgDeclarationStatement::gnu_extension_visability_attribute_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgDeclarationStatement::template_specialization_enum is defined at frontend/SageIII/Cxx_Grammar.h:79400
/** Converts an enum of type SgDeclarationStatement::template_specialization_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgDeclarationStatement_template_specialization_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_no_specialization"; break;
        case 2: retval = "e_partial_specialization"; break;
        case 3: retval = "e_specialization"; break;
        case 4: retval = "e_template_specialization_last"; break;
    }
    if (retval.empty()) {
        char buf[116];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgDeclarationStatement::template_specialization_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgDeclarationStatement::template_specialization_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgElaboratedTypeModifier::elaborated_type_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:11408
/** Converts an enum of type SgElaboratedTypeModifier::elaborated_type_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgElaboratedTypeModifier_elaborated_type_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_class"; break;
        case 3: retval = "e_struct"; break;
        case 4: retval = "e_union"; break;
        case 5: retval = "e_enum"; break;
        case 6: retval = "e_typename"; break;
        case 7: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[119];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgElaboratedTypeModifier::elaborated_type_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgElaboratedTypeModifier::elaborated_type_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgFile::outputFormatOption_enum is defined at frontend/SageIII/Cxx_Grammar.h:18590
/** Converts an enum of type SgFile::outputFormatOption_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgFile_outputFormatOption_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown_output_format"; break;
        case 1: retval = "e_fixed_form_output_format"; break;
        case 2: retval = "e_free_form_output_format"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgFile::outputFormatOption_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgFile::outputFormatOption_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgFile::outputLanguageOption_enum is defined at frontend/SageIII/Cxx_Grammar.h:18604
/** Converts an enum of type SgFile::outputLanguageOption_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgFile_outputLanguageOption_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_error_output_language"; break;
        case 1: retval = "e_default_output_language"; break;
        case 2: retval = "e_C_output_language"; break;
        case 3: retval = "e_Cxx_output_language"; break;
        case 4: retval = "e_Fortran_output_language"; break;
        case 5: retval = "e_Promela_output_language"; break;
        case 6: retval = "e_PHP_output_language"; break;
        case 7: retval = "e_last_output_language"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgFile::outputLanguageOption_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgFile::outputLanguageOption_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgFunctionModifier::function_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:9813
/** Converts an enum of type SgFunctionModifier::function_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgFunctionModifier_function_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_inline"; break;
        case 3: retval = "e_virtual"; break;
        case 4: retval = "e_pure_virtual"; break;
        case 5: retval = "e_explicit"; break;
        case 7: retval = "e_pure"; break;
        case 8: retval = "e_elemental"; break;
        case 9: retval = "e_recursive"; break;
        case 10: retval = "e_gnu_attribute__constructor__"; break;
        case 11: retval = "e_gnu_attribute__destructor__"; break;
        case 12: retval = "e_gnu_attribute__pure__"; break;
        case 13: retval = "e_gnu_attribute__weak__"; break;
        case 14: retval = "e_gnu_attribute__unused__"; break;
        case 15: retval = "e_gnu_attribute__used__"; break;
        case 16: retval = "e_gnu_attribute__deprecated__"; break;
        case 17: retval = "e_gnu_attribute__malloc__"; break;
        case 18: retval = "e_gnu_attribute__naked__"; break;
        case 19: retval = "e_gnu_attribute__no_instrument_function__"; break;
        case 20: retval = "e_gnu_attribute__no_check_memory_usage__"; break;
        case 21: retval = "e_gnu_attribute__noinline__"; break;
        case 22: retval = "e_gnu_attribute__always_inline__"; break;
        case 23: retval = "e_gnu_attribute__nothrow__"; break;
        case 24: retval = "e_gnu_attribute__weakref__"; break;
        case 25: retval = "e_cuda_device"; break;
        case 26: retval = "e_cuda_kernel"; break;
        case 27: retval = "e_cuda_host"; break;
        case 28: retval = "e_opencl_kernel"; break;
        case 29: retval = "e_opencl_vec_type_hint"; break;
        case 30: retval = "e_opencl_work_group_size_hint"; break;
        case 31: retval = "e_opencl_work_group_size_req"; break;
        case 32: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[106];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgFunctionModifier::function_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgFunctionModifier::function_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgGraph::GraphEdgeType is defined at frontend/SageIII/Cxx_Grammar.h:28418
/** Converts an enum of type SgGraph::GraphEdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgGraphGraphEdgeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_type_error"; break;
        case 1: retval = "none"; break;
        case 2: retval = "cfg"; break;
        case 3: retval = "usage"; break;
        case 4: retval = "e_last_type"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgGraph::GraphEdgeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgGraph::GraphEdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgGraph::GraphProperties is defined at frontend/SageIII/Cxx_Grammar.h:28432
/** Converts an enum of type SgGraph::GraphProperties to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgGraphGraphProperties(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_property_error"; break;
        case 1: retval = "name"; break;
        case 2: retval = "type"; break;
        case 3: retval = "nodest_jmp"; break;
        case 4: retval = "itself_call"; break;
        case 5: retval = "nodest_call"; break;
        case 6: retval = "interrupt"; break;
        case 7: retval = "eval"; break;
        case 8: retval = "regs"; break;
        case 9: retval = "done"; break;
        case 10: retval = "dfa_standard"; break;
        case 11: retval = "dfa_resolved_func"; break;
        case 12: retval = "dfa_unresolved_func"; break;
        case 13: retval = "dfa_variable"; break;
        case 14: retval = "dfa_conditional_def"; break;
        case 15: retval = "edgeLabel"; break;
        case 16: retval = "visitedCounter"; break;
        case 17: retval = "variable"; break;
        case 18: retval = "dfa_bufferoverflow"; break;
        case 19: retval = "e_last_property"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgGraph::GraphProperties)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgGraph::GraphProperties::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgIOStatement::io_statement_enum is defined at frontend/SageIII/Cxx_Grammar.h:112641
/** Converts an enum of type SgIOStatement::io_statement_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgIOStatement_io_statement_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_read"; break;
        case 2: retval = "e_print"; break;
        case 3: retval = "e_write"; break;
        case 4: retval = "e_open"; break;
        case 5: retval = "e_close"; break;
        case 6: retval = "e_inquire"; break;
        case 7: retval = "e_backspace"; break;
        case 8: retval = "e_endfile"; break;
        case 9: retval = "e_rewind"; break;
        case 10: retval = "e_last_io_statment_kind"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgIOStatement::io_statement_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgIOStatement::io_statement_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgInitializedName::asm_register_name_enum is defined at frontend/SageIII/Cxx_Grammar.h:59961
/** Converts an enum of type SgInitializedName::asm_register_name_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgInitializedName_asm_register_name_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_invalid_register"; break;
        case 1: retval = "e_memory_register"; break;
        case 2: retval = "e_register_a"; break;
        case 3: retval = "e_register_b"; break;
        case 4: retval = "e_register_c"; break;
        case 5: retval = "e_register_d"; break;
        case 6: retval = "e_register_si"; break;
        case 7: retval = "e_register_di"; break;
        case 8: retval = "e_register_bp"; break;
        case 9: retval = "e_register_sp"; break;
        case 10: retval = "e_register_r8"; break;
        case 11: retval = "e_register_r9"; break;
        case 12: retval = "e_register_r10"; break;
        case 13: retval = "e_register_r11"; break;
        case 14: retval = "e_register_r12"; break;
        case 15: retval = "e_register_r13"; break;
        case 16: retval = "e_register_r14"; break;
        case 17: retval = "e_register_r15"; break;
        case 18: retval = "e_register_st0"; break;
        case 19: retval = "e_register_st1"; break;
        case 20: retval = "e_register_st2"; break;
        case 21: retval = "e_register_st3"; break;
        case 22: retval = "e_register_st4"; break;
        case 23: retval = "e_register_st5"; break;
        case 24: retval = "e_register_st6"; break;
        case 25: retval = "e_register_st7"; break;
        case 26: retval = "e_register_mm0"; break;
        case 27: retval = "e_register_mm1"; break;
        case 28: retval = "e_register_mm2"; break;
        case 29: retval = "e_register_mm3"; break;
        case 30: retval = "e_register_mm4"; break;
        case 31: retval = "e_register_mm5"; break;
        case 32: retval = "e_register_mm6"; break;
        case 33: retval = "e_register_mm7"; break;
        case 34: retval = "e_register_f0"; break;
        case 35: retval = "e_register_f1"; break;
        case 36: retval = "e_register_f2"; break;
        case 37: retval = "e_register_f3"; break;
        case 38: retval = "e_register_f4"; break;
        case 39: retval = "e_register_f5"; break;
        case 40: retval = "e_register_f6"; break;
        case 41: retval = "e_register_f7"; break;
        case 42: retval = "e_register_f8"; break;
        case 43: retval = "e_register_f9"; break;
        case 44: retval = "e_register_f10"; break;
        case 45: retval = "e_register_f11"; break;
        case 46: retval = "e_register_f12"; break;
        case 47: retval = "e_register_f13"; break;
        case 48: retval = "e_register_f14"; break;
        case 49: retval = "e_register_f15"; break;
        case 50: retval = "e_register_flags"; break;
        case 51: retval = "e_register_fpsr"; break;
        case 52: retval = "e_register_dirflag"; break;
        case 53: retval = "e_unrecognized_register"; break;
        case 54: retval = "e_last_register"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgInitializedName::asm_register_name_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgInitializedName::asm_register_name_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgInitializedName::gnu_variable_attribute_enum is defined at frontend/SageIII/Cxx_Grammar.h:60023
/** Converts an enum of type SgInitializedName::gnu_variable_attribute_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgInitializedName_gnu_variable_attribute_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_gnu_attribute__weak__"; break;
        case 1: retval = "e_gnu_attribute__unused__"; break;
        case 2: retval = "e_gnu_attribute__used__"; break;
        case 3: retval = "e_gnu_attribute__deprecated__"; break;
        case 4: retval = "e_gnu_attribute__nocommon__"; break;
        case 5: retval = "e_gnu_attribute__transparent_union__"; break;
        case 6: retval = "e_gnu_attribute__weakref__"; break;
        case 7: retval = "e_last_gnu_variable_attribute"; break;
    }
    if (retval.empty()) {
        char buf[110];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgInitializedName::gnu_variable_attribute_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgInitializedName::gnu_variable_attribute_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgInitializedName::preinitialization_enum is defined at frontend/SageIII/Cxx_Grammar.h:59947
/** Converts an enum of type SgInitializedName::preinitialization_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgInitializedName_preinitialization_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown_preinitialization"; break;
        case 1: retval = "e_virtual_base_class"; break;
        case 2: retval = "e_nonvirtual_base_class"; break;
        case 3: retval = "e_data_member"; break;
        case 4: retval = "e_last_preinitialization"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgInitializedName::preinitialization_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgInitializedName::preinitialization_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgInterfaceStatement::generic_spec_enum is defined at frontend/SageIII/Cxx_Grammar.h:87290
/** Converts an enum of type SgInterfaceStatement::generic_spec_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgInterfaceStatement_generic_spec_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_error_interface_type"; break;
        case 1: retval = "e_default_interface_type"; break;
        case 2: retval = "e_unnamed_interface_type"; break;
        case 3: retval = "e_named_interface_type"; break;
        case 4: retval = "e_operator_interface_type"; break;
        case 5: retval = "e_assignment_interface_type"; break;
        case 6: retval = "e_last_interface_type"; break;
    }
    if (retval.empty()) {
        char buf[103];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgInterfaceStatement::generic_spec_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgInterfaceStatement::generic_spec_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgLabelSymbol::label_type_enum is defined at frontend/SageIII/Cxx_Grammar.h:187948
/** Converts an enum of type SgLabelSymbol::label_type_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgLabelSymbol_label_type_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown_label_type"; break;
        case 1: retval = "e_non_numeric_label_type"; break;
        case 2: retval = "e_start_label_type"; break;
        case 3: retval = "e_else_label_type"; break;
        case 4: retval = "e_end_label_type"; break;
        case 5: retval = "e_alternative_return_type"; break;
        case 6: retval = "e_last_label_type"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgLabelSymbol::label_type_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgLabelSymbol::label_type_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgLinkageModifier::linkage_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:11870
/** Converts an enum of type SgLinkageModifier::linkage_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgLinkageModifier_linkage_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_C_linkage"; break;
        case 3: retval = "e_Cpp_linkage"; break;
        case 4: retval = "e_fortran_linkage"; break;
        case 5: retval = "e_fortran90_linkage"; break;
        case 6: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgLinkageModifier::linkage_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgLinkageModifier::linkage_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgMemberFunctionType::mfunc_specifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:52788
/** Converts an enum of type SgMemberFunctionType::mfunc_specifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgMemberFunctionType_mfunc_specifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "e_const"; break;
        case 2: retval = "e_volatile"; break;
        case 4: retval = "e_restrict"; break;
    }
    if (retval.empty()) {
        char buf[106];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgMemberFunctionType::mfunc_specifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgMemberFunctionType::mfunc_specifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgOmpClause::omp_default_option_enum is defined at frontend/SageIII/Cxx_Grammar.h:61654
/** Converts an enum of type SgOmpClause::omp_default_option_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgOmpClause_omp_default_option_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_omp_default_unkown"; break;
        case 1: retval = "e_omp_default_none"; break;
        case 2: retval = "e_omp_default_shared"; break;
        case 3: retval = "e_omp_default_private"; break;
        case 4: retval = "e_omp_default_firstprivate"; break;
        case 5: retval = "e_omp_default_last"; break;
    }
    if (retval.empty()) {
        char buf[100];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgOmpClause::omp_default_option_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgOmpClause::omp_default_option_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgOmpClause::omp_reduction_operator_enum is defined at frontend/SageIII/Cxx_Grammar.h:61677
/** Converts an enum of type SgOmpClause::omp_reduction_operator_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgOmpClause_omp_reduction_operator_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_omp_reduction_unkown"; break;
        case 1: retval = "e_omp_reduction_plus"; break;
        case 2: retval = "e_omp_reduction_mul"; break;
        case 3: retval = "e_omp_reduction_minus"; break;
        case 4: retval = "e_omp_reduction_bitand"; break;
        case 5: retval = "e_omp_reduction_bitor"; break;
        case 6: retval = "e_omp_reduction_bitxor"; break;
        case 7: retval = "e_omp_reduction_logand"; break;
        case 8: retval = "e_omp_reduction_logor"; break;
        case 9: retval = "e_omp_reduction_and"; break;
        case 10: retval = "e_omp_reduction_or"; break;
        case 11: retval = "e_omp_reduction_eqv"; break;
        case 12: retval = "e_omp_reduction_neqv"; break;
        case 13: retval = "e_omp_reduction_max"; break;
        case 14: retval = "e_omp_reduction_min"; break;
        case 15: retval = "e_omp_reduction_iand"; break;
        case 16: retval = "e_omp_reduction_ior"; break;
        case 17: retval = "e_omp_reduction_ieor"; break;
        case 18: retval = "e_omp_reduction_last"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgOmpClause::omp_reduction_operator_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgOmpClause::omp_reduction_operator_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgOmpClause::omp_schedule_kind_enum is defined at frontend/SageIII/Cxx_Grammar.h:61666
/** Converts an enum of type SgOmpClause::omp_schedule_kind_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgOmpClause_omp_schedule_kind_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_omp_schedule_unkown"; break;
        case 1: retval = "e_omp_schedule_static"; break;
        case 2: retval = "e_omp_schedule_dynamic"; break;
        case 3: retval = "e_omp_schedule_guided"; break;
        case 4: retval = "e_omp_schedule_auto"; break;
        case 5: retval = "e_omp_schedule_runtime"; break;
        case 6: retval = "e_omp_schedule_last"; break;
    }
    if (retval.empty()) {
        char buf[99];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgOmpClause::omp_schedule_kind_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgOmpClause::omp_schedule_kind_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgOpenclAccessModeModifier::access_mode_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:14039
/** Converts an enum of type SgOpenclAccessModeModifier::access_mode_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgOpenclAccessModeModifier_access_mode_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_read_only"; break;
        case 3: retval = "e_write_only"; break;
        case 4: retval = "e_read_write"; break;
        case 5: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[117];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgOpenclAccessModeModifier::access_mode_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgOpenclAccessModeModifier::access_mode_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgProcedureHeaderStatement::subprogram_kind_enum is defined at frontend/SageIII/Cxx_Grammar.h:96872
/** Converts an enum of type SgProcedureHeaderStatement::subprogram_kind_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgProcedureHeaderStatement_subprogram_kind_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown_kind"; break;
        case 1: retval = "e_function_subprogram_kind"; break;
        case 2: retval = "e_subroutine_subprogram_kind"; break;
        case 3: retval = "e_block_data_subprogram_kind"; break;
        case 4: retval = "e_last_subprogram_kind"; break;
    }
    if (retval.empty()) {
        char buf[112];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgProcedureHeaderStatement::subprogram_kind_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgProcedureHeaderStatement::subprogram_kind_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgProject::template_instantiation_enum is defined at frontend/SageIII/Cxx_Grammar.h:21306
/** Converts an enum of type SgProject::template_instantiation_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgProject_template_instantiation_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_none"; break;
        case 3: retval = "e_used"; break;
        case 4: retval = "e_all"; break;
        case 5: retval = "e_local"; break;
        case 6: retval = "e_last"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgProject::template_instantiation_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgProject::template_instantiation_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgSpecialFunctionModifier::special_function_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:10941
/** Converts an enum of type SgSpecialFunctionModifier::special_function_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgSpecialFunctionModifier_special_function_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_constructor"; break;
        case 3: retval = "e_destructor"; break;
        case 4: retval = "e_conversion"; break;
        case 5: retval = "e_operator"; break;
        case 6: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[121];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgSpecialFunctionModifier::special_function_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgSpecialFunctionModifier::special_function_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgStopOrPauseStatement::stop_or_pause_enum is defined at frontend/SageIII/Cxx_Grammar.h:112207
/** Converts an enum of type SgStopOrPauseStatement::stop_or_pause_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgStopOrPauseStatement_stop_or_pause_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_stop"; break;
        case 2: retval = "e_pause"; break;
    }
    if (retval.empty()) {
        char buf[106];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgStopOrPauseStatement::stop_or_pause_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgStopOrPauseStatement::stop_or_pause_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgStorageModifier::storage_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:8805
/** Converts an enum of type SgStorageModifier::storage_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgStorageModifier_storage_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_extern"; break;
        case 3: retval = "e_static"; break;
        case 4: retval = "e_auto"; break;
        case 5: retval = "e_unspecified"; break;
        case 6: retval = "e_register"; break;
        case 7: retval = "e_mutable"; break;
        case 8: retval = "e_typedef"; break;
        case 9: retval = "e_asm"; break;
        case 10: retval = "e_local"; break;
        case 11: retval = "e_common"; break;
        case 12: retval = "e_associated"; break;
        case 13: retval = "e_intrinsic"; break;
        case 14: retval = "e_pointer_based"; break;
        case 15: retval = "e_cuda_global"; break;
        case 16: retval = "e_cuda_constant"; break;
        case 17: retval = "e_cuda_shared"; break;
        case 18: retval = "e_cuda_dynamic_shared"; break;
        case 19: retval = "e_opencl_global"; break;
        case 20: retval = "e_opencl_local"; break;
        case 21: retval = "e_opencl_constant"; break;
        case 22: retval = "e_opencl_private"; break;
        case 23: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgStorageModifier::storage_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgStorageModifier::storage_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgTemplateArgument::template_argument_enum is defined at frontend/SageIII/Cxx_Grammar.h:24935
/** Converts an enum of type SgTemplateArgument::template_argument_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTemplateArgument_template_argument_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "argument_undefined"; break;
        case 1: retval = "type_argument"; break;
        case 2: retval = "nontype_argument"; break;
        case 3: retval = "template_template_argument"; break;
    }
    if (retval.empty()) {
        char buf[106];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgTemplateArgument::template_argument_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgTemplateArgument::template_argument_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgTemplateDeclaration::template_type_enum is defined at frontend/SageIII/Cxx_Grammar.h:84674
/** Converts an enum of type SgTemplateDeclaration::template_type_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTemplateDeclaration_template_type_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_template_none"; break;
        case 1: retval = "e_template_class"; break;
        case 2: retval = "e_template_m_class"; break;
        case 3: retval = "e_template_function"; break;
        case 4: retval = "e_template_m_function"; break;
        case 5: retval = "e_template_m_data"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgTemplateDeclaration::template_type_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgTemplateDeclaration::template_type_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgTemplateParameter::template_parameter_enum is defined at frontend/SageIII/Cxx_Grammar.h:24467
/** Converts an enum of type SgTemplateParameter::template_parameter_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTemplateParameter_template_parameter_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "parameter_undefined"; break;
        case 1: retval = "type_parameter"; break;
        case 2: retval = "nontype_parameter"; break;
        case 3: retval = "template_parameter"; break;
    }
    if (retval.empty()) {
        char buf[108];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgTemplateParameter::template_parameter_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgTemplateParameter::template_parameter_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgThrowOp::e_throw_kind is defined at frontend/SageIII/Cxx_Grammar.h:135835
/** Converts an enum of type SgThrowOp::e_throw_kind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgThrowOp_e_throw_kind(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "unknown_throw"; break;
        case 1: retval = "throw_expression"; break;
        case 2: retval = "rethrow"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgThrowOp::e_throw_kind)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgThrowOp::e_throw_kind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgToken::ROSE_C_CXX_Operators is defined at frontend/SageIII/Cxx_Grammar.h:182840
/** Converts an enum of type SgToken::ROSE_C_CXX_Operators to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTokenROSE_C_CXX_Operators(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 50000: retval = "C_CXX_AND"; break;
        case 50001: retval = "C_CXX_ANDAND"; break;
        case 50002: retval = "C_CXX_ASSIGN"; break;
        case 50003: retval = "C_CXX_ANDASSIGN"; break;
        case 50004: retval = "C_CXX_OR"; break;
        case 50005: retval = "C_CXX_ORASSIGN"; break;
        case 50006: retval = "C_CXX_XOR"; break;
        case 50007: retval = "C_CXX_XORASSIGN"; break;
        case 50008: retval = "C_CXX_COMMA"; break;
        case 50009: retval = "C_CXX_COLON"; break;
        case 50010: retval = "C_CXX_DIVIDE"; break;
        case 50011: retval = "C_CXX_DIVIDEASSIGN"; break;
        case 50012: retval = "C_CXX_DOT"; break;
        case 50013: retval = "C_CXX_DOTSTAR"; break;
        case 50014: retval = "C_CXX_ELLIPSIS"; break;
        case 50015: retval = "C_CXX_EQUAL"; break;
        case 50016: retval = "C_CXX_GREATER"; break;
        case 50017: retval = "C_CXX_GREATEREQUAL"; break;
        case 50018: retval = "C_CXX_LEFTBRACE"; break;
        case 50019: retval = "C_CXX_LESS"; break;
        case 50020: retval = "C_CXX_LESSEQUAL"; break;
        case 50021: retval = "C_CXX_LEFTPAREN"; break;
        case 50022: retval = "C_CXX_LEFTBRACKET"; break;
        case 50023: retval = "C_CXX_MINUS"; break;
        case 50024: retval = "C_CXX_MINUSASSIGN"; break;
        case 50025: retval = "C_CXX_MINUSMINUS"; break;
        case 50026: retval = "C_CXX_PERCENT"; break;
        case 50027: retval = "C_CXX_PERCENTASSIGN"; break;
        case 50028: retval = "C_CXX_NOT"; break;
        case 50029: retval = "C_CXX_NOTEQUAL"; break;
        case 50030: retval = "C_CXX_OROR"; break;
        case 50031: retval = "C_CXX_PLUS"; break;
        case 50032: retval = "C_CXX_PLUSASSIGN"; break;
        case 50033: retval = "C_CXX_PLUSPLUS"; break;
        case 50034: retval = "C_CXX_ARROW"; break;
        case 50035: retval = "C_CXX_ARROWSTAR"; break;
        case 50036: retval = "C_CXX_QUESTION_MARK"; break;
        case 50037: retval = "C_CXX_RIGHTBRACE"; break;
        case 50038: retval = "C_CXX_RIGHTPAREN"; break;
        case 50039: retval = "C_CXX_RIGHTBRACKET"; break;
        case 50040: retval = "C_CXX_COLON_COLON"; break;
        case 50041: retval = "C_CXX_SEMICOLON"; break;
        case 50042: retval = "C_CXX_SHIFTLEFT"; break;
        case 50043: retval = "C_CXX_SHIFTLEFTASSIGN"; break;
        case 50044: retval = "C_CXX_SHIFTRIGHT"; break;
        case 50045: retval = "C_CXX_SHIFTRIGHTASSIGN"; break;
        case 50046: retval = "C_CXX_STAR"; break;
        case 50047: retval = "C_CXX_COMPL"; break;
        case 50048: retval = "C_CXX_STARASSIGN"; break;
        case 50049: retval = "C_CXX_POUND_POUND"; break;
        case 50050: retval = "C_CXX_POUND"; break;
        case 50051: retval = "C_CXX_AND_ALT"; break;
        case 50052: retval = "C_CXX_ANDASSIGN_ALT"; break;
        case 50053: retval = "C_CXX_OR_ALT"; break;
        case 50054: retval = "C_CXX_ORASSIGN_ALT"; break;
        case 50055: retval = "C_CXX_XOR_ALT"; break;
        case 50056: retval = "C_CXX_XORASSIGN_ALT"; break;
        case 50057: retval = "C_CXX_LEFTBRACE_ALT"; break;
        case 50058: retval = "C_CXX_LEFTBRACKET_ALT"; break;
        case 50059: retval = "C_CXX_NOT_ALT"; break;
        case 50060: retval = "C_CXX_NOTEQUAL_ALT"; break;
        case 50061: retval = "C_CXX_RIGHTBRACE_ALT"; break;
        case 50062: retval = "C_CXX_RIGHTBRACKET_ALT"; break;
        case 50063: retval = "C_CXX_COMPL_ALT"; break;
        case 50064: retval = "C_CXX_POUND_POUND_ALT"; break;
        case 50065: retval = "C_CXX_POUND_ALT"; break;
        case 50066: retval = "C_CXX_OR_TRIGRAPH"; break;
        case 50067: retval = "C_CXX_XOR_TRIGRAPH"; break;
        case 50068: retval = "C_CXX_LEFTBRACE_TRIGRAPH"; break;
        case 50069: retval = "C_CXX_LEFTBRACKET_TRIGRAPH"; break;
        case 50070: retval = "C_CXX_RIGHTBRACE_TRIGRAPH"; break;
        case 50071: retval = "C_CXX_RIGHTBRACKET_TRIGRAPH"; break;
        case 50072: retval = "C_CXX_COMPL_TRIGRAPH"; break;
        case 50073: retval = "C_CXX_POUND_POUND_TRIGRAPH"; break;
        case 50074: retval = "C_CXX_POUND_TRIGRAPH"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgToken::ROSE_C_CXX_Operators)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgToken::ROSE_C_CXX_Operators::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgToken::ROSE_C_CXX_keywords is defined at frontend/SageIII/Cxx_Grammar.h:182744
/** Converts an enum of type SgToken::ROSE_C_CXX_keywords to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTokenROSE_C_CXX_keywords(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 500: retval = "C_CXX_ASM"; break;
        case 501: retval = "C_CXX_AUTO"; break;
        case 502: retval = "C_CXX_BOOL"; break;
        case 503: retval = "C_CXX_BREAK"; break;
        case 504: retval = "C_CXX_CASE"; break;
        case 505: retval = "C_CXX_CATCH"; break;
        case 506: retval = "C_CXX_CHAR"; break;
        case 507: retval = "C_CXX_CLASS"; break;
        case 508: retval = "C_CXX_CONST"; break;
        case 509: retval = "C_CXX_CONSTCAST"; break;
        case 510: retval = "C_CXX_CONTINUE"; break;
        case 511: retval = "C_CXX_DEFAULT"; break;
        case 512: retval = "C_CXX_DEFINED"; break;
        case 513: retval = "C_CXX_DELETE"; break;
        case 514: retval = "C_CXX_DO"; break;
        case 515: retval = "C_CXX_DOUBLE"; break;
        case 516: retval = "C_CXX_DYNAMICCAST"; break;
        case 517: retval = "C_CXX_ELSE"; break;
        case 518: retval = "C_CXX_ENUM"; break;
        case 519: retval = "C_CXX_EXPLICIT"; break;
        case 520: retval = "C_CXX_EXPORT"; break;
        case 521: retval = "C_CXX_EXTERN"; break;
        case 522: retval = "C_CXX_FALSE"; break;
        case 523: retval = "C_CXX_FLOAT"; break;
        case 524: retval = "C_CXX_FOR"; break;
        case 525: retval = "C_CXX_FRIEND"; break;
        case 526: retval = "C_CXX_GOTO"; break;
        case 527: retval = "C_CXX_IF"; break;
        case 528: retval = "C_CXX_INLINE"; break;
        case 529: retval = "C_CXX_INT"; break;
        case 530: retval = "C_CXX_LONG"; break;
        case 531: retval = "C_CXX_MUTABLE"; break;
        case 532: retval = "C_CXX_NAMESPACE"; break;
        case 533: retval = "C_CXX_NEW"; break;
        case 534: retval = "C_CXX_OPERATOR"; break;
        case 535: retval = "C_CXX_PRIVATE"; break;
        case 536: retval = "C_CXX_PROTECTED"; break;
        case 537: retval = "C_CXX_PUBLIC"; break;
        case 538: retval = "C_CXX_REGISTER"; break;
        case 539: retval = "C_CXX_REINTERPRETCAST"; break;
        case 540: retval = "C_CXX_RETURN"; break;
        case 541: retval = "C_CXX_SHORT"; break;
        case 542: retval = "C_CXX_SIGNED"; break;
        case 543: retval = "C_CXX_SIZEOF"; break;
        case 544: retval = "C_CXX_STATIC"; break;
        case 545: retval = "C_CXX_STATICCAST"; break;
        case 546: retval = "C_CXX_STRUCT"; break;
        case 547: retval = "C_CXX_SWITCH"; break;
        case 548: retval = "C_CXX_TEMPLATE"; break;
        case 549: retval = "C_CXX_THIS"; break;
        case 550: retval = "C_CXX_THROW"; break;
        case 551: retval = "C_CXX_TRY"; break;
        case 552: retval = "C_CXX_TRUE"; break;
        case 553: retval = "C_CXX_TYPEDEF"; break;
        case 554: retval = "C_CXX_TYPEID"; break;
        case 555: retval = "C_CXX_TYPENAME"; break;
        case 556: retval = "C_CXX_UNION"; break;
        case 557: retval = "C_CXX_UNSIGNED"; break;
        case 558: retval = "C_CXX_USING"; break;
        case 559: retval = "C_CXX_VIRTUAL"; break;
        case 560: retval = "C_CXX_VOID"; break;
        case 561: retval = "C_CXX_VOLATILE"; break;
        case 562: retval = "C_CXX_WCHART"; break;
        case 563: retval = "C_CXX_WHILE"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgToken::ROSE_C_CXX_keywords)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgToken::ROSE_C_CXX_keywords::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgToken::ROSE_Fortran_Additional_Info is defined at frontend/SageIII/Cxx_Grammar.h:182920
/** Converts an enum of type SgToken::ROSE_Fortran_Additional_Info to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTokenROSE_Fortran_Additional_Info(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 100000: retval = "FORTRAN_COMMENTS"; break;
        case 100001: retval = "FORTRAN_STRING_LITERALS"; break;
        case 100002: retval = "FORTRAN_IDENTIFIER"; break;
        case 100003: retval = "FORTRAN_UNIDENTIFIED_TOKEN"; break;
        case 100004: retval = "FORTRAN_ERROR"; break;
    }
    if (retval.empty()) {
        char buf[101];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgToken::ROSE_Fortran_Additional_Info)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgToken::ROSE_Fortran_Additional_Info::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgToken::ROSE_Fortran_Keywords is defined at frontend/SageIII/Cxx_Grammar.h:182613
/** Converts an enum of type SgToken::ROSE_Fortran_Keywords to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTokenROSE_Fortran_Keywords(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FORTRAN_ABSTRACT"; break;
        case 1: retval = "FORTRAN_ACCESS"; break;
        case 2: retval = "FORTRAN_ACTION"; break;
        case 3: retval = "FORTRAN_ALLOCATE"; break;
        case 4: retval = "FORTRAN_ALLOCATABLE"; break;
        case 5: retval = "FORTRAN_ASSIGN"; break;
        case 6: retval = "FORTRAN_ASSOCIATE"; break;
        case 7: retval = "FORTRAN_ASYNCHRONOUS"; break;
        case 8: retval = "FORTRAN_BACKSPACE"; break;
        case 9: retval = "FORTRAN_BIND"; break;
        case 10: retval = "FORTRAN_BLANK"; break;
        case 11: retval = "FORTRAN_BLOCK_DATA"; break;
        case 12: retval = "FORTRAN_CALL"; break;
        case 13: retval = "FORTRAN_CHARACTER"; break;
        case 14: retval = "FORTRAN_CLASS"; break;
        case 15: retval = "FORTRAN_CLOSE"; break;
        case 16: retval = "FORTRAN_CONTINUE"; break;
        case 17: retval = "FORTRAN_CYCLE"; break;
        case 18: retval = "FORTRAN_CASE"; break;
        case 19: retval = "FORTRAN_COMMON"; break;
        case 20: retval = "FORTRAN_COMPLEX"; break;
        case 21: retval = "FORTRAN_CONTAINS"; break;
        case 22: retval = "FORTRAN_DEALLOCATE"; break;
        case 23: retval = "FORTRAN_DATA"; break;
        case 24: retval = "FORTRAN_DEFERRED"; break;
        case 25: retval = "FORTRAN_DELIM"; break;
        case 26: retval = "FORTRAN_DIMENSION"; break;
        case 27: retval = "FORTRAN_DO"; break;
        case 28: retval = "FORTRAN_DT"; break;
        case 29: retval = "FORTRAN_DOUBLEPRECISION"; break;
        case 30: retval = "FORTRAN_ENCODING"; break;
        case 31: retval = "FORTRAN_END_CASE"; break;
        case 32: retval = "FORTRAN_ENDDO"; break;
        case 33: retval = "FORTRAN_END_FILE"; break;
        case 34: retval = "FORTRAN_END_ENUM"; break;
        case 35: retval = "FORTRAN_END_INTERFACE"; break;
        case 36: retval = "FORTRAN_END_TYPE"; break;
        case 37: retval = "FORTRAN_ERR"; break;
        case 38: retval = "FORTRAN_ERRMSG"; break;
        case 39: retval = "FORTRAN_EXIT"; break;
        case 40: retval = "FORTRAN_ELSE"; break;
        case 41: retval = "FORTRAN_ELSEWHERE"; break;
        case 42: retval = "FORTRAN_ELSEIF"; break;
        case 43: retval = "FORTRAN_ENDIF"; break;
        case 44: retval = "FORTRAN_ENTRY"; break;
        case 45: retval = "FORTRAN_END"; break;
        case 46: retval = "FORTRAN_ENUM"; break;
        case 47: retval = "FORTRAN_ENUMERATOR"; break;
        case 48: retval = "FORTRAN_EQUIVALENCE"; break;
        case 49: retval = "FORTRAN_EXTERNAL"; break;
        case 50: retval = "FORTRAN_EXTENDS"; break;
        case 51: retval = "FORTRAN_FILE"; break;
        case 52: retval = "FORTRAN_FINAL"; break;
        case 53: retval = "FORTRAN_FMT"; break;
        case 54: retval = "FORTRAN_FORALL"; break;
        case 55: retval = "FORTRAN_FORM"; break;
        case 56: retval = "FORTRAN_FORMATTED"; break;
        case 57: retval = "FORTRAN_FORMAT"; break;
        case 58: retval = "FORTRAN_FLUSH"; break;
        case 59: retval = "FORTRAN_FUNCTION"; break;
        case 60: retval = "FORTRAN_GENERIC"; break;
        case 61: retval = "FORTRAN_GOTO"; break;
        case 62: retval = "FORTRAN_ID"; break;
        case 63: retval = "FORTRAN_IF"; break;
        case 64: retval = "FORTRAN_INQUIRE"; break;
        case 65: retval = "FORTRAN_INTEGER"; break;
        case 66: retval = "FORTRAN_IOMSG"; break;
        case 67: retval = "FORTRAN_IOSTAT"; break;
        case 68: retval = "FORTRAN_IMPLICIT"; break;
        case 69: retval = "FORTRAN_IMPLICIT_NONE"; break;
        case 70: retval = "FORTRAN_IMPORT"; break;
        case 71: retval = "FORTRAN_INTERFACE"; break;
        case 72: retval = "FORTRAN_INTENT"; break;
        case 73: retval = "FORTRAN_INTRINSIC"; break;
        case 74: retval = "FORTRAN_LEN"; break;
        case 75: retval = "FORTRAN_LOGICAL"; break;
        case 76: retval = "FORTRAN_KIND"; break;
        case 77: retval = "FORTRAN_MODULE_PROC"; break;
        case 78: retval = "FORTRAN_MODULE"; break;
        case 79: retval = "FORTRAN_NON_INTRINSIC"; break;
        case 80: retval = "FORTRAN_NON_OVERRIDABLE"; break;
        case 81: retval = "FORTRAN_NULL"; break;
        case 82: retval = "FORTRAN_NULLIFY"; break;
        case 83: retval = "FORTRAN_NAMELIST"; break;
        case 84: retval = "FORTRAN_NML"; break;
        case 85: retval = "FORTRAN_NONE"; break;
        case 86: retval = "FORTRAN_NOPASS"; break;
        case 87: retval = "FORTRAN_ONLY"; break;
        case 88: retval = "FORTRAN_OPEN"; break;
        case 89: retval = "FORTRAN_OPTIONAL"; break;
        case 90: retval = "FORTRAN_PARAMETER"; break;
        case 91: retval = "FORTRAN_PASS"; break;
        case 92: retval = "FORTRAN_PAUSE"; break;
        case 93: retval = "FORTRAN_POINTER"; break;
        case 94: retval = "FORTRAN_PRINT"; break;
        case 95: retval = "FORTRAN_PRIVATE"; break;
        case 96: retval = "FORTRAN_PROCEDURE"; break;
        case 97: retval = "FORTRAN_PROGRAM"; break;
        case 98: retval = "FORTRAN_PROTECTED"; break;
        case 99: retval = "FORTRAN_READ"; break;
        case 100: retval = "FORTRAN_REAL"; break;
        case 101: retval = "FORTRAN_RETURN"; break;
        case 102: retval = "FORTRAN_REWIND"; break;
        case 103: retval = "FORTRAN_ROUND"; break;
        case 104: retval = "FORTRAN_SELECTCASE"; break;
        case 105: retval = "FORTRAN_SELECTTYPE"; break;
        case 106: retval = "FORTRAN_SEQUENCE"; break;
        case 107: retval = "FORTRAN_SAVE"; break;
        case 108: retval = "FORTRAN_SIGN"; break;
        case 109: retval = "FORTRAN_SIZE"; break;
        case 110: retval = "FORTRAN_SOURCE"; break;
        case 111: retval = "FORTRAN_STAT"; break;
        case 112: retval = "FORTRAN_STOP"; break;
        case 113: retval = "FORTRAN_SUBROUTINE"; break;
        case 114: retval = "FORTRAN_TARGET"; break;
        case 115: retval = "FORTRAN_THEN"; break;
        case 116: retval = "FORTRAN_DERIVED_DECL"; break;
        case 117: retval = "FORTRAN_TYPEIS"; break;
        case 118: retval = "FORTRAN_UNFORMATTED"; break;
        case 119: retval = "FORTRAN_UNIT"; break;
        case 120: retval = "FORTRAN_USE"; break;
        case 121: retval = "FORTRAN_VALUE"; break;
        case 122: retval = "FORTRAN_VOLATILE"; break;
        case 123: retval = "FORTRAN_WAIT"; break;
        case 124: retval = "FORTRAN_WHERE"; break;
        case 125: retval = "FORTRAN_WRITE"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgToken::ROSE_Fortran_Keywords)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgToken::ROSE_Fortran_Keywords::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgToken::ROSE_Fortran_Operators is defined at frontend/SageIII/Cxx_Grammar.h:182813
/** Converts an enum of type SgToken::ROSE_Fortran_Operators to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTokenROSE_Fortran_Operators(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 10000: retval = "FORTRAN_INTRINSIC_PLUS"; break;
        case 10001: retval = "FORTRAN_INTRINSIC_MINUS"; break;
        case 10002: retval = "FORTRAN_INTRINSIC_POWER"; break;
        case 10003: retval = "FORTRAN_INTRINSIC_CONCAT"; break;
        case 10004: retval = "FORTRAN_INTRINSIC_TIMES"; break;
        case 10005: retval = "FORTRAN_INTRINSIC_DIVIDE"; break;
        case 10006: retval = "FORTRAN_INTRINSIC_AND"; break;
        case 10007: retval = "FORTRAN_INTRINSIC_OR"; break;
        case 10008: retval = "FORTRAN_INTRINSIC_EQV"; break;
        case 10009: retval = "FORTRAN_INTRINSIC_NEQV"; break;
        case 10010: retval = "FORTRAN_INTRINSIC_EQ"; break;
        case 10011: retval = "FORTRAN_INTRINSIC_NE"; break;
        case 10012: retval = "FORTRAN_INTRINSIC_GE"; break;
        case 10013: retval = "FORTRAN_INTRINSIC_LE"; break;
        case 10014: retval = "FORTRAN_INTRINSIC_LT"; break;
        case 10015: retval = "FORTRAN_INTRINSIC_GT"; break;
        case 10016: retval = "FORTRAN_INTRINSIC_NOT"; break;
        case 10017: retval = "FORTRAN_INTRINSIC_OLDEQ"; break;
        case 10018: retval = "FORTRAN_INTRINSIC_OLDNE"; break;
        case 10019: retval = "FORTRAN_INTRINSIC_OLDGE"; break;
        case 10020: retval = "FORTRAN_INTRINSIC_OLDLE"; break;
        case 10021: retval = "FORTRAN_INTRINSIC_OLDLT"; break;
        case 10022: retval = "FORTRAN_INTRINSIC_OLDGT"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgToken::ROSE_Fortran_Operators)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgToken::ROSE_Fortran_Operators::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgType::fortran_attribute_specifiers_enum is defined at frontend/SageIII/Cxx_Grammar.h:37166
/** Converts an enum of type SgType::fortran_attribute_specifiers_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgType_fortran_attribute_specifiers_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown_attribute_specifier"; break;
        case 1: retval = "e_public_access"; break;
        case 2: retval = "e_private_access"; break;
        case 3: retval = "e_allocatable"; break;
        case 4: retval = "e_asynchronous"; break;
        case 5: retval = "e_bind"; break;
        case 6: retval = "e_data"; break;
        case 7: retval = "e_dimension"; break;
        case 8: retval = "e_intent"; break;
        case 9: retval = "e_optional"; break;
        case 10: retval = "e_parameter"; break;
        case 11: retval = "e_pointer"; break;
        case 12: retval = "e_protected"; break;
        case 13: retval = "e_save"; break;
        case 14: retval = "e_target"; break;
        case 15: retval = "e_value"; break;
        case 16: retval = "e_volatile"; break;
        case 17: retval = "e_last_attribute_specifier"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgType::fortran_attribute_specifiers_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgType::fortran_attribute_specifiers_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgTypeModifier::gnu_extension_machine_mode_enum is defined at frontend/SageIII/Cxx_Grammar.h:12847
/** Converts an enum of type SgTypeModifier::gnu_extension_machine_mode_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTypeModifier_gnu_extension_machine_mode_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_gnu_extension_machine_mode_unknown"; break;
        case 1: retval = "e_gnu_extension_machine_mode_unspecified"; break;
        case 2: retval = "e_gnu_extension_machine_mode_BImode"; break;
        case 3: retval = "e_gnu_extension_machine_mode_QImode"; break;
        case 4: retval = "e_gnu_extension_machine_mode_HImode"; break;
        case 5: retval = "e_gnu_extension_machine_mode_PSImode"; break;
        case 6: retval = "e_gnu_extension_machine_mode_SImode"; break;
        case 7: retval = "e_gnu_extension_machine_mode_PDImode"; break;
        case 8: retval = "e_gnu_extension_machine_mode_DImode"; break;
        case 9: retval = "e_gnu_extension_machine_mode_TImode"; break;
        case 10: retval = "e_gnu_extension_machine_mode_OImode"; break;
        case 11: retval = "e_gnu_extension_machine_mode_QFmode"; break;
        case 12: retval = "e_gnu_extension_machine_mode_HFmode"; break;
        case 13: retval = "e_gnu_extension_machine_mode_TQFmode"; break;
        case 14: retval = "e_gnu_extension_machine_mode_SFmode"; break;
        case 15: retval = "e_gnu_extension_machine_mode_DFmode"; break;
        case 16: retval = "e_gnu_extension_machine_mode_XFmode"; break;
        case 17: retval = "e_gnu_extension_machine_mode_SDmode"; break;
        case 18: retval = "e_gnu_extension_machine_mode_DDmode"; break;
        case 19: retval = "e_gnu_extension_machine_mode_TDmode"; break;
        case 20: retval = "e_gnu_extension_machine_mode_TFmode"; break;
        case 21: retval = "e_gnu_extension_machine_mode_QQmode"; break;
        case 22: retval = "e_gnu_extension_machine_mode_HQmode"; break;
        case 23: retval = "e_gnu_extension_machine_mode_SQmode"; break;
        case 24: retval = "e_gnu_extension_machine_mode_DQmode"; break;
        case 25: retval = "e_gnu_extension_machine_mode_TQmode"; break;
        case 26: retval = "e_gnu_extension_machine_mode_UQQmode"; break;
        case 27: retval = "e_gnu_extension_machine_mode_UHQmode"; break;
        case 28: retval = "e_gnu_extension_machine_mode_USQmode"; break;
        case 29: retval = "e_gnu_extension_machine_mode_UDQmode"; break;
        case 30: retval = "e_gnu_extension_machine_mode_UTQmode"; break;
        case 31: retval = "e_gnu_extension_machine_mode_HAmode"; break;
        case 32: retval = "e_gnu_extension_machine_mode_SAmode"; break;
        case 33: retval = "e_gnu_extension_machine_mode_DAmode"; break;
        case 34: retval = "e_gnu_extension_machine_mode_TAmode"; break;
        case 35: retval = "e_gnu_extension_machine_mode_UHAmode"; break;
        case 36: retval = "e_gnu_extension_machine_mode_USAmode"; break;
        case 37: retval = "e_gnu_extension_machine_mode_UDAmode"; break;
        case 38: retval = "e_gnu_extension_machine_mode_UTAmode"; break;
        case 39: retval = "e_gnu_extension_machine_mode_CCmode"; break;
        case 40: retval = "e_gnu_extension_machine_mode_BLKmode"; break;
        case 41: retval = "e_gnu_extension_machine_mode_VOIDmode"; break;
        case 42: retval = "e_gnu_extension_machine_mode_QCmode"; break;
        case 43: retval = "e_gnu_extension_machine_mode_HCmode"; break;
        case 44: retval = "e_gnu_extension_machine_mode_SCmode"; break;
        case 45: retval = "e_gnu_extension_machine_mode_DCmode"; break;
        case 46: retval = "e_gnu_extension_machine_mode_XCmode"; break;
        case 47: retval = "e_gnu_extension_machine_mode_TCmode"; break;
        case 48: retval = "e_gnu_extension_machine_mode_CQImode"; break;
        case 49: retval = "e_gnu_extension_machine_mode_CHImode"; break;
        case 50: retval = "e_gnu_extension_machine_mode_CSImode"; break;
        case 51: retval = "e_gnu_extension_machine_mode_CDImode"; break;
        case 52: retval = "e_gnu_extension_machine_mode_CTImode"; break;
        case 53: retval = "e_gnu_extension_machine_mode_COImode"; break;
        case 54: retval = "e_last_machine_mode"; break;
    }
    if (retval.empty()) {
        char buf[111];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgTypeModifier::gnu_extension_machine_mode_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgTypeModifier::gnu_extension_machine_mode_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgTypeModifier::type_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:12780
/** Converts an enum of type SgTypeModifier::type_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTypeModifier_type_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_restrict"; break;
        case 3: retval = "e_allocatable"; break;
        case 4: retval = "e_asynchronous"; break;
        case 5: retval = "e_bind"; break;
        case 6: retval = "e_data"; break;
        case 7: retval = "e_dimension"; break;
        case 8: retval = "e_intent_in"; break;
        case 9: retval = "e_intent_out"; break;
        case 10: retval = "e_intent_inout"; break;
        case 11: retval = "e_intrinsic"; break;
        case 12: retval = "e_optional"; break;
        case 13: retval = "e_extends"; break;
        case 14: retval = "e_abstract"; break;
        case 15: retval = "e_save"; break;
        case 16: retval = "e_target"; break;
        case 17: retval = "e_value"; break;
        case 18: retval = "e_gnu_attribute__unused__"; break;
        case 19: retval = "e_gnu_attribute__packed__"; break;
        case 20: retval = "e_gnu_attribute__deprecated__"; break;
        case 21: retval = "e_gnu_attribute__transparent_union__"; break;
        case 22: retval = "e_gnu_attribute__noreturn__"; break;
        case 23: retval = "e_gnu_attribute__const__"; break;
        case 24: retval = "e_gnu_attribute__cdecl__"; break;
        case 25: retval = "e_gnu_attribute__stdcall__"; break;
        case 26: retval = "e_gnu_attribute__warn_unused_result__"; break;
        case 27: retval = "e_gnu_attribute__nonnull__"; break;
        case 28: retval = "e_gnu_attribute__sentinel__"; break;
        case 29: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[98];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgTypeModifier::type_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgTypeModifier::type_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgUPC_AccessModifier::upc_access_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:10471
/** Converts an enum of type SgUPC_AccessModifier::upc_access_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgUPC_AccessModifier_upc_access_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_upc_strict"; break;
        case 3: retval = "e_upc_relaxed"; break;
        case 4: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[110];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgUPC_AccessModifier::upc_access_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgUPC_AccessModifier::upc_access_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgUnaryOp::Sgop_mode is defined at frontend/SageIII/Cxx_Grammar.h:131230
/** Converts an enum of type SgUnaryOp::Sgop_mode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgUnaryOpSgop_mode(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "prefix"; break;
        case 1: retval = "postfix"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgUnaryOp::Sgop_mode)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgUnaryOp::Sgop_mode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgUnparse_Info::access_attr_enum is defined at frontend/SageIII/Cxx_Grammar.h:22833
/** Converts an enum of type SgUnparse_Info::access_attr_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgUnparse_Info_access_attr_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "a_unset_access"; break;
        case 2: retval = "a_private_access"; break;
        case 3: retval = "a_protected_access"; break;
        case 4: retval = "a_public_access"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgUnparse_Info::access_attr_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgUnparse_Info::access_attr_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgUnparse_Info::unparse_type_num is defined at frontend/SageIII/Cxx_Grammar.h:22693
/** Converts an enum of type SgUnparse_Info::unparse_type_num to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgUnparse_Info_unparse_type_num(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "b_enum_defaultValue"; break;
        case 1: retval = "b_isPointerToSomething"; break;
        case 2: retval = "b_isReferenceToSomething"; break;
        case 3: retval = "b_inVarDecl"; break;
        case 4: retval = "b_inArgList"; break;
        case 5: retval = "b_SkipSemiColon"; break;
        case 6: retval = "b_inEnumDecl"; break;
        case 7: retval = "b_inTemplateList"; break;
        case 8: retval = "b_SkipBaseType"; break;
        case 9: retval = "b_inAggregateInitializer"; break;
        case 10: retval = "b_isWithType"; break;
        case 11: retval = "b_inConditional"; break;
        case 12: retval = "b_SkipDefinition"; break;
        case 13: retval = "b_SkipClassSpecifier"; break;
        case 14: retval = "b_inEmbeddedDecl"; break;
        case 15: retval = "b_SkipGlobal"; break;
        case 16: retval = "b_SkipAtomic"; break;
        case 17: retval = "b_PrintName"; break;
        case 18: retval = "b_CheckAccess"; break;
        case 19: retval = "b_SkipFunctionQualifier"; break;
        case 20: retval = "b_isArrayType"; break;
        case 21: retval = "b_inRhsExpr"; break;
        case 22: retval = "b_SkipParen"; break;
        case 23: retval = "b_isTypeSecondPart"; break;
        case 24: retval = "b_isTypeFirstPart"; break;
        case 25: retval = "b_SkipInitializer"; break;
        case 26: retval = "b_SkipComments"; break;
        case 27: retval = "b_SkipCPPDirectives"; break;
        case 28: retval = "b_SkipEnumDefinition"; break;
        case 29: retval = "b_SkipFunctionDefinition"; break;
        case 30: retval = "b_SkipClassDefinition"; break;
        case 31: retval = "b_AddSemiColonAfterDeclaration"; break;
        case 32: retval = "b_SkipWhitespaces"; break;
        case 33: retval = "b_SkipBasicBlock"; break;
        case 34: retval = "b_outputClassTemplateName"; break;
        case 35: retval = "b_outputCompilerGeneratedStatements"; break;
        case 36: retval = "b_SkipConstantFoldedExpressions"; break;
        case 37: retval = "b_forceQualifiedNames"; break;
        case 38: retval = "b_SkipQualifiedNames"; break;
        case 39: retval = "b_skipCheckAccess"; break;
        case 40: retval = "b_requiresGlobalNameQualification"; break;
        case 41: retval = "b_useTypeAttributes"; break;
        case 42: retval = "b_SkipFormatting"; break;
        case 43: retval = "b_outputFortranModFile"; break;
        case 44: retval = "b_supressStrippedTypeName"; break;
        case 45: retval = "UNPARSE_TYPE_LAST"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgUnparse_Info::unparse_type_num)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgUnparse_Info::unparse_type_num::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SgVariableDeclaration::gnu_extension_declaration_attributes_enum is defined at frontend/SageIII/Cxx_Grammar.h:80470
/** Converts an enum of type SgVariableDeclaration::gnu_extension_declaration_attributes_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgVariableDeclaration_gnu_extension_declaration_attributes_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_gnu_attribute_unknown"; break;
        case 1: retval = "e_gnu_attribute_unspecified"; break;
        case 2: retval = "e_gnu_attribute__weak__"; break;
        case 3: retval = "e_gnu_attribute__unused__"; break;
        case 4: retval = "e_gnu_attribute__deprecated__"; break;
        case 5: retval = "e_gnu_attribute__nocommon__"; break;
        case 6: retval = "e_gnu_attribute__transparent_union__"; break;
        case 7: retval = "e_last_gnu_declaration_attribute"; break;
    }
    if (retval.empty()) {
        char buf[128];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SgVariableDeclaration::gnu_extension_declaration_attributes_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgVariableDeclaration::gnu_extension_declaration_attributes_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// Sg_File_Info::classifier is defined at frontend/SageIII/Cxx_Grammar.h:17900
/** Converts an enum of type Sg_File_Info::classifier to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySg_File_Info_classifier(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "e_transformation"; break;
        case 2: retval = "e_compiler_generated"; break;
        case 4: retval = "e_output_in_code_generation"; break;
        case 8: retval = "e_shared"; break;
        case 16: retval = "e_frontend_specific"; break;
        case 32: retval = "e_source_position_unavailable_in_frontend"; break;
        case 64: retval = "e_comment_or_directive"; break;
        case 128: retval = "e_token"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(Sg_File_Info::classifier)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sg_File_Info::classifier::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// Sg_File_Info::p_fileflags is defined at frontend/SageIII/Cxx_Grammar.h:18120
/** Converts an enum of type Sg_File_Info::p_fileflags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySg_File_Info_p_fileflags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case -6: retval = "BAD_FILE_ID"; break;
        case -5: retval = "COMPILER_GENERATED_MARKED_FOR_OUTPUT_FILE_ID"; break;
        case -4: retval = "COMPILER_GENERATED_FILE_ID"; break;
        case -3: retval = "TRANSFORMATION_FILE_ID"; break;
        case -2: retval = "NULL_FILE_ID"; break;
        case -1: retval = "COPY_FILE_ID"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(Sg_File_Info::p_fileflags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sg_File_Info::p_fileflags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SimpleDirectedGraph::TraverseDirection is defined at src/midend/programAnalysis/staticInterproceduralSlicing/SimpleDirectedGraph.h:200
/** Converts an enum of type SimpleDirectedGraph::TraverseDirection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySimpleDirectedGraphTraverseDirection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "FORWARD"; break;
        case 2: retval = "BACKWARD"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SimpleDirectedGraph::TraverseDirection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SimpleDirectedGraph::TraverseDirection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// StringUtility::FileNameLocation is defined at src/util/stringSupport/string_functions.h:260
/** Converts an enum of type StringUtility::FileNameLocation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyStringUtilityFileNameLocation(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FILENAME_LOCATION_UNKNOWN"; break;
        case 1: retval = "FILENAME_LOCATION_USER"; break;
        case 2: retval = "FILENAME_LOCATION_LIBRARY"; break;
        case 3: retval = "FILENAME_LOCATION_NOT_EXIST"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(StringUtility::FileNameLocation)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "StringUtility::FileNameLocation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// StringUtility::OSType is defined at src/util/stringSupport/string_functions.h:242
/** Converts an enum of type StringUtility::OSType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyStringUtilityOSType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "OS_TYPE_UNKNOWN"; break;
        case 1: retval = "OS_TYPE_LINUX"; break;
        case 2: retval = "OS_TYPE_OSX"; break;
        case 3: retval = "OS_TYPE_WINDOWS"; break;
        case 4: retval = "OS_TPYE_WINDOWSXP"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(StringUtility::OSType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "StringUtility::OSType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// SymbolicSemantics::Policy::MemRefType is defined at src/midend/binaryAnalyses/instructionSemantics/SymbolicSemantics.h:413
/** Converts an enum of type SymbolicSemantics::Policy::MemRefType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySymbolicSemanticsPolicyMemRefType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "MRT_STACK_PTR"; break;
        case 1: retval = "MRT_FRAME_PTR"; break;
        case 2: retval = "MRT_OTHER_PTR"; break;
    }
    if (retval.empty()) {
        char buf[101];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(SymbolicSemantics::Policy::MemRefType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SymbolicSemantics::Policy::MemRefType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// Task::State is defined at src/roseExtensions/qtWidgets/TaskSystem/TaskInterface.h:26
/** Converts an enum of type Task::State to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyTaskState(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "BEFORE_START"; break;
        case 1: retval = "RUNNING"; break;
        case 2: retval = "FINISHED_SUCCESS"; break;
        case 3: retval = "FINISHED_ERROR"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(Task::State)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Task::State::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// Terminal::TypeEvaluation is defined at src/ROSETTA/src/terminal.h:326
/** Converts an enum of type Terminal::TypeEvaluation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyTerminalTypeEvaluation(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "CHAR_POINTER"; break;
        case 1: retval = "CONST_CHAR_POINTER"; break;
        case 2: retval = "ATTACHEDPREPROCESSINGINFOTYPE"; break;
        case 3: retval = "ROSE_HASH_MULTIMAP"; break;
        case 4: retval = "ROSE_GRAPH_HASH_MULTIMAP"; break;
        case 5: retval = "ROSE_GRAPH_DIRECTED_EDGE_HASH_MULTIMAP"; break;
        case 6: retval = "ROSE_GRAPH_UNDIRECTED_EDGE_HASH_MULTIMAP"; break;
        case 7: retval = "ROSE_GRAPH_NODE_EDGE_HASH_MULTIMAP"; break;
        case 8: retval = "ROSE_GRAPH_INTEGER_NODE_HASH_MAP"; break;
        case 9: retval = "ROSE_GRAPH_INTEGER_EDGE_HASH_MAP"; break;
        case 10: retval = "ROSE_GRAPH_STRING_INTEGER_HASH_MULTIMAP"; break;
        case 11: retval = "ROSE_GRAPH_INTEGER_PAIR_EDGE_HASH_MULTIMAP"; break;
        case 12: retval = "ROSE_GRAPH_INTEGER_EDGE_HASH_MULTIMAP"; break;
        case 13: retval = "SGCLASS_POINTER"; break;
        case 14: retval = "ROSEATTRUBUTESLISTCONTAINER"; break;
        case 15: retval = "SGCLASS_POINTER_LIST"; break;
        case 16: retval = "SGCLASS_POINTER_VECTOR"; break;
        case 17: retval = "SGCLASS_POINTER_VECTOR_NAMED_LIST"; break;
        case 18: retval = "STL_CONTAINER"; break;
        case 19: retval = "STL_SET"; break;
        case 20: retval = "STL_MULTIMAP"; break;
        case 21: retval = "STL_MAP"; break;
        case 22: retval = "STRING"; break;
        case 23: retval = "SGNAME"; break;
        case 24: retval = "BIT_VECTOR"; break;
        case 25: retval = "MODIFIERCLASS"; break;
        case 26: retval = "MODIFIERCLASS_WITHOUTEASYSTORAGE"; break;
        case 27: retval = "ASTATTRIBUTEMECHANISM"; break;
        case 28: retval = "TO_HANDLE"; break;
        case 29: retval = "OSTREAM"; break;
        case 30: retval = "ENUM_TYPE"; break;
        case 31: retval = "BASIC_DATA_TYPE"; break;
        case 32: retval = "SKIP_TYPE"; break;
        case 33: retval = "SGCLASS_POINTER_LIST_POINTER"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(Terminal::TypeEvaluation)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Terminal::TypeEvaluation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// Terminal::includeExcludeMechanism is defined at src/ROSETTA/src/terminal.h:121
/** Converts an enum of type Terminal::includeExcludeMechanism to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyTerminal_includeExcludeMechanism(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "INCLUDE_LIST"; break;
        case 1: retval = "EXCLUDE_LIST"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(Terminal::includeExcludeMechanism)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Terminal::includeExcludeMechanism::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// Terminal::locationInTree is defined at src/ROSETTA/src/terminal.h:115
/** Converts an enum of type Terminal::locationInTree to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyTerminal_locationInTree(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "LOCAL_LIST"; break;
        case 1: retval = "SUBTREE_LIST"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(Terminal::locationInTree)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Terminal::locationInTree::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// TransformationSupport::operatorCodeType is defined at src/roseSupport/transformationSupport.h:38
/** Converts an enum of type TransformationSupport::operatorCodeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyTransformationSupport_operatorCodeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FUNCTION_CALL_OPERATOR_CODE"; break;
        case 1: retval = "ADD_OPERATOR_CODE"; break;
        case 2: retval = "SUBT_OPERATOR_CODE"; break;
        case 3: retval = "MULT_OPERATOR_CODE"; break;
        case 4: retval = "DIV_OPERATOR_CODE"; break;
        case 5: retval = "INTEGER_DIV_OPERATOR_CODE"; break;
        case 6: retval = "MOD_OPERATOR_CODE"; break;
        case 7: retval = "AND_OPERATOR_CODE"; break;
        case 8: retval = "OR_OPERATOR_CODE"; break;
        case 9: retval = "BITXOR_OPERATOR_CODE"; break;
        case 10: retval = "BITAND_OPERATOR_CODE"; break;
        case 11: retval = "BITOR_OPERATOR_CODE"; break;
        case 12: retval = "EQ_OPERATOR_CODE"; break;
        case 13: retval = "LT_OPERATOR_CODE"; break;
        case 14: retval = "GT_OPERATOR_CODE"; break;
        case 15: retval = "NE_OPERATOR_CODE"; break;
        case 16: retval = "LE_OPERATOR_CODE"; break;
        case 17: retval = "GE_OPERATOR_CODE"; break;
        case 18: retval = "ASSIGN_OPERATOR_CODE"; break;
        case 19: retval = "PLUS_ASSIGN_OPERATOR_CODE"; break;
        case 20: retval = "MINUS_ASSIGN_OPERATOR_CODE"; break;
        case 21: retval = "AND_ASSIGN_OPERATOR_CODE"; break;
        case 22: retval = "IOR_ASSIGN_OPERATOR_CODE"; break;
        case 23: retval = "MULT_ASSIGN_OPERATOR_CODE"; break;
        case 24: retval = "DIV_ASSIGN_OPERATOR_CODE"; break;
        case 25: retval = "MOD_ASSIGN_OPERATOR_CODE"; break;
        case 26: retval = "XOR_ASSIGN_OPERATOR_CODE"; break;
        case 27: retval = "PARENTHESIS_OPERATOR_CODE"; break;
        case 28: retval = "BRACKET_OPERATOR_CODE"; break;
        case 29: retval = "NOT_OPERATOR_CODE"; break;
        case 30: retval = "DEREFERENCE_OPERATOR_CODE"; break;
        case 31: retval = "ADDRESS_OPERATOR_CODE"; break;
        case 32: retval = "LSHIFT_OPERATOR_CODE"; break;
        case 33: retval = "RSHIFT_OPERATOR_CODE"; break;
        case 34: retval = "LSHIFT_ASSIGN_OPERATOR_CODE"; break;
        case 35: retval = "RSHIFT_ASSIGN_OPERATOR_CODE"; break;
        case 36: retval = "PREFIX_PLUSPLUS_OPERATOR_CODE"; break;
        case 37: retval = "POSTFIX_PLUSPLUS_OPERATOR_CODE"; break;
        case 38: retval = "PREFIX_MINUSMINUS_OPERATOR_CODE"; break;
        case 39: retval = "POSTFIX_MINUSMINUS_OPERATOR_CODE"; break;
        case 99: retval = "OPERATOR_CODE_LAST_TAG"; break;
    }
    if (retval.empty()) {
        char buf[103];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(TransformationSupport::operatorCodeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "TransformationSupport::operatorCodeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// VariantT is defined at frontend/SageIII/Cxx_Grammar.h:678
/** Converts an enum of type VariantT to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyVariantT(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "V_SgAccessModifier"; break;
        case 2: retval = "V_SgActualArgumentExpression"; break;
        case 3: retval = "V_SgAddOp"; break;
        case 4: retval = "V_SgAddressOfOp"; break;
        case 5: retval = "V_SgAggregateInitializer"; break;
        case 6: retval = "V_SgAliasSymbol"; break;
        case 7: retval = "V_SgAllocateStatement"; break;
        case 8: retval = "V_SgAndAssignOp"; break;
        case 9: retval = "V_SgAndOp"; break;
        case 10: retval = "V_SgArithmeticIfStatement"; break;
        case 11: retval = "V_SgArrayType"; break;
        case 12: retval = "V_SgArrowExp"; break;
        case 13: retval = "V_SgArrowStarOp"; break;
        case 14: retval = "V_SgAsmArmInstruction"; break;
        case 15: retval = "V_SgAsmArmRegisterReferenceExpression"; break;
        case 16: retval = "V_SgAsmBasicString"; break;
        case 17: retval = "V_SgAsmBinaryAdd"; break;
        case 18: retval = "V_SgAsmBinaryAddPostupdate"; break;
        case 19: retval = "V_SgAsmBinaryAddPreupdate"; break;
        case 20: retval = "V_SgAsmBinaryAsr"; break;
        case 21: retval = "V_SgAsmBinaryDivide"; break;
        case 22: retval = "V_SgAsmBinaryExpression"; break;
        case 23: retval = "V_SgAsmBinaryLsl"; break;
        case 24: retval = "V_SgAsmBinaryLsr"; break;
        case 25: retval = "V_SgAsmBinaryMod"; break;
        case 26: retval = "V_SgAsmBinaryMultiply"; break;
        case 27: retval = "V_SgAsmBinaryRor"; break;
        case 28: retval = "V_SgAsmBinarySubtract"; break;
        case 29: retval = "V_SgAsmBinarySubtractPostupdate"; break;
        case 30: retval = "V_SgAsmBinarySubtractPreupdate"; break;
        case 31: retval = "V_SgAsmBlock"; break;
        case 32: retval = "V_SgAsmByteValueExpression"; break;
        case 33: retval = "V_SgAsmCoffStrtab"; break;
        case 34: retval = "V_SgAsmCoffSymbol"; break;
        case 35: retval = "V_SgAsmCoffSymbolList"; break;
        case 36: retval = "V_SgAsmCoffSymbolTable"; break;
        case 37: retval = "V_SgAsmCommonSubExpression"; break;
        case 38: retval = "V_SgAsmControlFlagsExpression"; break;
        case 39: retval = "V_SgAsmDOSExtendedHeader"; break;
        case 40: retval = "V_SgAsmDOSFileHeader"; break;
        case 41: retval = "V_SgAsmDataStructureDeclaration"; break;
        case 42: retval = "V_SgAsmDeclaration"; break;
        case 43: retval = "V_SgAsmDoubleFloatValueExpression"; break;
        case 44: retval = "V_SgAsmDoubleWordValueExpression"; break;
        case 45: retval = "V_SgAsmDwarfAccessDeclaration"; break;
        case 46: retval = "V_SgAsmDwarfArrayType"; break;
        case 47: retval = "V_SgAsmDwarfBaseType"; break;
        case 48: retval = "V_SgAsmDwarfCatchBlock"; break;
        case 49: retval = "V_SgAsmDwarfClassTemplate"; break;
        case 50: retval = "V_SgAsmDwarfClassType"; break;
        case 51: retval = "V_SgAsmDwarfCommonBlock"; break;
        case 52: retval = "V_SgAsmDwarfCommonInclusion"; break;
        case 53: retval = "V_SgAsmDwarfCompilationUnit"; break;
        case 54: retval = "V_SgAsmDwarfCompilationUnitList"; break;
        case 55: retval = "V_SgAsmDwarfCondition"; break;
        case 56: retval = "V_SgAsmDwarfConstType"; break;
        case 57: retval = "V_SgAsmDwarfConstant"; break;
        case 58: retval = "V_SgAsmDwarfConstruct"; break;
        case 59: retval = "V_SgAsmDwarfConstructList"; break;
        case 60: retval = "V_SgAsmDwarfDwarfProcedure"; break;
        case 61: retval = "V_SgAsmDwarfEntryPoint"; break;
        case 62: retval = "V_SgAsmDwarfEnumerationType"; break;
        case 63: retval = "V_SgAsmDwarfEnumerator"; break;
        case 64: retval = "V_SgAsmDwarfFileType"; break;
        case 65: retval = "V_SgAsmDwarfFormalParameter"; break;
        case 66: retval = "V_SgAsmDwarfFormatLabel"; break;
        case 67: retval = "V_SgAsmDwarfFriend"; break;
        case 68: retval = "V_SgAsmDwarfFunctionTemplate"; break;
        case 69: retval = "V_SgAsmDwarfImportedDeclaration"; break;
        case 70: retval = "V_SgAsmDwarfImportedModule"; break;
        case 71: retval = "V_SgAsmDwarfImportedUnit"; break;
        case 72: retval = "V_SgAsmDwarfInformation"; break;
        case 73: retval = "V_SgAsmDwarfInheritance"; break;
        case 74: retval = "V_SgAsmDwarfInlinedSubroutine"; break;
        case 75: retval = "V_SgAsmDwarfInterfaceType"; break;
        case 76: retval = "V_SgAsmDwarfLabel"; break;
        case 77: retval = "V_SgAsmDwarfLexicalBlock"; break;
        case 78: retval = "V_SgAsmDwarfLine"; break;
        case 79: retval = "V_SgAsmDwarfLineList"; break;
        case 80: retval = "V_SgAsmDwarfMacro"; break;
        case 81: retval = "V_SgAsmDwarfMacroList"; break;
        case 82: retval = "V_SgAsmDwarfMember"; break;
        case 83: retval = "V_SgAsmDwarfModule"; break;
        case 84: retval = "V_SgAsmDwarfMutableType"; break;
        case 85: retval = "V_SgAsmDwarfNamelist"; break;
        case 86: retval = "V_SgAsmDwarfNamelistItem"; break;
        case 87: retval = "V_SgAsmDwarfNamespace"; break;
        case 88: retval = "V_SgAsmDwarfPackedType"; break;
        case 89: retval = "V_SgAsmDwarfPartialUnit"; break;
        case 90: retval = "V_SgAsmDwarfPointerType"; break;
        case 91: retval = "V_SgAsmDwarfPtrToMemberType"; break;
        case 92: retval = "V_SgAsmDwarfReferenceType"; break;
        case 93: retval = "V_SgAsmDwarfRestrictType"; break;
        case 94: retval = "V_SgAsmDwarfSetType"; break;
        case 95: retval = "V_SgAsmDwarfSharedType"; break;
        case 96: retval = "V_SgAsmDwarfStringType"; break;
        case 97: retval = "V_SgAsmDwarfStructureType"; break;
        case 98: retval = "V_SgAsmDwarfSubprogram"; break;
        case 99: retval = "V_SgAsmDwarfSubrangeType"; break;
        case 100: retval = "V_SgAsmDwarfSubroutineType"; break;
        case 101: retval = "V_SgAsmDwarfTemplateTypeParameter"; break;
        case 102: retval = "V_SgAsmDwarfTemplateValueParameter"; break;
        case 103: retval = "V_SgAsmDwarfThrownType"; break;
        case 104: retval = "V_SgAsmDwarfTryBlock"; break;
        case 105: retval = "V_SgAsmDwarfTypedef"; break;
        case 106: retval = "V_SgAsmDwarfUnionType"; break;
        case 107: retval = "V_SgAsmDwarfUnknownConstruct"; break;
        case 108: retval = "V_SgAsmDwarfUnspecifiedParameters"; break;
        case 109: retval = "V_SgAsmDwarfUnspecifiedType"; break;
        case 110: retval = "V_SgAsmDwarfUpcRelaxedType"; break;
        case 111: retval = "V_SgAsmDwarfUpcSharedType"; break;
        case 112: retval = "V_SgAsmDwarfUpcStrictType"; break;
        case 113: retval = "V_SgAsmDwarfVariable"; break;
        case 114: retval = "V_SgAsmDwarfVariant"; break;
        case 115: retval = "V_SgAsmDwarfVariantPart"; break;
        case 116: retval = "V_SgAsmDwarfVolatileType"; break;
        case 117: retval = "V_SgAsmDwarfWithStmt"; break;
        case 118: retval = "V_SgAsmElfDynamicEntry"; break;
        case 119: retval = "V_SgAsmElfDynamicEntryList"; break;
        case 120: retval = "V_SgAsmElfDynamicSection"; break;
        case 121: retval = "V_SgAsmElfEHFrameEntryCI"; break;
        case 122: retval = "V_SgAsmElfEHFrameEntryCIList"; break;
        case 123: retval = "V_SgAsmElfEHFrameEntryFD"; break;
        case 124: retval = "V_SgAsmElfEHFrameEntryFDList"; break;
        case 125: retval = "V_SgAsmElfEHFrameSection"; break;
        case 126: retval = "V_SgAsmElfFileHeader"; break;
        case 127: retval = "V_SgAsmElfNoteEntry"; break;
        case 128: retval = "V_SgAsmElfNoteEntryList"; break;
        case 129: retval = "V_SgAsmElfNoteSection"; break;
        case 130: retval = "V_SgAsmElfRelocEntry"; break;
        case 131: retval = "V_SgAsmElfRelocEntryList"; break;
        case 132: retval = "V_SgAsmElfRelocSection"; break;
        case 133: retval = "V_SgAsmElfSection"; break;
        case 134: retval = "V_SgAsmElfSectionTable"; break;
        case 135: retval = "V_SgAsmElfSectionTableEntry"; break;
        case 136: retval = "V_SgAsmElfSegmentTable"; break;
        case 137: retval = "V_SgAsmElfSegmentTableEntry"; break;
        case 138: retval = "V_SgAsmElfSegmentTableEntryList"; break;
        case 139: retval = "V_SgAsmElfStringSection"; break;
        case 140: retval = "V_SgAsmElfStrtab"; break;
        case 141: retval = "V_SgAsmElfSymbol"; break;
        case 142: retval = "V_SgAsmElfSymbolList"; break;
        case 143: retval = "V_SgAsmElfSymbolSection"; break;
        case 144: retval = "V_SgAsmElfSymverDefinedAux"; break;
        case 145: retval = "V_SgAsmElfSymverDefinedAuxList"; break;
        case 146: retval = "V_SgAsmElfSymverDefinedEntry"; break;
        case 147: retval = "V_SgAsmElfSymverDefinedEntryList"; break;
        case 148: retval = "V_SgAsmElfSymverDefinedSection"; break;
        case 149: retval = "V_SgAsmElfSymverEntry"; break;
        case 150: retval = "V_SgAsmElfSymverEntryList"; break;
        case 151: retval = "V_SgAsmElfSymverNeededAux"; break;
        case 152: retval = "V_SgAsmElfSymverNeededAuxList"; break;
        case 153: retval = "V_SgAsmElfSymverNeededEntry"; break;
        case 154: retval = "V_SgAsmElfSymverNeededEntryList"; break;
        case 155: retval = "V_SgAsmElfSymverNeededSection"; break;
        case 156: retval = "V_SgAsmElfSymverSection"; break;
        case 157: retval = "V_SgAsmExecutableFileFormat"; break;
        case 158: retval = "V_SgAsmExprListExp"; break;
        case 159: retval = "V_SgAsmExpression"; break;
        case 160: retval = "V_SgAsmFieldDeclaration"; break;
        case 161: retval = "V_SgAsmFunctionDeclaration"; break;
        case 163: retval = "V_SgAsmGenericDLL"; break;
        case 164: retval = "V_SgAsmGenericDLLList"; break;
        case 165: retval = "V_SgAsmGenericFile"; break;
        case 166: retval = "V_SgAsmGenericFileList"; break;
        case 167: retval = "V_SgAsmGenericFormat"; break;
        case 168: retval = "V_SgAsmGenericHeader"; break;
        case 169: retval = "V_SgAsmGenericHeaderList"; break;
        case 170: retval = "V_SgAsmGenericSection"; break;
        case 171: retval = "V_SgAsmGenericSectionList"; break;
        case 172: retval = "V_SgAsmGenericString"; break;
        case 173: retval = "V_SgAsmGenericStrtab"; break;
        case 174: retval = "V_SgAsmGenericSymbol"; break;
        case 175: retval = "V_SgAsmGenericSymbolList"; break;
        case 176: retval = "V_SgAsmInstruction"; break;
        case 177: retval = "V_SgAsmInterpretation"; break;
        case 178: retval = "V_SgAsmInterpretationList"; break;
        case 179: retval = "V_SgAsmLEEntryPoint"; break;
        case 180: retval = "V_SgAsmLEEntryTable"; break;
        case 181: retval = "V_SgAsmLEFileHeader"; break;
        case 182: retval = "V_SgAsmLENameTable"; break;
        case 183: retval = "V_SgAsmLEPageTable"; break;
        case 184: retval = "V_SgAsmLEPageTableEntry"; break;
        case 185: retval = "V_SgAsmLERelocTable"; break;
        case 186: retval = "V_SgAsmLESection"; break;
        case 187: retval = "V_SgAsmLESectionTable"; break;
        case 188: retval = "V_SgAsmLESectionTableEntry"; break;
        case 189: retval = "V_SgAsmMemoryReferenceExpression"; break;
        case 190: retval = "V_SgAsmNEEntryPoint"; break;
        case 191: retval = "V_SgAsmNEEntryTable"; break;
        case 192: retval = "V_SgAsmNEFileHeader"; break;
        case 193: retval = "V_SgAsmNEModuleTable"; break;
        case 194: retval = "V_SgAsmNENameTable"; break;
        case 196: retval = "V_SgAsmNERelocEntry"; break;
        case 197: retval = "V_SgAsmNERelocTable"; break;
        case 198: retval = "V_SgAsmNESection"; break;
        case 199: retval = "V_SgAsmNESectionTable"; break;
        case 200: retval = "V_SgAsmNESectionTableEntry"; break;
        case 201: retval = "V_SgAsmNEStringTable"; break;
        case 202: retval = "V_SgAsmNode"; break;
        case 203: retval = "V_SgAsmOp"; break;
        case 204: retval = "V_SgAsmOperandList"; break;
        case 205: retval = "V_SgAsmPEExportDirectory"; break;
        case 206: retval = "V_SgAsmPEExportEntry"; break;
        case 207: retval = "V_SgAsmPEExportEntryList"; break;
        case 208: retval = "V_SgAsmPEExportSection"; break;
        case 209: retval = "V_SgAsmPEFileHeader"; break;
        case 210: retval = "V_SgAsmPEImportDirectory"; break;
        case 211: retval = "V_SgAsmPEImportDirectoryList"; break;
        case 212: retval = "V_SgAsmPEImportHNTEntry"; break;
        case 213: retval = "V_SgAsmPEImportHNTEntryList"; break;
        case 214: retval = "V_SgAsmPEImportILTEntry"; break;
        case 215: retval = "V_SgAsmPEImportILTEntryList"; break;
        case 216: retval = "V_SgAsmPEImportLookupTable"; break;
        case 217: retval = "V_SgAsmPEImportSection"; break;
        case 218: retval = "V_SgAsmPERVASizePair"; break;
        case 219: retval = "V_SgAsmPERVASizePairList"; break;
        case 220: retval = "V_SgAsmPESection"; break;
        case 221: retval = "V_SgAsmPESectionTable"; break;
        case 222: retval = "V_SgAsmPESectionTableEntry"; break;
        case 223: retval = "V_SgAsmPEStringSection"; break;
        case 224: retval = "V_SgAsmPowerpcInstruction"; break;
        case 225: retval = "V_SgAsmPowerpcRegisterReferenceExpression"; break;
        case 228: retval = "V_SgAsmQuadWordValueExpression"; break;
        case 229: retval = "V_SgAsmRegisterReferenceExpression"; break;
        case 232: retval = "V_SgAsmSingleFloatValueExpression"; break;
        case 233: retval = "V_SgAsmStatement"; break;
        case 234: retval = "V_SgAsmStmt"; break;
        case 235: retval = "V_SgAsmStoredString"; break;
        case 236: retval = "V_SgAsmStringStorage"; break;
        case 237: retval = "V_SgAsmType"; break;
        case 238: retval = "V_SgAsmType128bitFloat"; break;
        case 239: retval = "V_SgAsmType80bitFloat"; break;
        case 240: retval = "V_SgAsmTypeByte"; break;
        case 241: retval = "V_SgAsmTypeDoubleFloat"; break;
        case 242: retval = "V_SgAsmTypeDoubleQuadWord"; break;
        case 243: retval = "V_SgAsmTypeDoubleWord"; break;
        case 244: retval = "V_SgAsmTypeQuadWord"; break;
        case 245: retval = "V_SgAsmTypeSingleFloat"; break;
        case 246: retval = "V_SgAsmTypeVector"; break;
        case 247: retval = "V_SgAsmTypeWord"; break;
        case 248: retval = "V_SgAsmUnaryArmSpecialRegisterList"; break;
        case 249: retval = "V_SgAsmUnaryExpression"; break;
        case 250: retval = "V_SgAsmUnaryMinus"; break;
        case 251: retval = "V_SgAsmUnaryPlus"; break;
        case 252: retval = "V_SgAsmUnaryRrx"; break;
        case 253: retval = "V_SgAsmValueExpression"; break;
        case 254: retval = "V_SgAsmVectorValueExpression"; break;
        case 255: retval = "V_SgAsmWordValueExpression"; break;
        case 256: retval = "V_SgAsmx86Instruction"; break;
        case 257: retval = "V_SgAsmx86RegisterReferenceExpression"; break;
        case 258: retval = "V_SgAsmBinaryAddressSymbol"; break;
        case 259: retval = "V_SgAsmBinaryDataSymbol"; break;
        case 260: retval = "V_SgAssignInitializer"; break;
        case 261: retval = "V_SgAssignOp"; break;
        case 262: retval = "V_SgAssignStatement"; break;
        case 263: retval = "V_SgAssignedGotoStatement"; break;
        case 264: retval = "V_SgAssociateStatement"; break;
        case 265: retval = "V_SgAsteriskShapeExp"; break;
        case 266: retval = "V_SgAttribute"; break;
        case 267: retval = "V_SgAttributeSpecificationStatement"; break;
        case 268: retval = "V_SgBackspaceStatement"; break;
        case 269: retval = "V_SgBaseClass"; break;
        case 270: retval = "V_SgBaseClassModifier"; break;
        case 271: retval = "V_SgBasicBlock"; break;
        case 272: retval = "V_SgBidirectionalGraph"; break;
        case 273: retval = "V_SgBinaryComposite"; break;
        case 274: retval = "V_SgBinaryOp"; break;
        case 275: retval = "V_SgBitAndOp"; break;
        case 276: retval = "V_SgBitAttribute"; break;
        case 277: retval = "V_SgBitComplementOp"; break;
        case 278: retval = "V_SgBitOrOp"; break;
        case 279: retval = "V_SgBitXorOp"; break;
        case 280: retval = "V_SgBlockDataStatement"; break;
        case 281: retval = "V_SgBoolValExp"; break;
        case 282: retval = "V_SgBreakStmt"; break;
        case 283: retval = "V_SgC_PreprocessorDirectiveStatement"; break;
        case 284: retval = "V_SgCaseOptionStmt"; break;
        case 285: retval = "V_SgCastExp"; break;
        case 286: retval = "V_SgCatchOptionStmt"; break;
        case 287: retval = "V_SgCatchStatementSeq"; break;
        case 288: retval = "V_SgCharVal"; break;
        case 289: retval = "V_SgClassDecl_attr"; break;
        case 290: retval = "V_SgClassDeclaration"; break;
        case 291: retval = "V_SgClassDefinition"; break;
        case 292: retval = "V_SgClassNameRefExp"; break;
        case 293: retval = "V_SgClassSymbol"; break;
        case 294: retval = "V_SgClassType"; break;
        case 295: retval = "V_SgClinkageDeclarationStatement"; break;
        case 296: retval = "V_SgClinkageEndStatement"; break;
        case 297: retval = "V_SgClinkageStartStatement"; break;
        case 298: retval = "V_SgCloseStatement"; break;
        case 299: retval = "V_SgColonShapeExp"; break;
        case 300: retval = "V_SgCommaOpExp"; break;
        case 301: retval = "V_SgCommonBlock"; break;
        case 302: retval = "V_SgCommonBlockObject"; break;
        case 303: retval = "V_SgCommonSymbol"; break;
        case 304: retval = "V_SgComplexVal"; break;
        case 305: retval = "V_SgComputedGotoStatement"; break;
        case 306: retval = "V_SgConcatenationOp"; break;
        case 307: retval = "V_SgConditionalExp"; break;
        case 308: retval = "V_SgConjugateOp"; break;
        case 309: retval = "V_SgConstVolatileModifier"; break;
        case 310: retval = "V_SgConstructorInitializer"; break;
        case 311: retval = "V_SgContainsStatement"; break;
        case 312: retval = "V_SgContinueStmt"; break;
        case 313: retval = "V_SgCtorInitializerList"; break;
        case 314: retval = "V_SgDataStatementGroup"; break;
        case 315: retval = "V_SgDataStatementObject"; break;
        case 316: retval = "V_SgDataStatementValue"; break;
        case 317: retval = "V_SgDeadIfDirectiveStatement"; break;
        case 318: retval = "V_SgDeallocateStatement"; break;
        case 319: retval = "V_SgDeclarationModifier"; break;
        case 320: retval = "V_SgDeclarationStatement"; break;
        case 321: retval = "V_SgDefaultOptionStmt"; break;
        case 322: retval = "V_SgDefaultSymbol"; break;
        case 323: retval = "V_SgDefineDirectiveStatement"; break;
        case 324: retval = "V_SgDeleteExp"; break;
        case 325: retval = "V_SgDerivedTypeStatement"; break;
        case 326: retval = "V_SgDesignatedInitializer"; break;
        case 327: retval = "V_SgDimensionObject"; break;
        case 329: retval = "V_SgDirectedGraphEdge"; break;
        case 331: retval = "V_SgDirectory"; break;
        case 332: retval = "V_SgDirectoryList"; break;
        case 333: retval = "V_SgDivAssignOp"; break;
        case 334: retval = "V_SgDivideOp"; break;
        case 335: retval = "V_SgDoWhileStmt"; break;
        case 336: retval = "V_SgDotExp"; break;
        case 337: retval = "V_SgDotStarOp"; break;
        case 338: retval = "V_SgDoubleVal"; break;
        case 339: retval = "V_SgElaboratedTypeModifier"; break;
        case 340: retval = "V_SgElseDirectiveStatement"; break;
        case 341: retval = "V_SgElseWhereStatement"; break;
        case 342: retval = "V_SgElseifDirectiveStatement"; break;
        case 343: retval = "V_SgEmptyDirectiveStatement"; break;
        case 344: retval = "V_SgEndfileStatement"; break;
        case 345: retval = "V_SgEndifDirectiveStatement"; break;
        case 346: retval = "V_SgEntryStatement"; break;
        case 347: retval = "V_SgEnumDeclaration"; break;
        case 348: retval = "V_SgEnumFieldSymbol"; break;
        case 349: retval = "V_SgEnumSymbol"; break;
        case 350: retval = "V_SgEnumType"; break;
        case 351: retval = "V_SgEnumVal"; break;
        case 352: retval = "V_SgEqualityOp"; break;
        case 353: retval = "V_SgEquivalenceStatement"; break;
        case 354: retval = "V_SgErrorDirectiveStatement"; break;
        case 355: retval = "V_SgExponentiationOp"; break;
        case 356: retval = "V_SgExprListExp"; break;
        case 357: retval = "V_SgExprStatement"; break;
        case 358: retval = "V_SgExpression"; break;
        case 359: retval = "V_SgExpressionRoot"; break;
        case 360: retval = "V_SgFile"; break;
        case 361: retval = "V_SgFileList"; break;
        case 362: retval = "V_SgFloatVal"; break;
        case 363: retval = "V_SgFlushStatement"; break;
        case 364: retval = "V_SgForAllStatement"; break;
        case 365: retval = "V_SgForInitStatement"; break;
        case 366: retval = "V_SgForStatement"; break;
        case 367: retval = "V_SgFormatItem"; break;
        case 368: retval = "V_SgFormatItemList"; break;
        case 369: retval = "V_SgFormatStatement"; break;
        case 370: retval = "V_SgFortranDo"; break;
        case 371: retval = "V_SgFortranIncludeLine"; break;
        case 372: retval = "V_SgFortranNonblockedDo"; break;
        case 373: retval = "V_SgFuncDecl_attr"; break;
        case 374: retval = "V_SgFunctionCallExp"; break;
        case 375: retval = "V_SgFunctionDeclaration"; break;
        case 376: retval = "V_SgFunctionDefinition"; break;
        case 377: retval = "V_SgFunctionModifier"; break;
        case 378: retval = "V_SgFunctionParameterList"; break;
        case 379: retval = "V_SgFunctionParameterTypeList"; break;
        case 380: retval = "V_SgFunctionRefExp"; break;
        case 381: retval = "V_SgFunctionSymbol"; break;
        case 382: retval = "V_SgFunctionType"; break;
        case 383: retval = "V_SgFunctionTypeSymbol"; break;
        case 384: retval = "V_SgFunctionTypeTable"; break;
        case 385: retval = "V_SgTypeTable"; break;
        case 386: retval = "V_SgGlobal"; break;
        case 387: retval = "V_SgGotoStatement"; break;
        case 388: retval = "V_SgGraph"; break;
        case 389: retval = "V_SgGraphEdge"; break;
        case 390: retval = "V_SgGraphEdgeList"; break;
        case 391: retval = "V_SgGraphNode"; break;
        case 392: retval = "V_SgGraphNodeList"; break;
        case 393: retval = "V_SgGreaterOrEqualOp"; break;
        case 394: retval = "V_SgGreaterThanOp"; break;
        case 395: retval = "V_SgIOItemExpression"; break;
        case 396: retval = "V_SgIOStatement"; break;
        case 397: retval = "V_SgIdentDirectiveStatement"; break;
        case 398: retval = "V_SgIfDirectiveStatement"; break;
        case 399: retval = "V_SgIfStmt"; break;
        case 400: retval = "V_SgIfdefDirectiveStatement"; break;
        case 401: retval = "V_SgIfndefDirectiveStatement"; break;
        case 402: retval = "V_SgImagPartOp"; break;
        case 403: retval = "V_SgImplicitStatement"; break;
        case 404: retval = "V_SgImpliedDo"; break;
        case 405: retval = "V_SgImportStatement"; break;
        case 406: retval = "V_SgIncidenceDirectedGraph"; break;
        case 407: retval = "V_SgIncidenceUndirectedGraph"; break;
        case 408: retval = "V_SgIncludeDirectiveStatement"; break;
        case 409: retval = "V_SgIncludeNextDirectiveStatement"; break;
        case 410: retval = "V_SgInitializedName"; break;
        case 411: retval = "V_SgInitializer"; break;
        case 412: retval = "V_SgInquireStatement"; break;
        case 413: retval = "V_SgIntKeyedBidirectionalGraph"; break;
        case 414: retval = "V_SgIntVal"; break;
        case 415: retval = "V_SgIntegerDivideOp"; break;
        case 416: retval = "V_SgInterfaceBody"; break;
        case 417: retval = "V_SgInterfaceStatement"; break;
        case 418: retval = "V_SgInterfaceSymbol"; break;
        case 419: retval = "V_SgIntrinsicSymbol"; break;
        case 420: retval = "V_SgIorAssignOp"; break;
        case 421: retval = "V_SgCudaKernelExecConfig"; break;
        case 422: retval = "V_SgCudaKernelCallExp"; break;
        case 423: retval = "V_SgLabelRefExp"; break;
        case 424: retval = "V_SgLabelStatement"; break;
        case 425: retval = "V_SgLabelSymbol"; break;
        case 426: retval = "V_SgLessOrEqualOp"; break;
        case 427: retval = "V_SgLessThanOp"; break;
        case 428: retval = "V_SgLineDirectiveStatement"; break;
        case 429: retval = "V_SgLinemarkerDirectiveStatement"; break;
        case 430: retval = "V_SgLinkageModifier"; break;
        case 431: retval = "V_SgLocatedNode"; break;
        case 432: retval = "V_SgLocatedNodeSupport"; break;
        case 433: retval = "V_SgLongDoubleVal"; break;
        case 434: retval = "V_SgLongIntVal"; break;
        case 435: retval = "V_SgLongLongIntVal"; break;
        case 436: retval = "V_SgLshiftAssignOp"; break;
        case 437: retval = "V_SgLshiftOp"; break;
        case 438: retval = "V_SgMemberFunctionDeclaration"; break;
        case 439: retval = "V_SgMemberFunctionRefExp"; break;
        case 440: retval = "V_SgMemberFunctionSymbol"; break;
        case 441: retval = "V_SgMemberFunctionType"; break;
        case 442: retval = "V_SgMinusAssignOp"; break;
        case 443: retval = "V_SgMinusMinusOp"; break;
        case 444: retval = "V_SgMinusOp"; break;
        case 445: retval = "V_SgModAssignOp"; break;
        case 446: retval = "V_SgModOp"; break;
        case 447: retval = "V_SgModifier"; break;
        case 448: retval = "V_SgModifierNodes"; break;
        case 449: retval = "V_SgModifierType"; break;
        case 450: retval = "V_SgModuleStatement"; break;
        case 451: retval = "V_SgModuleSymbol"; break;
        case 452: retval = "V_SgMultAssignOp"; break;
        case 453: retval = "V_SgMultiplyOp"; break;
        case 454: retval = "V_SgName"; break;
        case 455: retval = "V_SgNameGroup"; break;
        case 456: retval = "V_SgNamedType"; break;
        case 457: retval = "V_SgNamelistStatement"; break;
        case 458: retval = "V_SgNamespaceAliasDeclarationStatement"; break;
        case 459: retval = "V_SgNamespaceDeclarationStatement"; break;
        case 460: retval = "V_SgNamespaceDefinitionStatement"; break;
        case 461: retval = "V_SgNamespaceSymbol"; break;
        case 462: retval = "V_SgNewExp"; break;
        case 463: retval = "V_SgNode"; break;
        case 464: retval = "V_SgNotEqualOp"; break;
        case 465: retval = "V_SgNotOp"; break;
        case 466: retval = "V_SgNullExpression"; break;
        case 467: retval = "V_SgNullStatement"; break;
        case 468: retval = "V_SgNullifyStatement"; break;
        case 469: retval = "V_SgOmpAtomicStatement"; break;
        case 470: retval = "V_SgOmpBarrierStatement"; break;
        case 471: retval = "V_SgOmpCriticalStatement"; break;
        case 472: retval = "V_SgOmpClauseBodyStatement"; break;
        case 473: retval = "V_SgOmpBodyStatement"; break;
        case 474: retval = "V_SgOmpDoStatement"; break;
        case 475: retval = "V_SgOmpFlushStatement"; break;
        case 476: retval = "V_SgOmpForStatement"; break;
        case 477: retval = "V_SgOmpMasterStatement"; break;
        case 478: retval = "V_SgOmpOrderedStatement"; break;
        case 479: retval = "V_SgOmpParallelStatement"; break;
        case 480: retval = "V_SgOmpSectionStatement"; break;
        case 481: retval = "V_SgOmpSectionsStatement"; break;
        case 482: retval = "V_SgOmpSingleStatement"; break;
        case 483: retval = "V_SgOmpTaskStatement"; break;
        case 484: retval = "V_SgOmpTaskwaitStatement"; break;
        case 485: retval = "V_SgOmpThreadprivateStatement"; break;
        case 486: retval = "V_SgOmpWorkshareStatement"; break;
        case 487: retval = "V_SgOmpClause"; break;
        case 488: retval = "V_SgOmpCollapseClause"; break;
        case 489: retval = "V_SgOmpCopyinClause"; break;
        case 490: retval = "V_SgOmpCopyprivateClause"; break;
        case 491: retval = "V_SgOmpDefaultClause"; break;
        case 492: retval = "V_SgOmpExpressionClause"; break;
        case 493: retval = "V_SgOmpFirstprivateClause"; break;
        case 494: retval = "V_SgOmpIfClause"; break;
        case 495: retval = "V_SgOmpLastprivateClause"; break;
        case 496: retval = "V_SgOmpNowaitClause"; break;
        case 497: retval = "V_SgOmpNumThreadsClause"; break;
        case 498: retval = "V_SgOmpOrderedClause"; break;
        case 499: retval = "V_SgOmpPrivateClause"; break;
        case 500: retval = "V_SgOmpReductionClause"; break;
        case 501: retval = "V_SgOmpScheduleClause"; break;
        case 502: retval = "V_SgOmpSharedClause"; break;
        case 503: retval = "V_SgOmpUntiedClause"; break;
        case 504: retval = "V_SgOmpVariablesClause"; break;
        case 505: retval = "V_SgOpenclAccessModeModifier"; break;
        case 506: retval = "V_SgOpenStatement"; break;
        case 507: retval = "V_SgOptions"; break;
        case 508: retval = "V_SgOrOp"; break;
        case 509: retval = "V_SgParameterStatement"; break;
        case 510: retval = "V_SgPartialFunctionModifierType"; break;
        case 511: retval = "V_SgPartialFunctionType"; break;
        case 512: retval = "V_SgPlusAssignOp"; break;
        case 513: retval = "V_SgPlusPlusOp"; break;
        case 514: retval = "V_SgPntrArrRefExp"; break;
        case 515: retval = "V_SgPointerAssignOp"; break;
        case 516: retval = "V_SgPointerDerefExp"; break;
        case 517: retval = "V_SgPointerMemberType"; break;
        case 518: retval = "V_SgPointerType"; break;
        case 519: retval = "V_SgPragma"; break;
        case 520: retval = "V_SgPragmaDeclaration"; break;
        case 521: retval = "V_SgPrintStatement"; break;
        case 522: retval = "V_SgProcedureHeaderStatement"; break;
        case 523: retval = "V_SgProgramHeaderStatement"; break;
        case 524: retval = "V_SgProject"; break;
        case 525: retval = "V_SgPseudoDestructorRefExp"; break;
        case 526: retval = "V_SgQualifiedName"; break;
        case 527: retval = "V_SgQualifiedNameType"; break;
        case 528: retval = "V_SgReadStatement"; break;
        case 529: retval = "V_SgRealPartOp"; break;
        case 530: retval = "V_SgRefExp"; break;
        case 531: retval = "V_SgReferenceType"; break;
        case 532: retval = "V_SgRenamePair"; break;
        case 533: retval = "V_SgRenameSymbol"; break;
        case 534: retval = "V_SgReturnStmt"; break;
        case 535: retval = "V_SgRewindStatement"; break;
        case 536: retval = "V_SgRshiftAssignOp"; break;
        case 537: retval = "V_SgRshiftOp"; break;
        case 538: retval = "V_SgScopeOp"; break;
        case 539: retval = "V_SgScopeStatement"; break;
        case 540: retval = "V_SgSequenceStatement"; break;
        case 541: retval = "V_SgShortVal"; break;
        case 542: retval = "V_SgSizeOfOp"; break;
        case 543: retval = "V_SgSourceFile"; break;
        case 544: retval = "V_SgSpawnStmt"; break;
        case 545: retval = "V_SgSpecialFunctionModifier"; break;
        case 546: retval = "V_SgStatement"; break;
        case 547: retval = "V_SgStatementExpression"; break;
        case 548: retval = "V_SgStatementFunctionStatement"; break;
        case 549: retval = "V_SgStopOrPauseStatement"; break;
        case 550: retval = "V_SgStorageModifier"; break;
        case 551: retval = "V_SgStringKeyedBidirectionalGraph"; break;
        case 552: retval = "V_SgStringVal"; break;
        case 553: retval = "V_SgSubscriptExpression"; break;
        case 554: retval = "V_SgSubtractOp"; break;
        case 555: retval = "V_SgSupport"; break;
        case 556: retval = "V_SgSwitchStatement"; break;
        case 557: retval = "V_SgSymbol"; break;
        case 558: retval = "V_SgSymbolTable"; break;
        case 559: retval = "V_SgTemplateArgument"; break;
        case 560: retval = "V_SgTemplateArgumentList"; break;
        case 561: retval = "V_SgTemplateDeclaration"; break;
        case 562: retval = "V_SgTemplateInstantiationDecl"; break;
        case 563: retval = "V_SgTemplateInstantiationDefn"; break;
        case 564: retval = "V_SgTemplateInstantiationDirectiveStatement"; break;
        case 565: retval = "V_SgTemplateInstantiationFunctionDecl"; break;
        case 566: retval = "V_SgTemplateInstantiationMemberFunctionDecl"; break;
        case 567: retval = "V_SgTemplateParameter"; break;
        case 568: retval = "V_SgTemplateParameterList"; break;
        case 569: retval = "V_SgTemplateSymbol"; break;
        case 570: retval = "V_SgTemplateType"; break;
        case 571: retval = "V_SgThisExp"; break;
        case 572: retval = "V_SgThrowOp"; break;
        case 573: retval = "V_SgToken"; break;
        case 574: retval = "V_SgTryStmt"; break;
        case 575: retval = "V_SgType"; break;
        case 576: retval = "V_SgTypeBool"; break;
        case 577: retval = "V_SgTypeChar"; break;
        case 578: retval = "V_SgTypeComplex"; break;
        case 579: retval = "V_SgTypeDefault"; break;
        case 580: retval = "V_SgTypeLabel"; break;
        case 581: retval = "V_SgTypeDouble"; break;
        case 582: retval = "V_SgTypeEllipse"; break;
        case 583: retval = "V_SgTypeFloat"; break;
        case 584: retval = "V_SgTypeGlobalVoid"; break;
        case 585: retval = "V_SgTypeIdOp"; break;
        case 586: retval = "V_SgTypeImaginary"; break;
        case 587: retval = "V_SgTypeInt"; break;
        case 588: retval = "V_SgTypeLong"; break;
        case 589: retval = "V_SgTypeLongDouble"; break;
        case 590: retval = "V_SgTypeLongLong"; break;
        case 591: retval = "V_SgTypeModifier"; break;
        case 592: retval = "V_SgTypeShort"; break;
        case 593: retval = "V_SgTypeSignedChar"; break;
        case 594: retval = "V_SgTypeSignedInt"; break;
        case 595: retval = "V_SgTypeSignedLong"; break;
        case 596: retval = "V_SgTypeSignedLongLong"; break;
        case 597: retval = "V_SgTypeSignedShort"; break;
        case 598: retval = "V_SgTypeString"; break;
        case 599: retval = "V_SgTypeUnknown"; break;
        case 600: retval = "V_SgTypeUnsignedChar"; break;
        case 601: retval = "V_SgTypeUnsignedInt"; break;
        case 602: retval = "V_SgTypeUnsignedLong"; break;
        case 603: retval = "V_SgTypeUnsignedLongLong"; break;
        case 604: retval = "V_SgTypeUnsignedShort"; break;
        case 605: retval = "V_SgTypeVoid"; break;
        case 606: retval = "V_SgTypeWchar"; break;
        case 607: retval = "V_SgTypedefDeclaration"; break;
        case 608: retval = "V_SgTypedefSeq"; break;
        case 609: retval = "V_SgTypedefSymbol"; break;
        case 610: retval = "V_SgTypedefType"; break;
        case 611: retval = "V_SgUPC_AccessModifier"; break;
        case 612: retval = "V_SgUnaryAddOp"; break;
        case 613: retval = "V_SgUnaryOp"; break;
        case 614: retval = "V_SgUndefDirectiveStatement"; break;
        case 615: retval = "V_SgUndirectedGraphEdge"; break;
        case 616: retval = "V_SgUnknownArrayOrFunctionReference"; break;
        case 617: retval = "V_SgUnknownFile"; break;
        case 619: retval = "V_SgUnparse_Info"; break;
        case 620: retval = "V_SgUnsignedCharVal"; break;
        case 621: retval = "V_SgUnsignedIntVal"; break;
        case 622: retval = "V_SgUnsignedLongLongIntVal"; break;
        case 623: retval = "V_SgUnsignedLongVal"; break;
        case 624: retval = "V_SgUnsignedShortVal"; break;
        case 625: retval = "V_SgUpcBarrierStatement"; break;
        case 626: retval = "V_SgUpcBlocksizeofExpression"; break;
        case 627: retval = "V_SgUpcElemsizeofExpression"; break;
        case 628: retval = "V_SgUpcFenceStatement"; break;
        case 629: retval = "V_SgUpcForAllStatement"; break;
        case 630: retval = "V_SgUpcLocalsizeofExpression"; break;
        case 631: retval = "V_SgUpcMythread"; break;
        case 632: retval = "V_SgUpcNotifyStatement"; break;
        case 633: retval = "V_SgUpcThreads"; break;
        case 634: retval = "V_SgUpcWaitStatement"; break;
        case 635: retval = "V_SgUseStatement"; break;
        case 636: retval = "V_SgUserDefinedBinaryOp"; break;
        case 637: retval = "V_SgUserDefinedUnaryOp"; break;
        case 638: retval = "V_SgUsingDeclarationStatement"; break;
        case 639: retval = "V_SgUsingDirectiveStatement"; break;
        case 640: retval = "V_SgValueExp"; break;
        case 641: retval = "V_SgVarArgCopyOp"; break;
        case 642: retval = "V_SgVarArgEndOp"; break;
        case 643: retval = "V_SgVarArgOp"; break;
        case 644: retval = "V_SgVarArgStartOneOperandOp"; break;
        case 645: retval = "V_SgVarArgStartOp"; break;
        case 646: retval = "V_SgVarRefExp"; break;
        case 647: retval = "V_SgVariableDeclaration"; break;
        case 648: retval = "V_SgVariableDefinition"; break;
        case 649: retval = "V_SgVariableSymbol"; break;
        case 650: retval = "V_SgVariantExpression"; break;
        case 651: retval = "V_SgVariantStatement"; break;
        case 652: retval = "V_SgWaitStatement"; break;
        case 653: retval = "V_SgWarningDirectiveStatement"; break;
        case 654: retval = "V_SgWcharVal"; break;
        case 655: retval = "V_SgWhereStatement"; break;
        case 656: retval = "V_SgWhileStmt"; break;
        case 657: retval = "V_SgWriteStatement"; break;
        case 658: retval = "V_SgXorAssignOp"; break;
        case 659: retval = "V_Sg_File_Info"; break;
        case 660: retval = "V_SgTypeCAFTeam"; break;
        case 661: retval = "V_SgCAFWithTeamStatement"; break;
        case 662: retval = "V_SgCAFCoExpression"; break;
        case 663: retval = "V_SgTypeCrayPointer"; break;
        case 665: retval = "V_SgNumVariants"; break;
    }
    if (retval.empty()) {
        char buf[72];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(VariantT)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "VariantT::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// VirtualBinCFG::EdgeConditionKind is defined at src/frontend/SageIII/virtualCFG/virtualBinCFG.h:15
/** Converts an enum of type VirtualBinCFG::EdgeConditionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyVirtualBinCFG_EdgeConditionKind(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "eckUnconditional"; break;
        case 1: retval = "eckTrue"; break;
        case 2: retval = "eckFalse"; break;
        case 3: retval = "eckCaseLabel"; break;
        case 4: retval = "eckDefault"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(VirtualBinCFG::EdgeConditionKind)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "VirtualBinCFG::EdgeConditionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// VirtualCFG::EdgeConditionKind is defined at src/frontend/SageIII/virtualCFG/virtualCFG.h:40
/** Converts an enum of type VirtualCFG::EdgeConditionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyVirtualCFG_EdgeConditionKind(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "eckUnconditional"; break;
        case 1: retval = "eckTrue"; break;
        case 2: retval = "eckFalse"; break;
        case 3: retval = "eckCaseLabel"; break;
        case 4: retval = "eckDefault"; break;
        case 5: retval = "eckDoConditionPassed"; break;
        case 6: retval = "eckDoConditionFailed"; break;
        case 7: retval = "eckForallIndicesInRange"; break;
        case 8: retval = "eckForallIndicesNotInRange"; break;
        case 9: retval = "eckComputedGotoCaseLabel"; break;
        case 10: retval = "eckArithmeticIfLess"; break;
        case 11: retval = "eckArithmeticIfEqual"; break;
        case 12: retval = "eckArithmeticIfGreater"; break;
        case 13: retval = "eckInterprocedural"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(VirtualCFG::EdgeConditionKind)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "VirtualCFG::EdgeConditionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// VirtualMachineSemantics::Policy::MemRefType is defined at src/midend/binaryAnalyses/instructionSemantics/VirtualMachineSemantics.h:453
/** Converts an enum of type VirtualMachineSemantics::Policy::MemRefType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyVirtualMachineSemanticsPolicyMemRefType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "MRT_STACK_PTR"; break;
        case 1: retval = "MRT_FRAME_PTR"; break;
        case 2: retval = "MRT_OTHER_PTR"; break;
    }
    if (retval.empty()) {
        char buf[107];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(VirtualMachineSemantics::Policy::MemRefType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "VirtualMachineSemantics::Policy::MemRefType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// X86BranchPrediction is defined at src/frontend/Disassemblers/InstructionEnumsX86.h:88
/** Converts an enum of type X86BranchPrediction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86BranchPrediction(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_branch_prediction_none"; break;
        case 1: retval = "x86_branch_prediction_taken"; break;
        case 2: retval = "x86_branch_prediction_not_taken"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(X86BranchPrediction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86BranchPrediction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// X86Flag is defined at src/frontend/Disassemblers/InstructionEnumsX86.h:66
/** Converts an enum of type X86Flag to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86Flag(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_flag_cf"; break;
        case 2: retval = "x86_flag_pf"; break;
        case 4: retval = "x86_flag_af"; break;
        case 6: retval = "x86_flag_zf"; break;
        case 7: retval = "x86_flag_sf"; break;
        case 8: retval = "x86_flag_tf"; break;
        case 9: retval = "x86_flag_if"; break;
        case 10: retval = "x86_flag_df"; break;
        case 11: retval = "x86_flag_of"; break;
        case 12: retval = "x86_flag_iopl"; break;
        case 14: retval = "x86_flag_nt"; break;
        case 16: retval = "x86_flag_rf"; break;
        case 17: retval = "x86_flag_vm"; break;
        case 18: retval = "x86_flag_ac"; break;
        case 19: retval = "x86_flag_vif"; break;
        case 20: retval = "x86_flag_vip"; break;
        case 21: retval = "x86_flag_id"; break;
    }
    if (retval.empty()) {
        char buf[71];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(X86Flag)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86Flag::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// X86GeneralPurposeRegister is defined at src/frontend/Disassemblers/InstructionEnumsX86.h:45
/** Converts an enum of type X86GeneralPurposeRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86GeneralPurposeRegister(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_gpr_ax"; break;
        case 1: retval = "x86_gpr_cx"; break;
        case 2: retval = "x86_gpr_dx"; break;
        case 3: retval = "x86_gpr_bx"; break;
        case 4: retval = "x86_gpr_sp"; break;
        case 5: retval = "x86_gpr_bp"; break;
        case 6: retval = "x86_gpr_si"; break;
        case 7: retval = "x86_gpr_di"; break;
        case 8: retval = "x86_gpr_r8"; break;
        case 9: retval = "x86_gpr_r9"; break;
        case 10: retval = "x86_gpr_r10"; break;
        case 11: retval = "x86_gpr_r11"; break;
        case 12: retval = "x86_gpr_r12"; break;
        case 13: retval = "x86_gpr_r13"; break;
        case 14: retval = "x86_gpr_r14"; break;
        case 15: retval = "x86_gpr_r15"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(X86GeneralPurposeRegister)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86GeneralPurposeRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// X86InstructionKind is defined at src/frontend/Disassemblers/AssemblerX86Init.h:22
/** Converts an enum of type X86InstructionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86InstructionKind(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_unknown_instruction"; break;
        case 1: retval = "x86_aaa"; break;
        case 2: retval = "x86_aad"; break;
        case 3: retval = "x86_aam"; break;
        case 4: retval = "x86_aas"; break;
        case 5: retval = "x86_adc"; break;
        case 6: retval = "x86_add"; break;
        case 7: retval = "x86_addpd"; break;
        case 8: retval = "x86_addps"; break;
        case 9: retval = "x86_addsd"; break;
        case 10: retval = "x86_addss"; break;
        case 11: retval = "x86_addsubpd"; break;
        case 12: retval = "x86_addsubps"; break;
        case 13: retval = "x86_and"; break;
        case 14: retval = "x86_andnpd"; break;
        case 15: retval = "x86_andnps"; break;
        case 16: retval = "x86_andpd"; break;
        case 17: retval = "x86_andps"; break;
        case 18: retval = "x86_arpl"; break;
        case 19: retval = "x86_blendpd"; break;
        case 20: retval = "x86_blendps"; break;
        case 21: retval = "x86_blendvpd"; break;
        case 22: retval = "x86_blendvps"; break;
        case 23: retval = "x86_bound"; break;
        case 24: retval = "x86_bsf"; break;
        case 25: retval = "x86_bsr"; break;
        case 26: retval = "x86_bswap"; break;
        case 27: retval = "x86_bt"; break;
        case 28: retval = "x86_btc"; break;
        case 29: retval = "x86_btr"; break;
        case 30: retval = "x86_bts"; break;
        case 31: retval = "x86_call"; break;
        case 32: retval = "x86_cbw"; break;
        case 33: retval = "x86_cdq"; break;
        case 34: retval = "x86_cdqe"; break;
        case 35: retval = "x86_clc"; break;
        case 36: retval = "x86_cld"; break;
        case 37: retval = "x86_clflush"; break;
        case 38: retval = "x86_clgi"; break;
        case 39: retval = "x86_cli"; break;
        case 40: retval = "x86_clts"; break;
        case 41: retval = "x86_cmc"; break;
        case 42: retval = "x86_cmova"; break;
        case 43: retval = "x86_cmovae"; break;
        case 44: retval = "x86_cmovb"; break;
        case 45: retval = "x86_cmovbe"; break;
        case 46: retval = "x86_cmove"; break;
        case 47: retval = "x86_cmovg"; break;
        case 48: retval = "x86_cmovge"; break;
        case 49: retval = "x86_cmovl"; break;
        case 50: retval = "x86_cmovle"; break;
        case 51: retval = "x86_cmovne"; break;
        case 52: retval = "x86_cmovno"; break;
        case 53: retval = "x86_cmovns"; break;
        case 54: retval = "x86_cmovo"; break;
        case 55: retval = "x86_cmovpe"; break;
        case 56: retval = "x86_cmovpo"; break;
        case 57: retval = "x86_cmovs"; break;
        case 58: retval = "x86_cmp"; break;
        case 59: retval = "x86_cmppd"; break;
        case 60: retval = "x86_cmpps"; break;
        case 61: retval = "x86_cmpsb"; break;
        case 62: retval = "x86_cmpsd"; break;
        case 63: retval = "x86_cmpsq"; break;
        case 64: retval = "x86_cmpss"; break;
        case 65: retval = "x86_cmpsw"; break;
        case 66: retval = "x86_cmpxchg"; break;
        case 67: retval = "x86_cmpxchg16b"; break;
        case 68: retval = "x86_cmpxchg8b"; break;
        case 69: retval = "x86_comisd"; break;
        case 70: retval = "x86_comiss"; break;
        case 71: retval = "x86_cpuid"; break;
        case 72: retval = "x86_cqo"; break;
        case 73: retval = "x86_crc32"; break;
        case 74: retval = "x86_cvtdq2pd"; break;
        case 75: retval = "x86_cvtdq2ps"; break;
        case 76: retval = "x86_cvtpd2dq"; break;
        case 77: retval = "x86_cvtpd2pi"; break;
        case 78: retval = "x86_cvtpd2ps"; break;
        case 79: retval = "x86_cvtpi2pd"; break;
        case 80: retval = "x86_cvtpi2ps"; break;
        case 81: retval = "x86_cvtps2dq"; break;
        case 82: retval = "x86_cvtps2pd"; break;
        case 83: retval = "x86_cvtps2pi"; break;
        case 84: retval = "x86_cvtsd2si"; break;
        case 85: retval = "x86_cvtsd2ss"; break;
        case 86: retval = "x86_cvtsi2sd"; break;
        case 87: retval = "x86_cvtsi2ss"; break;
        case 88: retval = "x86_cvtss2sd"; break;
        case 89: retval = "x86_cvtss2si"; break;
        case 90: retval = "x86_cvttpd2dq"; break;
        case 91: retval = "x86_cvttpd2pi"; break;
        case 92: retval = "x86_cvttps2dq"; break;
        case 93: retval = "x86_cvttps2pi"; break;
        case 94: retval = "x86_cvttsd2si"; break;
        case 95: retval = "x86_cvttss2si"; break;
        case 96: retval = "x86_cwd"; break;
        case 97: retval = "x86_cwde"; break;
        case 98: retval = "x86_daa"; break;
        case 99: retval = "x86_das"; break;
        case 100: retval = "x86_dec"; break;
        case 101: retval = "x86_div"; break;
        case 102: retval = "x86_divpd"; break;
        case 103: retval = "x86_divps"; break;
        case 104: retval = "x86_divsd"; break;
        case 105: retval = "x86_divss"; break;
        case 106: retval = "x86_dppd"; break;
        case 107: retval = "x86_dpps"; break;
        case 108: retval = "x86_emms"; break;
        case 109: retval = "x86_enter"; break;
        case 110: retval = "x86_extractps"; break;
        case 111: retval = "x86_extrq"; break;
        case 112: retval = "x86_f2xm1"; break;
        case 113: retval = "x86_fabs"; break;
        case 114: retval = "x86_fadd"; break;
        case 115: retval = "x86_faddp"; break;
        case 116: retval = "x86_farcall"; break;
        case 117: retval = "x86_farjmp"; break;
        case 118: retval = "x86_fbld"; break;
        case 119: retval = "x86_fbstp"; break;
        case 120: retval = "x86_fchs"; break;
        case 121: retval = "x86_fcmovb"; break;
        case 122: retval = "x86_fcmovbe"; break;
        case 123: retval = "x86_fcmove"; break;
        case 124: retval = "x86_fcmovnb"; break;
        case 125: retval = "x86_fcmovnbe"; break;
        case 126: retval = "x86_fcmovne"; break;
        case 127: retval = "x86_fcmovnu"; break;
        case 128: retval = "x86_fcmovu"; break;
        case 129: retval = "x86_fcom"; break;
        case 130: retval = "x86_fcomi"; break;
        case 131: retval = "x86_fcomip"; break;
        case 132: retval = "x86_fcomp"; break;
        case 133: retval = "x86_fcompp"; break;
        case 134: retval = "x86_fcos"; break;
        case 135: retval = "x86_fdecstp"; break;
        case 136: retval = "x86_fdiv"; break;
        case 137: retval = "x86_fdivp"; break;
        case 138: retval = "x86_fdivr"; break;
        case 139: retval = "x86_fdivrp"; break;
        case 140: retval = "x86_femms"; break;
        case 141: retval = "x86_ffree"; break;
        case 142: retval = "x86_fiadd"; break;
        case 143: retval = "x86_ficom"; break;
        case 144: retval = "x86_ficomp"; break;
        case 145: retval = "x86_fidiv"; break;
        case 146: retval = "x86_fidivr"; break;
        case 147: retval = "x86_fild"; break;
        case 148: retval = "x86_fimul"; break;
        case 149: retval = "x86_fincstp"; break;
        case 150: retval = "x86_fist"; break;
        case 151: retval = "x86_fistp"; break;
        case 152: retval = "x86_fisttp"; break;
        case 153: retval = "x86_fisub"; break;
        case 154: retval = "x86_fisubr"; break;
        case 155: retval = "x86_fld"; break;
        case 156: retval = "x86_fld1"; break;
        case 157: retval = "x86_fldcw"; break;
        case 158: retval = "x86_fldenv"; break;
        case 159: retval = "x86_fldl2e"; break;
        case 160: retval = "x86_fldl2t"; break;
        case 161: retval = "x86_fldlg2"; break;
        case 162: retval = "x86_fldln2"; break;
        case 163: retval = "x86_fldpi"; break;
        case 164: retval = "x86_fldz"; break;
        case 165: retval = "x86_fmul"; break;
        case 166: retval = "x86_fmulp"; break;
        case 167: retval = "x86_fnclex"; break;
        case 168: retval = "x86_fninit"; break;
        case 169: retval = "x86_fnop"; break;
        case 170: retval = "x86_fnsave"; break;
        case 171: retval = "x86_fnstcw"; break;
        case 172: retval = "x86_fnstenv"; break;
        case 173: retval = "x86_fnstsw"; break;
        case 174: retval = "x86_fpatan"; break;
        case 175: retval = "x86_fprem"; break;
        case 176: retval = "x86_fprem1"; break;
        case 177: retval = "x86_fptan"; break;
        case 178: retval = "x86_frndint"; break;
        case 179: retval = "x86_frstor"; break;
        case 180: retval = "x86_fscale"; break;
        case 181: retval = "x86_fsin"; break;
        case 182: retval = "x86_fsincos"; break;
        case 183: retval = "x86_fsqrt"; break;
        case 184: retval = "x86_fst"; break;
        case 185: retval = "x86_fstp"; break;
        case 186: retval = "x86_fsub"; break;
        case 187: retval = "x86_fsubp"; break;
        case 188: retval = "x86_fsubr"; break;
        case 189: retval = "x86_fsubrp"; break;
        case 190: retval = "x86_ftst"; break;
        case 191: retval = "x86_fucom"; break;
        case 192: retval = "x86_fucomi"; break;
        case 193: retval = "x86_fucomip"; break;
        case 194: retval = "x86_fucomp"; break;
        case 195: retval = "x86_fucompp"; break;
        case 196: retval = "x86_fwait"; break;
        case 197: retval = "x86_fxam"; break;
        case 198: retval = "x86_fxch"; break;
        case 199: retval = "x86_fxrstor"; break;
        case 200: retval = "x86_fxsave"; break;
        case 201: retval = "x86_fxtract"; break;
        case 202: retval = "x86_fyl2x"; break;
        case 203: retval = "x86_fyl2xp1"; break;
        case 204: retval = "x86_getsec"; break;
        case 205: retval = "x86_haddpd"; break;
        case 206: retval = "x86_haddps"; break;
        case 207: retval = "x86_hlt"; break;
        case 208: retval = "x86_hsubpd"; break;
        case 209: retval = "x86_hsubps"; break;
        case 210: retval = "x86_idiv"; break;
        case 211: retval = "x86_imul"; break;
        case 212: retval = "x86_in"; break;
        case 213: retval = "x86_inc"; break;
        case 214: retval = "x86_insb"; break;
        case 215: retval = "x86_insd"; break;
        case 216: retval = "x86_insertps"; break;
        case 217: retval = "x86_insertq"; break;
        case 218: retval = "x86_insw"; break;
        case 219: retval = "x86_int"; break;
        case 220: retval = "x86_int1"; break;
        case 221: retval = "x86_int3"; break;
        case 222: retval = "x86_into"; break;
        case 223: retval = "x86_invd"; break;
        case 224: retval = "x86_invept"; break;
        case 225: retval = "x86_invlpg"; break;
        case 226: retval = "x86_invlpga"; break;
        case 227: retval = "x86_invvpid"; break;
        case 228: retval = "x86_iret"; break;
        case 229: retval = "x86_ja"; break;
        case 230: retval = "x86_jae"; break;
        case 231: retval = "x86_jb"; break;
        case 232: retval = "x86_jbe"; break;
        case 233: retval = "x86_jcxz"; break;
        case 234: retval = "x86_je"; break;
        case 235: retval = "x86_jecxz"; break;
        case 236: retval = "x86_jg"; break;
        case 237: retval = "x86_jge"; break;
        case 238: retval = "x86_jl"; break;
        case 239: retval = "x86_jle"; break;
        case 240: retval = "x86_jmp"; break;
        case 241: retval = "x86_jmpe"; break;
        case 242: retval = "x86_jne"; break;
        case 243: retval = "x86_jno"; break;
        case 244: retval = "x86_jns"; break;
        case 245: retval = "x86_jo"; break;
        case 246: retval = "x86_jpe"; break;
        case 247: retval = "x86_jpo"; break;
        case 248: retval = "x86_jrcxz"; break;
        case 249: retval = "x86_js"; break;
        case 250: retval = "x86_lahf"; break;
        case 251: retval = "x86_lar"; break;
        case 252: retval = "x86_lddqu"; break;
        case 253: retval = "x86_ldmxcsr"; break;
        case 254: retval = "x86_lds"; break;
        case 255: retval = "x86_lea"; break;
        case 256: retval = "x86_leave"; break;
        case 257: retval = "x86_les"; break;
        case 258: retval = "x86_lfence"; break;
        case 259: retval = "x86_lfs"; break;
        case 260: retval = "x86_lgdt"; break;
        case 261: retval = "x86_lgs"; break;
        case 262: retval = "x86_lidt"; break;
        case 263: retval = "x86_lldt"; break;
        case 264: retval = "x86_lmsw"; break;
        case 265: retval = "x86_lock"; break;
        case 266: retval = "x86_lodsb"; break;
        case 267: retval = "x86_lodsd"; break;
        case 268: retval = "x86_lodsq"; break;
        case 269: retval = "x86_lodsw"; break;
        case 270: retval = "x86_loop"; break;
        case 271: retval = "x86_loopnz"; break;
        case 272: retval = "x86_loopz"; break;
        case 273: retval = "x86_lsl"; break;
        case 274: retval = "x86_lss"; break;
        case 275: retval = "x86_ltr"; break;
        case 276: retval = "x86_lzcnt"; break;
        case 277: retval = "x86_maskmovq"; break;
        case 278: retval = "x86_maxpd"; break;
        case 279: retval = "x86_maxps"; break;
        case 280: retval = "x86_maxsd"; break;
        case 281: retval = "x86_maxss"; break;
        case 282: retval = "x86_mfence"; break;
        case 283: retval = "x86_minpd"; break;
        case 284: retval = "x86_minps"; break;
        case 285: retval = "x86_minsd"; break;
        case 286: retval = "x86_minss"; break;
        case 287: retval = "x86_monitor"; break;
        case 288: retval = "x86_mov"; break;
        case 289: retval = "x86_movapd"; break;
        case 290: retval = "x86_movaps"; break;
        case 291: retval = "x86_movbe"; break;
        case 292: retval = "x86_movd"; break;
        case 293: retval = "x86_movddup"; break;
        case 294: retval = "x86_movdq2q"; break;
        case 295: retval = "x86_movdqa"; break;
        case 296: retval = "x86_movdqu"; break;
        case 297: retval = "x86_movhlps"; break;
        case 298: retval = "x86_movhpd"; break;
        case 299: retval = "x86_movhps"; break;
        case 300: retval = "x86_movlhps"; break;
        case 301: retval = "x86_movlpd"; break;
        case 302: retval = "x86_movlps"; break;
        case 303: retval = "x86_movmskpd"; break;
        case 304: retval = "x86_movmskps"; break;
        case 305: retval = "x86_movntdq"; break;
        case 306: retval = "x86_movntdqa"; break;
        case 307: retval = "x86_movnti"; break;
        case 308: retval = "x86_movntpd"; break;
        case 309: retval = "x86_movntps"; break;
        case 310: retval = "x86_movntq"; break;
        case 311: retval = "x86_movntsd"; break;
        case 312: retval = "x86_movntss"; break;
        case 313: retval = "x86_movq"; break;
        case 314: retval = "x86_movq2dq"; break;
        case 315: retval = "x86_movsb"; break;
        case 316: retval = "x86_movsd"; break;
        case 317: retval = "x86_movsd_sse"; break;
        case 318: retval = "x86_movshdup"; break;
        case 319: retval = "x86_movsldup"; break;
        case 320: retval = "x86_movsq"; break;
        case 321: retval = "x86_movss"; break;
        case 322: retval = "x86_movsw"; break;
        case 323: retval = "x86_movsx"; break;
        case 324: retval = "x86_movsxd"; break;
        case 325: retval = "x86_movupd"; break;
        case 326: retval = "x86_movups"; break;
        case 327: retval = "x86_movzx"; break;
        case 328: retval = "x86_mpsadbw"; break;
        case 329: retval = "x86_mul"; break;
        case 330: retval = "x86_mulpd"; break;
        case 331: retval = "x86_mulps"; break;
        case 332: retval = "x86_mulsd"; break;
        case 333: retval = "x86_mulss"; break;
        case 334: retval = "x86_mwait"; break;
        case 335: retval = "x86_neg"; break;
        case 336: retval = "x86_nop"; break;
        case 337: retval = "x86_not"; break;
        case 338: retval = "x86_or"; break;
        case 339: retval = "x86_orpd"; break;
        case 340: retval = "x86_orps"; break;
        case 341: retval = "x86_out"; break;
        case 342: retval = "x86_outs"; break;
        case 343: retval = "x86_outsb"; break;
        case 344: retval = "x86_outsd"; break;
        case 345: retval = "x86_outsw"; break;
        case 346: retval = "x86_pabsb"; break;
        case 347: retval = "x86_pabsd"; break;
        case 348: retval = "x86_pabsw"; break;
        case 349: retval = "x86_packssdw"; break;
        case 350: retval = "x86_packsswb"; break;
        case 351: retval = "x86_packusdw"; break;
        case 352: retval = "x86_packuswb"; break;
        case 353: retval = "x86_paddb"; break;
        case 354: retval = "x86_paddd"; break;
        case 355: retval = "x86_paddq"; break;
        case 356: retval = "x86_paddsb"; break;
        case 357: retval = "x86_paddsw"; break;
        case 358: retval = "x86_paddusb"; break;
        case 359: retval = "x86_paddusw"; break;
        case 360: retval = "x86_paddw"; break;
        case 361: retval = "x86_palignr"; break;
        case 362: retval = "x86_pand"; break;
        case 363: retval = "x86_pandn"; break;
        case 364: retval = "x86_pause"; break;
        case 365: retval = "x86_pavgb"; break;
        case 366: retval = "x86_pavgusb"; break;
        case 367: retval = "x86_pavgw"; break;
        case 368: retval = "x86_pblendvb"; break;
        case 369: retval = "x86_pblendw"; break;
        case 370: retval = "x86_pcmpeqb"; break;
        case 371: retval = "x86_pcmpeqd"; break;
        case 372: retval = "x86_pcmpeqq"; break;
        case 373: retval = "x86_pcmpeqw"; break;
        case 374: retval = "x86_pcmpestri"; break;
        case 375: retval = "x86_pcmpestrm"; break;
        case 376: retval = "x86_pcmpgtb"; break;
        case 377: retval = "x86_pcmpgtd"; break;
        case 378: retval = "x86_pcmpgtq"; break;
        case 379: retval = "x86_pcmpgtw"; break;
        case 380: retval = "x86_pcmpistri"; break;
        case 381: retval = "x86_pcmpistrm"; break;
        case 382: retval = "x86_pextrb"; break;
        case 383: retval = "x86_pextrd"; break;
        case 384: retval = "x86_pextrq"; break;
        case 385: retval = "x86_pextrw"; break;
        case 386: retval = "x86_pf2id"; break;
        case 387: retval = "x86_pf2iw"; break;
        case 388: retval = "x86_pfacc"; break;
        case 389: retval = "x86_pfadd"; break;
        case 390: retval = "x86_pfcmpeq"; break;
        case 391: retval = "x86_pfcmpge"; break;
        case 392: retval = "x86_pfcmpgt"; break;
        case 393: retval = "x86_pfmax"; break;
        case 394: retval = "x86_pfmin"; break;
        case 395: retval = "x86_pfmul"; break;
        case 396: retval = "x86_pfnacc"; break;
        case 397: retval = "x86_pfpnacc"; break;
        case 398: retval = "x86_pfrcp"; break;
        case 399: retval = "x86_pfrcpit1"; break;
        case 400: retval = "x86_pfrcpit2"; break;
        case 401: retval = "x86_pfrsqit1"; break;
        case 402: retval = "x86_pfrsqrt"; break;
        case 403: retval = "x86_pfsub"; break;
        case 404: retval = "x86_pfsubr"; break;
        case 405: retval = "x86_phaddd"; break;
        case 406: retval = "x86_phaddsw"; break;
        case 407: retval = "x86_phaddw"; break;
        case 408: retval = "x86_phminposuw"; break;
        case 409: retval = "x86_phsubd"; break;
        case 410: retval = "x86_phsubsw"; break;
        case 411: retval = "x86_phsubw"; break;
        case 412: retval = "x86_pi2fd"; break;
        case 413: retval = "x86_pi2fw"; break;
        case 414: retval = "x86_pinsrb"; break;
        case 415: retval = "x86_pinsrd"; break;
        case 416: retval = "x86_pinsrq"; break;
        case 417: retval = "x86_pinsrw"; break;
        case 418: retval = "x86_pmaddubsw"; break;
        case 419: retval = "x86_pmaddwd"; break;
        case 420: retval = "x86_pmaxsb"; break;
        case 421: retval = "x86_pmaxsd"; break;
        case 422: retval = "x86_pmaxsw"; break;
        case 423: retval = "x86_pmaxub"; break;
        case 424: retval = "x86_pmaxud"; break;
        case 425: retval = "x86_pmaxuw"; break;
        case 426: retval = "x86_pminsb"; break;
        case 427: retval = "x86_pminsd"; break;
        case 428: retval = "x86_pminsw"; break;
        case 429: retval = "x86_pminub"; break;
        case 430: retval = "x86_pminud"; break;
        case 431: retval = "x86_pminuw"; break;
        case 432: retval = "x86_pmovmskb"; break;
        case 433: retval = "x86_pmovsxbd"; break;
        case 434: retval = "x86_pmovsxbq"; break;
        case 435: retval = "x86_pmovsxbw"; break;
        case 436: retval = "x86_pmovsxdq"; break;
        case 437: retval = "x86_pmovsxwd"; break;
        case 438: retval = "x86_pmovsxwq"; break;
        case 439: retval = "x86_pmovzxbd"; break;
        case 440: retval = "x86_pmovzxbq"; break;
        case 441: retval = "x86_pmovzxbw"; break;
        case 442: retval = "x86_pmovzxdq"; break;
        case 443: retval = "x86_pmovzxwd"; break;
        case 444: retval = "x86_pmovzxwq"; break;
        case 445: retval = "x86_pmuldq"; break;
        case 446: retval = "x86_pmulhrsw"; break;
        case 447: retval = "x86_pmulhrw"; break;
        case 448: retval = "x86_pmulhuw"; break;
        case 449: retval = "x86_pmulhw"; break;
        case 450: retval = "x86_pmulld"; break;
        case 451: retval = "x86_pmullw"; break;
        case 452: retval = "x86_pmuludq"; break;
        case 453: retval = "x86_pop"; break;
        case 454: retval = "x86_popa"; break;
        case 455: retval = "x86_popad"; break;
        case 456: retval = "x86_popcnt"; break;
        case 457: retval = "x86_popf"; break;
        case 458: retval = "x86_popfd"; break;
        case 459: retval = "x86_popfq"; break;
        case 460: retval = "x86_por"; break;
        case 461: retval = "x86_prefetch"; break;
        case 462: retval = "x86_prefetchnta"; break;
        case 463: retval = "x86_prefetcht0"; break;
        case 464: retval = "x86_prefetcht1"; break;
        case 465: retval = "x86_prefetcht2"; break;
        case 466: retval = "x86_prefetchw"; break;
        case 467: retval = "x86_psadbw"; break;
        case 468: retval = "x86_pshufb"; break;
        case 469: retval = "x86_pshufd"; break;
        case 470: retval = "x86_pshufhw"; break;
        case 471: retval = "x86_pshuflw"; break;
        case 472: retval = "x86_pshufw"; break;
        case 473: retval = "x86_psignb"; break;
        case 474: retval = "x86_psignd"; break;
        case 475: retval = "x86_psignw"; break;
        case 476: retval = "x86_pslld"; break;
        case 477: retval = "x86_pslldq"; break;
        case 478: retval = "x86_psllq"; break;
        case 479: retval = "x86_psllw"; break;
        case 480: retval = "x86_psrad"; break;
        case 481: retval = "x86_psraq"; break;
        case 482: retval = "x86_psraw"; break;
        case 483: retval = "x86_psrld"; break;
        case 484: retval = "x86_psrldq"; break;
        case 485: retval = "x86_psrlq"; break;
        case 486: retval = "x86_psrlw"; break;
        case 487: retval = "x86_psubb"; break;
        case 488: retval = "x86_psubd"; break;
        case 489: retval = "x86_psubq"; break;
        case 490: retval = "x86_psubsb"; break;
        case 491: retval = "x86_psubsw"; break;
        case 492: retval = "x86_psubusb"; break;
        case 493: retval = "x86_psubusw"; break;
        case 494: retval = "x86_psubw"; break;
        case 495: retval = "x86_pswapd"; break;
        case 496: retval = "x86_ptest"; break;
        case 497: retval = "x86_punpckhbw"; break;
        case 498: retval = "x86_punpckhdq"; break;
        case 499: retval = "x86_punpckhqdq"; break;
        case 500: retval = "x86_punpckhwd"; break;
        case 501: retval = "x86_punpcklbw"; break;
        case 502: retval = "x86_punpckldq"; break;
        case 503: retval = "x86_punpcklqdq"; break;
        case 504: retval = "x86_punpcklwd"; break;
        case 505: retval = "x86_push"; break;
        case 506: retval = "x86_pusha"; break;
        case 507: retval = "x86_pushad"; break;
        case 508: retval = "x86_pushf"; break;
        case 509: retval = "x86_pushfd"; break;
        case 510: retval = "x86_pushfq"; break;
        case 511: retval = "x86_pxor"; break;
        case 512: retval = "x86_rcl"; break;
        case 513: retval = "x86_rcpps"; break;
        case 514: retval = "x86_rcpss"; break;
        case 515: retval = "x86_rcr"; break;
        case 516: retval = "x86_rdmsr"; break;
        case 517: retval = "x86_rdpmc"; break;
        case 518: retval = "x86_rdtsc"; break;
        case 519: retval = "x86_rdtscp"; break;
        case 520: retval = "x86_rep_insb"; break;
        case 521: retval = "x86_rep_insd"; break;
        case 522: retval = "x86_rep_insw"; break;
        case 523: retval = "x86_rep_lodsb"; break;
        case 524: retval = "x86_rep_lodsd"; break;
        case 525: retval = "x86_rep_lodsq"; break;
        case 526: retval = "x86_rep_lodsw"; break;
        case 527: retval = "x86_rep_movsb"; break;
        case 528: retval = "x86_rep_movsd"; break;
        case 529: retval = "x86_rep_movsq"; break;
        case 530: retval = "x86_rep_movsw"; break;
        case 531: retval = "x86_rep_outsb"; break;
        case 532: retval = "x86_rep_outsd"; break;
        case 533: retval = "x86_rep_outsw"; break;
        case 534: retval = "x86_rep_stosb"; break;
        case 535: retval = "x86_rep_stosd"; break;
        case 536: retval = "x86_rep_stosq"; break;
        case 537: retval = "x86_rep_stosw"; break;
        case 538: retval = "x86_repe_cmpsb"; break;
        case 539: retval = "x86_repe_cmpsd"; break;
        case 540: retval = "x86_repe_cmpsq"; break;
        case 541: retval = "x86_repe_cmpsw"; break;
        case 542: retval = "x86_repe_scasb"; break;
        case 543: retval = "x86_repe_scasd"; break;
        case 544: retval = "x86_repe_scasq"; break;
        case 545: retval = "x86_repe_scasw"; break;
        case 546: retval = "x86_repne_cmpsb"; break;
        case 547: retval = "x86_repne_cmpsd"; break;
        case 548: retval = "x86_repne_cmpsq"; break;
        case 549: retval = "x86_repne_cmpsw"; break;
        case 550: retval = "x86_repne_scasb"; break;
        case 551: retval = "x86_repne_scasd"; break;
        case 552: retval = "x86_repne_scasq"; break;
        case 553: retval = "x86_repne_scasw"; break;
        case 554: retval = "x86_ret"; break;
        case 555: retval = "x86_retf"; break;
        case 556: retval = "x86_rol"; break;
        case 557: retval = "x86_ror"; break;
        case 558: retval = "x86_roundpd"; break;
        case 559: retval = "x86_roundps"; break;
        case 560: retval = "x86_roundsd"; break;
        case 561: retval = "x86_roundss"; break;
        case 562: retval = "x86_rsm"; break;
        case 563: retval = "x86_rsqrtps"; break;
        case 564: retval = "x86_rsqrtss"; break;
        case 565: retval = "x86_sahf"; break;
        case 566: retval = "x86_salc"; break;
        case 567: retval = "x86_sar"; break;
        case 568: retval = "x86_sbb"; break;
        case 569: retval = "x86_scasb"; break;
        case 570: retval = "x86_scasd"; break;
        case 571: retval = "x86_scasq"; break;
        case 572: retval = "x86_scasw"; break;
        case 573: retval = "x86_seta"; break;
        case 574: retval = "x86_setae"; break;
        case 575: retval = "x86_setb"; break;
        case 576: retval = "x86_setbe"; break;
        case 577: retval = "x86_sete"; break;
        case 578: retval = "x86_setg"; break;
        case 579: retval = "x86_setge"; break;
        case 580: retval = "x86_setl"; break;
        case 581: retval = "x86_setle"; break;
        case 582: retval = "x86_setne"; break;
        case 583: retval = "x86_setno"; break;
        case 584: retval = "x86_setns"; break;
        case 585: retval = "x86_seto"; break;
        case 586: retval = "x86_setpe"; break;
        case 587: retval = "x86_setpo"; break;
        case 588: retval = "x86_sets"; break;
        case 589: retval = "x86_sfence"; break;
        case 590: retval = "x86_sgdt"; break;
        case 591: retval = "x86_shl"; break;
        case 592: retval = "x86_shld"; break;
        case 593: retval = "x86_shr"; break;
        case 594: retval = "x86_shrd"; break;
        case 595: retval = "x86_shufpd"; break;
        case 596: retval = "x86_shufps"; break;
        case 597: retval = "x86_sidt"; break;
        case 598: retval = "x86_skinit"; break;
        case 599: retval = "x86_sldt"; break;
        case 600: retval = "x86_smsw"; break;
        case 601: retval = "x86_sqrtpd"; break;
        case 602: retval = "x86_sqrtps"; break;
        case 603: retval = "x86_sqrtsd"; break;
        case 604: retval = "x86_sqrtss"; break;
        case 605: retval = "x86_stc"; break;
        case 606: retval = "x86_std"; break;
        case 607: retval = "x86_stgi"; break;
        case 608: retval = "x86_sti"; break;
        case 609: retval = "x86_stmxcsr"; break;
        case 610: retval = "x86_stos"; break;
        case 611: retval = "x86_stosb"; break;
        case 612: retval = "x86_stosd"; break;
        case 613: retval = "x86_stosq"; break;
        case 614: retval = "x86_stosw"; break;
        case 615: retval = "x86_str"; break;
        case 616: retval = "x86_sub"; break;
        case 617: retval = "x86_subpd"; break;
        case 618: retval = "x86_subps"; break;
        case 619: retval = "x86_subsd"; break;
        case 620: retval = "x86_subss"; break;
        case 621: retval = "x86_swapgs"; break;
        case 622: retval = "x86_syscall"; break;
        case 623: retval = "x86_sysenter"; break;
        case 624: retval = "x86_sysexit"; break;
        case 625: retval = "x86_sysret"; break;
        case 626: retval = "x86_test"; break;
        case 627: retval = "x86_ucomisd"; break;
        case 628: retval = "x86_ucomiss"; break;
        case 629: retval = "x86_ud2"; break;
        case 630: retval = "x86_unpckhpd"; break;
        case 631: retval = "x86_unpckhps"; break;
        case 632: retval = "x86_unpcklpd"; break;
        case 633: retval = "x86_unpcklps"; break;
        case 634: retval = "x86_verr"; break;
        case 635: retval = "x86_verw"; break;
        case 636: retval = "x86_vmcall"; break;
        case 637: retval = "x86_vmclear"; break;
        case 638: retval = "x86_vmlaunch"; break;
        case 639: retval = "x86_vmload"; break;
        case 640: retval = "x86_vmmcall"; break;
        case 641: retval = "x86_vmoff"; break;
        case 642: retval = "x86_vmptrld"; break;
        case 643: retval = "x86_vmptrst"; break;
        case 644: retval = "x86_vmread"; break;
        case 645: retval = "x86_vmresume"; break;
        case 646: retval = "x86_vmrun"; break;
        case 647: retval = "x86_vmsave"; break;
        case 648: retval = "x86_vmwrite"; break;
        case 649: retval = "x86_vmxoff"; break;
        case 650: retval = "x86_vmxon"; break;
        case 651: retval = "x86_wait"; break;
        case 652: retval = "x86_wbinvd"; break;
        case 653: retval = "x86_wrmsr"; break;
        case 654: retval = "x86_xadd"; break;
        case 655: retval = "x86_xchg"; break;
        case 656: retval = "x86_xgetbv"; break;
        case 657: retval = "x86_xlatb"; break;
        case 658: retval = "x86_xor"; break;
        case 659: retval = "x86_xorpd"; break;
        case 660: retval = "x86_xorps"; break;
        case 661: retval = "x86_xrstor"; break;
        case 662: retval = "x86_xsave"; break;
        case 663: retval = "x86_xsetbv"; break;
        case 664: retval = "x86_last_instruction"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(X86InstructionKind)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86InstructionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// X86InstructionSize is defined at src/frontend/Disassemblers/InstructionEnumsX86.h:10
/** Converts an enum of type X86InstructionSize to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86InstructionSize(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_insnsize_none"; break;
        case 1: retval = "x86_insnsize_16"; break;
        case 2: retval = "x86_insnsize_32"; break;
        case 3: retval = "x86_insnsize_64"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(X86InstructionSize)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86InstructionSize::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// X86RegisterClass is defined at src/frontend/Disassemblers/InstructionEnumsX86.h:19
/** Converts an enum of type X86RegisterClass to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86RegisterClass(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_regclass_gpr"; break;
        case 1: retval = "x86_regclass_segment"; break;
        case 2: retval = "x86_regclass_cr"; break;
        case 3: retval = "x86_regclass_dr"; break;
        case 4: retval = "x86_regclass_st"; break;
        case 5: retval = "x86_regclass_mm"; break;
        case 6: retval = "x86_regclass_xmm"; break;
        case 7: retval = "x86_regclass_ip"; break;
        case 8: retval = "x86_regclass_flags"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(X86RegisterClass)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86RegisterClass::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// X86RepeatPrefix is defined at src/frontend/Disassemblers/InstructionEnumsX86.h:96
/** Converts an enum of type X86RepeatPrefix to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86RepeatPrefix(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_repeat_none"; break;
        case 1: retval = "x86_repeat_repne"; break;
        case 2: retval = "x86_repeat_repe"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(X86RepeatPrefix)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86RepeatPrefix::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// X86SegmentRegister is defined at src/frontend/Disassemblers/InstructionEnumsX86.h:33
/** Converts an enum of type X86SegmentRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86SegmentRegister(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_segreg_es"; break;
        case 1: retval = "x86_segreg_cs"; break;
        case 2: retval = "x86_segreg_ss"; break;
        case 3: retval = "x86_segreg_ds"; break;
        case 4: retval = "x86_segreg_fs"; break;
        case 5: retval = "x86_segreg_gs"; break;
        case 16: retval = "x86_segreg_none"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(X86SegmentRegister)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86SegmentRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// YicesSolver::LinkMode is defined at src/midend/binaryAnalyses/instructionSemantics/YicesSolver.h:21
/** Converts an enum of type YicesSolver::LinkMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyYicesSolverLinkMode(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "LM_NONE"; break;
        case 1: retval = "LM_LIBRARY"; break;
        case 2: retval = "LM_EXECUTABLE"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(YicesSolver::LinkMode)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "YicesSolver::LinkMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// boost::edge_dbg_data_t is defined at src/midend/programAnalysis/sideEffectAnalysis/SqliteDatabaseGraph.h:359
/** Converts an enum of type boost::edge_dbg_data_t to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_boost_edge_dbg_data_t(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "edge_dbg_data"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(boost::edge_dbg_data_t)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "boost::edge_dbg_data_t::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// boost::graph_dbg_data_t is defined at src/midend/programAnalysis/sideEffectAnalysis/SqliteDatabaseGraph.h:362
/** Converts an enum of type boost::graph_dbg_data_t to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_boost_graph_dbg_data_t(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "graph_dbg_data"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(boost::graph_dbg_data_t)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "boost::graph_dbg_data_t::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// boost::vertex_callgraph_t is defined at src/midend/programAnalysis/CallGraphAnalysisMySQL/Callgraph.h:34
/** Converts an enum of type boost::vertex_callgraph_t to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_boost_vertex_callgraph_t(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "vertex_callgraph"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(boost::vertex_callgraph_t)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "boost::vertex_callgraph_t::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// boost::vertex_classhierarchy_t is defined at src/midend/programAnalysis/CallGraphAnalysisMySQL/Classhierarchy.h:32
/** Converts an enum of type boost::vertex_classhierarchy_t to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_boost_vertex_classhierarchy_t(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "vertex_classhierarchy"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(boost::vertex_classhierarchy_t)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "boost::vertex_classhierarchy_t::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// boost::vertex_dbg_data_t is defined at src/midend/programAnalysis/sideEffectAnalysis/SqliteDatabaseGraph.h:356
/** Converts an enum of type boost::vertex_dbg_data_t to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_boost_vertex_dbg_data_t(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "vertex_dbg_data"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(boost::vertex_dbg_data_t)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "boost::vertex_dbg_data_t::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// constructPosition is defined at src/frontend/CxxFrontend/EDG/EDG_SAGE_Connection/sourcePositionComputation.h:4
/** Converts an enum of type constructPosition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_constructPosition(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "startOfConstruct"; break;
        case 1: retval = "endOfConstruct"; break;
        case 2: retval = "operatorPosition"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(constructPosition)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "constructPosition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// controlEnum is defined at src/roseExtensions/dataStructureTraversal/exampleTest.C:4
/** Converts an enum of type controlEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_controlEnum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "BEGGINING_OF_ENUM"; break;
        case 1: retval = "typeInt"; break;
        case 2: retval = "typeChar"; break;
        case 3: retval = "typeTestStruct"; break;
        case 4: retval = "END_OF_ENUM"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(controlEnum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "controlEnum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// defaultEnumFunctionType is defined at src/midend/programTransformation/implicitCodeGeneration/defaultFunctionGenerator.C:13
/** Converts an enum of type defaultEnumFunctionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_defaultEnumFunctionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_constructor"; break;
        case 2: retval = "e_destructor"; break;
        case 3: retval = "e_copy_constructor"; break;
        case 4: retval = "e_assignment_operator"; break;
        case 5: retval = "e_last_type"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(defaultEnumFunctionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "defaultEnumFunctionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// language_enum is defined at src/roseSupport/utility_functions.C:405
/** Converts an enum of type language_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_language_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_none"; break;
        case 1: retval = "e_c"; break;
        case 2: retval = "e_cxx"; break;
        case 3: retval = "e_fortran"; break;
        case 4: retval = "e_last_language"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(language_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "language_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// omp_sched_t is defined at src/frontend/SageIII/omp.h:20
/** Converts an enum of type omp_sched_t to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_omp_sched_t(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "omp_sched_static"; break;
        case 2: retval = "omp_sched_dynamic"; break;
        case 3: retval = "omp_sched_guided"; break;
        case 4: retval = "omp_sched_auto"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(omp_sched_t)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "omp_sched_t::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// statementTypeEnum is defined at src/frontend/CxxFrontend/EDG/EDG_SAGE_Connection/sage_gen_be.C:4381
/** Converts an enum of type statementTypeEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_statementTypeEnum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "unknownStatementType"; break;
        case 1: retval = "forwardVariableDeclaration"; break;
        case 2: retval = "variableDeclaration"; break;
        case 3: retval = "typedefDeclaration"; break;
        case 4: retval = "lastStatementTypeEnum"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(statementTypeEnum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "statementTypeEnum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by ../../../scripts/stringify.pl.
// templateDeclarationEnum is defined at src/frontend/CxxFrontend/EDG/EDG_SAGE_Connection/sageFunctionPrototypes.h:62
/** Converts an enum of type templateDeclarationEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_templateDeclarationEnum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_error_declaratation"; break;
        case 1: retval = "e_unknownDeclaration"; break;
        case 2: retval = "e_definingDeclaration"; break;
        case 3: retval = "e_nondefiningDeclaration"; break;
        case 4: retval = "e_last_declaration_value"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint = snprintf(buf, sizeof buf, "(templateDeclarationEnum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "templateDeclarationEnum::" + retval;
    }
    return retval;
}
