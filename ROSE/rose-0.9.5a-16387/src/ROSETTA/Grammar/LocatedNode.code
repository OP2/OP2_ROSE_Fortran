HEADER_START
     public:

#if 0
      //! This enum type is used to hold values controling if new comments/directives are added
      //! to the front of back of the AttachedPreprocessingInfoType (typedef to a list of
      //! PreprocessorInfo objects).
          enum PositionOfPreprocessingInfoInListType
             {
               defaultValue                   = 0, // let the zero value be an error value
               prependPreprocessingInfoToList = 1, // Prepend the new PreprocessingInfo object to the list
               appendPreprocessingInfoToList  = 2  // Append the new PreprocessingInfo object to the list
             };
#endif

       // ~SgLocatedNode();

       // void setlineNumber(unsigned long new_line);

       // virtual bool _print(int depth) const; /* prints file info */

       // DQ (8/20/2004): Make this depricated since we should remove this (or should we?)
       // If we want to preserve it we should make it a member function of SgNode?
       // Function added by DQ (7/22/2001)
       // const char* getFileName() ROSE_DEPRECATED_FUNCTION;
          const std::string & getFilenameString() const;

     protected:
     // void delete_file_info();
     // void directives(ostream& os);
        void post_construction_initialization();

     private:
          $CLASSNAME( const $CLASSNAME & X ); /* until we know what to do with it */

     public:
       // [MK] Member function to attach PreprocessingInfo object to the node
       // void addToAttachedPreprocessingInfo(PreprocessingInfo *prepInfoPtr);
          void addToAttachedPreprocessingInfo( PreprocessingInfo *prepInfoPtr, PreprocessingInfo::RelativePositionType locationInList = PreprocessingInfo::after );

       // DQ (2/6/2003):
       /*! \brief Interface function to implement original SAGE interface to
                  SgFile_Info objects.

          This function is added explicitly to provide the older interface to the file_info
          pointer which has been removed and replaced with two Sg_File_Info pointers to mark the
          start and end of the located node object (previously we only stored the starting location).
          This function still returns the starting location of the construct.
        */
          virtual Sg_File_Info* get_file_info() const;

      //! Access function calls set_startingConstruct(Sg_File_Info*) member function
          virtual void set_file_info(Sg_File_Info* X);

      /*! \brief Allow IR nodes (mostly SgLocatedNode) to be marked as compiler generated.

          Since the flag for isCompilerGenerated is stored in the Sg_File_Info, and because there
          are up to three of these for the source position information to be comprehensive, this 
          function permits a mechanism to have them be set uniformally.  Warnings are issued if
          they are not set uniformally.

          \internal This function marks the Sg_File_Info objects that must already be present.
       */
          void setCompilerGenerated ();
          void unsetCompilerGenerated ();

      /*! \brief Allow IR nodes (mostly SgLocatedNode) to be marked as front-end specific (generated by the front-end to support a specific backend compiler; e.g. GNU gcc and g++).

          Since the flag for isFrontendSpecific is stored in the Sg_File_Info, and because there
          are up to three of these for the source position information to be comprehensive, this 
          function permits a mechanism to have them be set uniformally.  Warnings are issued if
          they are not set uniformally.

          \internal This function marks the Sg_File_Info objects that must already be present.
       */
          void setFrontendSpecific ();
          void unsetFrontendSpecific ();

      /*! \brief Allow IR nodes (mostly SgLocatedNode) to be marked as to when the information was unavilable in the front-end (even if it typically is there are special cases).

          Since the flag for isSourcePositionUnavailableInFrontend is stored in the Sg_File_Info, and because there
          are up to three of these for the source position information to be comprehensive, this 
          function permits a mechanism to have them be set uniformally.  Warnings are issued if
          they are not set uniformally.

          \internal This function marks the Sg_File_Info objects that must already be present.
       */
          void setSourcePositionUnavailableInFrontend();
          void unsetSourcePositionUnavailableInFrontend();

      /*! \brief Allow IR nodes (mostly SgLocatedNode) to be marked as to when the information was unavilable in the front-end (even if it typically is there are special cases).

          Since the flag for isOutputInCodeGeneration is stored in the Sg_File_Info, and because there
          are up to three of these for the source position information to be comprehensive, this 
          function permits a mechanism to have them be set uniformally.  Warnings are issued if
          they are not set uniformally.

          \internal This function marks the Sg_File_Info objects that must already be present.
       */
          void setOutputInCodeGeneration();
          void unsetOutputInCodeGeneration();

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (11/1/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

      /*! \brief Computes the number of nodes in the defined subtree of the AST.

          This function is used as a basis for steps in AST isomophism tests.
       */
       // PC (7/9/2009): This function is not defined.
       // size_t numberOfNodesInSubtree();

     public:
       // [MK] Member function to access attached preprocessing info 
          AttachedPreprocessingInfoType*& getAttachedPreprocessingInfo(void);

       // DQ (4/10/2006): This is replaced by a better interface for attributes.
       // DQ (1/2/2006): Added attribute mechanism to SgLocatedNode
       // AstAttributeMechanism & attribute();

       // DQ (12/30/2009): This is moved to be a member function instead of a local inlined 
       // function in global scope.  This implementation better supports the optional use 
       // of smaller separate files generated by ROSETTA. The name is changed to both be
       // more clear and match the naming convention in ROSE.
       // inline Sg_File_Info* New_File_Info( SgLocatedNode *p)
       // Sg_File_Info* New_File_Info( SgLocatedNode *p);
          Sg_File_Info* generateMatchingFileInfo();

HEADER_END

HEADER_TOKEN_START
// DQ (3/24/2007): These are added from Rama's
// work on the lexical analysis of Fortran.  There will
// be similar values for C and C++ (and Python at some point).

// DQ (3/24/2007): We should put this in a namespace or rename it.
struct token_element
   {
     std::string token_lexeme;
     int token_id;
   };

// DQ (4/14/2007): New enum values are language specific to clarity.
// The "index + language_specific_offset" permits IR node enum values
// that will be grouped appropriately.
// DQ (3/24/2007): first versions of tokens using "ROSE_" prefix was judged overdone.
// Language specific enum values for Fortran 2003 tokens
// enum ROSE_Fortran_Identifiers
enum ROSE_Fortran_Keywords
   {
      FORTRAN_ABSTRACT = 0 + 0,
      FORTRAN_ACCESS = 1 + 0,
      FORTRAN_ACTION = 2 + 0,
      FORTRAN_ALLOCATE = 3 + 0,
      FORTRAN_ALLOCATABLE = 4 + 0,
      FORTRAN_ASSIGN = 5 + 0,
      FORTRAN_ASSOCIATE = 6 + 0,
      FORTRAN_ASYNCHRONOUS = 7 + 0,
      FORTRAN_BACKSPACE = 8 + 0,
      FORTRAN_BIND = 9 + 0,
      FORTRAN_BLANK = 10 + 0,
      FORTRAN_BLOCK_DATA = 11 + 0,
      FORTRAN_CALL = 12 + 0,
      FORTRAN_CHARACTER = 13 + 0,
      FORTRAN_CLASS = 14 + 0,
      FORTRAN_CLOSE = 15 + 0,
      FORTRAN_CONTINUE = 16 + 0,
      FORTRAN_CYCLE = 17 + 0,
      FORTRAN_CASE = 18 + 0,
      FORTRAN_COMMON = 19 + 0,
      FORTRAN_COMPLEX = 20 + 0,
      FORTRAN_CONTAINS = 21 + 0,
      FORTRAN_DEALLOCATE = 22 + 0,
      FORTRAN_DATA = 23 + 0,
      FORTRAN_DEFERRED = 24 + 0,
      FORTRAN_DELIM = 25 + 0,
      FORTRAN_DIMENSION = 26 + 0,
      FORTRAN_DO = 27 + 0,
      FORTRAN_DT = 28 + 0,
      FORTRAN_DOUBLEPRECISION = 29 + 0,
      FORTRAN_ENCODING = 30 + 0,
      FORTRAN_END_CASE = 31 + 0,
      FORTRAN_ENDDO = 32 + 0,
      FORTRAN_END_FILE = 33 + 0,
      FORTRAN_END_ENUM = 34 + 0,
      FORTRAN_END_INTERFACE = 35 + 0,
      FORTRAN_END_TYPE = 36 + 0,
      FORTRAN_ERR = 37 + 0,
      FORTRAN_ERRMSG = 38 + 0,
      FORTRAN_EXIT = 39 + 0,
      FORTRAN_ELSE = 40 + 0,
      FORTRAN_ELSEWHERE = 41 + 0,
      FORTRAN_ELSEIF = 42 + 0,
      FORTRAN_ENDIF = 43 + 0,
      FORTRAN_ENTRY = 44 + 0,
      FORTRAN_END = 45 + 0,
      FORTRAN_ENUM = 46 + 0,
      FORTRAN_ENUMERATOR = 47 + 0,
      FORTRAN_EQUIVALENCE = 48 + 0,
      FORTRAN_EXTERNAL = 49 + 0,
      FORTRAN_EXTENDS = 50 + 0,
      FORTRAN_FILE = 51 + 0,
      FORTRAN_FINAL = 52 + 0,
      FORTRAN_FMT = 53 + 0,
      FORTRAN_FORALL = 54 + 0,
      FORTRAN_FORM = 55 + 0,
      FORTRAN_FORMATTED = 56 + 0,
      FORTRAN_FORMAT = 57 + 0,
      FORTRAN_FLUSH = 58 + 0,
      FORTRAN_FUNCTION = 59 + 0,
      FORTRAN_GENERIC = 60 + 0,
      FORTRAN_GOTO = 61 + 0,
      FORTRAN_ID = 62 + 0,
      FORTRAN_IF = 63 + 0,
      FORTRAN_INQUIRE = 64 + 0,
      FORTRAN_INTEGER = 65 + 0,
      FORTRAN_IOMSG = 66 + 0,
      FORTRAN_IOSTAT = 67 + 0,
      FORTRAN_IMPLICIT = 68 + 0,
      FORTRAN_IMPLICIT_NONE = 69 + 0,
      FORTRAN_IMPORT = 70 + 0,
      FORTRAN_INTERFACE = 71 + 0,
      FORTRAN_INTENT = 72 + 0,
      FORTRAN_INTRINSIC = 73 + 0,
      FORTRAN_LEN = 74 + 0,
      FORTRAN_LOGICAL = 75 + 0,
      FORTRAN_KIND = 76 + 0,
      FORTRAN_MODULE_PROC = 77 + 0,
      FORTRAN_MODULE = 78 + 0,
      FORTRAN_NON_INTRINSIC = 79 + 0,
      FORTRAN_NON_OVERRIDABLE = 80 + 0,
      FORTRAN_NULL = 81 + 0,
      FORTRAN_NULLIFY = 82 + 0,
      FORTRAN_NAMELIST = 83 + 0,
      FORTRAN_NML = 84 + 0,
      FORTRAN_NONE = 85 + 0,
      FORTRAN_NOPASS = 86 + 0,
      FORTRAN_ONLY = 87 + 0,
      FORTRAN_OPEN = 88 + 0,
      FORTRAN_OPTIONAL = 89 + 0,
      FORTRAN_PARAMETER = 90 + 0,
      FORTRAN_PASS = 91 + 0,
      FORTRAN_PAUSE = 92 + 0,
      FORTRAN_POINTER = 93 + 0,
      FORTRAN_PRINT = 94 + 0,
      FORTRAN_PRIVATE = 95 + 0,
      FORTRAN_PROCEDURE = 96 + 0,
      FORTRAN_PROGRAM = 97 + 0,
      FORTRAN_PROTECTED = 98 + 0,
      FORTRAN_READ = 99 + 0,
      FORTRAN_REAL = 100 + 0,
      FORTRAN_RETURN = 101 + 0,
      FORTRAN_REWIND = 102 + 0,
      FORTRAN_ROUND = 103 + 0,
      FORTRAN_SELECTCASE = 104 + 0,
      FORTRAN_SELECTTYPE = 105 + 0,
      FORTRAN_SEQUENCE = 106 + 0,
      FORTRAN_SAVE = 107 + 0,
      FORTRAN_SIGN = 108 + 0,
      FORTRAN_SIZE = 109 + 0,
      FORTRAN_SOURCE = 110 + 0,
      FORTRAN_STAT = 111 + 0,
      FORTRAN_STOP = 112 + 0,
      FORTRAN_SUBROUTINE = 113 + 0,
      FORTRAN_TARGET = 114 + 0,
      FORTRAN_THEN = 115 + 0,
      FORTRAN_DERIVED_DECL = 116 + 0,
      FORTRAN_TYPEIS = 117 + 0,
      FORTRAN_UNFORMATTED = 118 + 0,
      FORTRAN_UNIT = 119 + 0,
      FORTRAN_USE = 120 + 0,
      FORTRAN_VALUE = 121 + 0,
      FORTRAN_VOLATILE = 122 + 0,
      FORTRAN_WAIT = 123 + 0,
      FORTRAN_WHERE = 124 + 0,
      FORTRAN_WRITE = 125 + 0
   };

// Language specific enum values for C and C++ tokens
enum ROSE_C_CXX_keywords
   {
      C_CXX_ASM = 0 + 500,
      C_CXX_AUTO = 1 + 500,
      C_CXX_BOOL = 2 + 500,
      C_CXX_BREAK = 3 + 500,
      C_CXX_CASE = 4 + 500,
      C_CXX_CATCH = 5 + 500,
      C_CXX_CHAR = 6 + 500,
      C_CXX_CLASS = 7 + 500,
      C_CXX_CONST = 8 + 500,
      C_CXX_CONSTCAST = 9 + 500,
      C_CXX_CONTINUE = 10 + 500,
      C_CXX_DEFAULT = 11 + 500,
      C_CXX_DEFINED = 12 + 500,
      C_CXX_DELETE = 13 + 500,
      C_CXX_DO = 14 + 500,
      C_CXX_DOUBLE = 15 + 500,
      C_CXX_DYNAMICCAST = 16 + 500,
      C_CXX_ELSE = 17 + 500,
      C_CXX_ENUM = 18 + 500,
      C_CXX_EXPLICIT = 19 + 500,
      C_CXX_EXPORT = 20 + 500,
      C_CXX_EXTERN = 21 + 500,
      C_CXX_FALSE = 22 + 500,
      C_CXX_FLOAT = 23 + 500,
      C_CXX_FOR = 24 + 500,
      C_CXX_FRIEND = 25 + 500,
      C_CXX_GOTO = 26 + 500,
      C_CXX_IF = 27 + 500,
      C_CXX_INLINE = 28 + 500,
      C_CXX_INT = 29 + 500,
      C_CXX_LONG = 30 + 500,
      C_CXX_MUTABLE = 31 + 500,
      C_CXX_NAMESPACE = 32 + 500,
      C_CXX_NEW = 33 + 500,
      C_CXX_OPERATOR = 34 + 500,
      C_CXX_PRIVATE = 35 + 500,
      C_CXX_PROTECTED = 36 + 500,
      C_CXX_PUBLIC = 37 + 500,
      C_CXX_REGISTER = 38 + 500,
      C_CXX_REINTERPRETCAST = 39 + 500,
      C_CXX_RETURN = 40 + 500,
      C_CXX_SHORT = 41 + 500,
      C_CXX_SIGNED = 42 + 500,
      C_CXX_SIZEOF = 43 + 500,
      C_CXX_STATIC = 44 + 500,
      C_CXX_STATICCAST = 45 + 500,
      C_CXX_STRUCT = 46 + 500,
      C_CXX_SWITCH = 47 + 500,
      C_CXX_TEMPLATE = 48 + 500,
      C_CXX_THIS = 49 + 500,
      C_CXX_THROW = 50 + 500,
      C_CXX_TRY = 51 + 500,
      C_CXX_TRUE = 52 + 500,
      C_CXX_TYPEDEF = 53 + 500,
      C_CXX_TYPEID = 54 + 500,
      C_CXX_TYPENAME = 55 + 500,
      C_CXX_UNION = 56 + 500,
      C_CXX_UNSIGNED = 57 + 500,
      C_CXX_USING = 58 + 500,
      C_CXX_VIRTUAL = 59 + 500,
      C_CXX_VOID = 60 + 500,
      C_CXX_VOLATILE = 61 + 500,
      C_CXX_WCHART = 62 + 500,
      C_CXX_WHILE = 63 + 500
   };

// Langauge specific token enums for Fortran intrinsic operators
enum ROSE_Fortran_Operators
   {
      FORTRAN_INTRINSIC_PLUS = 0 + 10000,
      FORTRAN_INTRINSIC_MINUS = 1 + 10000,
      FORTRAN_INTRINSIC_POWER = 2 + 10000,
      FORTRAN_INTRINSIC_CONCAT = 3 + 10000,
      FORTRAN_INTRINSIC_TIMES = 4 + 10000,
      FORTRAN_INTRINSIC_DIVIDE = 5 + 10000,
      FORTRAN_INTRINSIC_AND = 6 + 10000,
      FORTRAN_INTRINSIC_OR = 7 + 10000,
      FORTRAN_INTRINSIC_EQV = 8 + 10000,
      FORTRAN_INTRINSIC_NEQV = 9 + 10000,
      FORTRAN_INTRINSIC_EQ = 10 + 10000,
      FORTRAN_INTRINSIC_NE = 11 + 10000,
      FORTRAN_INTRINSIC_GE = 12 + 10000,
      FORTRAN_INTRINSIC_LE = 13 + 10000,
      FORTRAN_INTRINSIC_LT = 14 + 10000,
      FORTRAN_INTRINSIC_GT = 15 + 10000,
      FORTRAN_INTRINSIC_NOT = 16 + 10000,
      FORTRAN_INTRINSIC_OLDEQ = 17 + 10000,
      FORTRAN_INTRINSIC_OLDNE = 18 + 10000,
      FORTRAN_INTRINSIC_OLDGE = 19 + 10000,
      FORTRAN_INTRINSIC_OLDLE = 20 + 10000,
      FORTRAN_INTRINSIC_OLDLT = 21 + 10000,
      FORTRAN_INTRINSIC_OLDGT = 22 + 10000
   };

enum ROSE_C_CXX_Operators
   {
      C_CXX_AND = 0 + 50000,
      C_CXX_ANDAND = 1 + 50000,
      C_CXX_ASSIGN = 2 + 50000,
      C_CXX_ANDASSIGN = 3 + 50000,
      C_CXX_OR = 4 + 50000,
      C_CXX_ORASSIGN = 5 + 50000,
      C_CXX_XOR = 6 + 50000,
      C_CXX_XORASSIGN = 7 + 50000,
      C_CXX_COMMA = 8 + 50000,
      C_CXX_COLON = 9 + 50000,
      C_CXX_DIVIDE = 10 + 50000,
      C_CXX_DIVIDEASSIGN = 11 + 50000,
      C_CXX_DOT = 12 + 50000,
      C_CXX_DOTSTAR = 13 + 50000,
      C_CXX_ELLIPSIS = 14 + 50000,
      C_CXX_EQUAL = 15 + 50000,
      C_CXX_GREATER = 16 + 50000,
      C_CXX_GREATEREQUAL = 17 + 50000,
      C_CXX_LEFTBRACE = 18 + 50000,
      C_CXX_LESS = 19 + 50000,
      C_CXX_LESSEQUAL = 20 + 50000,
      C_CXX_LEFTPAREN = 21 + 50000,
      C_CXX_LEFTBRACKET = 22 + 50000,
      C_CXX_MINUS = 23 + 50000,
      C_CXX_MINUSASSIGN = 24 + 50000,
      C_CXX_MINUSMINUS = 25 + 50000,
      C_CXX_PERCENT = 26 + 50000,
      C_CXX_PERCENTASSIGN = 27 + 50000,
      C_CXX_NOT = 28 + 50000,
      C_CXX_NOTEQUAL = 29 + 50000,
      C_CXX_OROR = 30 + 50000,
      C_CXX_PLUS = 31 + 50000,
      C_CXX_PLUSASSIGN = 32 + 50000,
      C_CXX_PLUSPLUS = 33 + 50000,
      C_CXX_ARROW = 34 + 50000,
      C_CXX_ARROWSTAR = 35 + 50000,
      C_CXX_QUESTION_MARK = 36 + 50000,
      C_CXX_RIGHTBRACE = 37 + 50000,
      C_CXX_RIGHTPAREN = 38 + 50000,
      C_CXX_RIGHTBRACKET = 39 + 50000,
      C_CXX_COLON_COLON = 40 + 50000,
      C_CXX_SEMICOLON = 41 + 50000,
      C_CXX_SHIFTLEFT = 42 + 50000,
      C_CXX_SHIFTLEFTASSIGN = 43 + 50000,
      C_CXX_SHIFTRIGHT = 44 + 50000,
      C_CXX_SHIFTRIGHTASSIGN = 45 + 50000,
      C_CXX_STAR = 46 + 50000,
      C_CXX_COMPL = 47 + 50000,
      C_CXX_STARASSIGN = 48 + 50000,
      C_CXX_POUND_POUND = 49 + 50000,
      C_CXX_POUND = 50 + 50000,
      C_CXX_AND_ALT = 51 + 50000,
      C_CXX_ANDASSIGN_ALT = 52 + 50000,
      C_CXX_OR_ALT = 53 + 50000,
      C_CXX_ORASSIGN_ALT = 54 + 50000,
      C_CXX_XOR_ALT = 55 + 50000,
      C_CXX_XORASSIGN_ALT = 56 + 50000,
      C_CXX_LEFTBRACE_ALT = 57 + 50000,
      C_CXX_LEFTBRACKET_ALT = 58 + 50000,
      C_CXX_NOT_ALT = 59 + 50000,
      C_CXX_NOTEQUAL_ALT = 60 + 50000,
      C_CXX_RIGHTBRACE_ALT = 61 + 50000,
      C_CXX_RIGHTBRACKET_ALT = 62 + 50000,
      C_CXX_COMPL_ALT = 63 + 50000,
      C_CXX_POUND_POUND_ALT = 64 + 50000,
      C_CXX_POUND_ALT = 65 + 50000,
      C_CXX_OR_TRIGRAPH = 66 + 50000,
      C_CXX_XOR_TRIGRAPH = 67 + 50000,
      C_CXX_LEFTBRACE_TRIGRAPH = 68 + 50000,
      C_CXX_LEFTBRACKET_TRIGRAPH = 69 + 50000,
      C_CXX_RIGHTBRACE_TRIGRAPH = 70 + 50000,
      C_CXX_RIGHTBRACKET_TRIGRAPH = 71 + 50000,
      C_CXX_COMPL_TRIGRAPH = 72 + 50000,
      C_CXX_POUND_POUND_TRIGRAPH = 73 + 50000,
      C_CXX_POUND_TRIGRAPH = 74 + 50000
   };

// Fortran specific additional token classifications
enum ROSE_Fortran_Additional_Info
   {
      FORTRAN_COMMENTS = 0 + 100000,
      FORTRAN_STRING_LITERALS = 1 + 100000,
      FORTRAN_IDENTIFIER = 2 + 100000,
      FORTRAN_UNIDENTIFIED_TOKEN = 3 + 100000,
      FORTRAN_ERROR = 4 + 100000
   };

     public:
       // DQ (4/14/2007): Modified to make this a const array
          static const token_element ROSE_Fortran_keyword_map[127];

HEADER_TOKEN_END


HEADER_LOCATED_NODE_SUPPORT_START
HEADER_LOCATED_NODE_SUPPORT_END

HEADER_RENAME_PAIR_START

          bool isRename() const;

HEADER_RENAME_PAIR_END

HEADER_INTERFACE_BODY_START

HEADER_INTERFACE_BODY_END

HEADER_HEADER_FILE_BODY_START

HEADER_HEADER_FILE_BODY_END


// *************************************************
// *************************************************
//                  Source Code
// *************************************************
// *************************************************

SOURCE_START

#if 0
// DQ (4/10/2006): This is replaced by a better interface for attributes.
AstAttributeMechanism & 
SgLocatedNode::attribute()
   {
  // DQ (1/2/2006): This function preserves as much of
  // the syntax of attribute being a public data member.
     if (p_attribute == NULL)
        {
          printf ("Error: p_attribute == NULL  (node = %s) \n",class_name().c_str());
          ROSE_ASSERT(false);
        }

     return *p_attribute;
   }
#endif

#if 0
const char*
SgLocatedNode::getFileName ()
   {
  // Function added by DQ (7/22/2001)

     const char* fileName = "NO NAME FILE";
  // Sometimes the locatedNode doesn't have a SgFile object 
  // (likely because it is part of a parent statement object)
     if (get_file_info() != NULL)
        {
          Sg_File_Info* fileInfo = get_file_info();
          ROSE_ASSERT (fileInfo != NULL);
          fileName = fileInfo->get_filename();
          ROSE_ASSERT (fileName != NULL);
        }

     return fileName;
   }
#endif

const std::string &
SgLocatedNode::getFilenameString() const
   {
  // Function added by DQ (2/2/2007) to replace depricated function const char* SgLocatedNode::getFileName()
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     return get_startOfConstruct()->get_filenameString();
   }

Sg_File_Info*
SgLocatedNode::get_file_info() const
   {
  // DQ (11/8/2006):
  // At this level in the hierarchy of AST IR nodes we want the get_file_info() 
  // member function to be mapped to the get_startOfConstruct() member function.
  // For SgExpression IR nodes we will map it to the get_operatorPosition() 
  // member function.
     return get_startOfConstruct();
   }

void
SgLocatedNode::set_file_info( Sg_File_Info* fileInfo )
   {
  // DQ (5.14.2006): Allow input to be NULL so that we can safely reset the Sg_File_Info pointer.
  // ROSE_ASSERT (fileInfo != NULL);
     set_startOfConstruct(fileInfo);
#ifndef REMOVE_SET_PARENT_FUNCTION
     fileInfo->set_parent(this);
#endif
   }

void
SgLocatedNode::post_construction_initialization()
   {
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

  // Make sure that the pointer to the data structure storing the
  // attached PreprocessingInfo objects is NULL
     p_attachedPreprocessingInfoPtr = NULL;

  // DQ (12/17/2006): Added semantics to set the parent of any avaliable Sg_File_Info objects.
     if (p_startOfConstruct != NULL)
        {
          p_startOfConstruct->set_parent(this);
        }

  // DQ (12/17/2006): Added semantics to set the parent of any avaliable Sg_File_Info objects.
     if (p_endOfConstruct != NULL)
        {
          p_endOfConstruct->set_parent(this);
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::setCompilerGenerated ()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->setCompilerGenerated();
     get_endOfConstruct()->setCompilerGenerated();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          expression->get_operatorPosition()->setCompilerGenerated();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::unsetCompilerGenerated()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->unsetCompilerGenerated();
     get_endOfConstruct()->unsetCompilerGenerated();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          ROSE_ASSERT(expression->get_operatorPosition() != NULL);
          expression->get_operatorPosition()->unsetCompilerGenerated();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::setFrontendSpecific ()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->setFrontendSpecific();
     get_endOfConstruct()->setFrontendSpecific();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          expression->get_operatorPosition()->setFrontendSpecific();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::unsetFrontendSpecific()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->unsetFrontendSpecific();
     get_endOfConstruct()->unsetFrontendSpecific();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          ROSE_ASSERT(expression->get_operatorPosition() != NULL);
          expression->get_operatorPosition()->unsetFrontendSpecific();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::setSourcePositionUnavailableInFrontend ()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->setSourcePositionUnavailableInFrontend();
     get_endOfConstruct()->setSourcePositionUnavailableInFrontend();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          expression->get_operatorPosition()->setSourcePositionUnavailableInFrontend();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::unsetSourcePositionUnavailableInFrontend()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->unsetSourcePositionUnavailableInFrontend();
     get_endOfConstruct()->unsetSourcePositionUnavailableInFrontend();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          ROSE_ASSERT(expression->get_operatorPosition() != NULL);
          expression->get_operatorPosition()->unsetSourcePositionUnavailableInFrontend();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::setOutputInCodeGeneration ()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->setOutputInCodeGeneration();
     get_endOfConstruct()->setOutputInCodeGeneration();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          expression->get_operatorPosition()->setOutputInCodeGeneration();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::unsetOutputInCodeGeneration()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->unsetOutputInCodeGeneration();
     get_endOfConstruct()->unsetOutputInCodeGeneration();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          ROSE_ASSERT(expression->get_operatorPosition() != NULL);
          expression->get_operatorPosition()->unsetOutputInCodeGeneration();
        }
   }


#if 0
SgLocatedNode::~SgLocatedNode()
   {
  // Some expressions are initialized with NULL_FILE (which is a null Sg_File_Info pointer)
  // so we can't assert that p_file_info != NULL.
  // ROSE_ASSERT(p_file_info != NULL);

#if 0
  // At the moment uncommenting this will cause SAGE 3 to crash 
  // (SAGE 2 never tried to cleanup memory leaks and is it not 
  // done well in SAGE 3 yet either, though it is started).
     ROSE_ASSERT(get_file_info()->getReferenceCount() > 0);
     get_file_info()->decrementReferenceCount();
     if (get_file_info()->getReferenceCount() == 0)
        {
       // We need to add reference counting to Sg_File_Info objects 
       // before we can properly cleanup the meory that they allocate
          delete p _ file _ info;
        }
#endif

  // p_file_info = NULL;
     set_startOfConstruct(NULL);
     set_endOfConstruct(NULL);
   } 
#endif

#if 0
void SgLocatedNode::directives(ostream& os)
   {
#if 0
     if (p_file_info) 
        {
          p_file_info->output(os);
        }
     output_pragma(os);	

#if MEIDEBUG 
     SgExpression *e=isSgExpression(this);
     if(e && e->get_is_lvalue())
        {
          os << "<a_LVAL>";
        }
#endif
#else
     printf ("ERROR: not yet implemented within SAGE3! \n");
     abort();
#endif
   }
#endif

#if 0
void 
SgLocatedNode::setlineNumber(unsigned long new_line)
   {
     if (p_file_info == 0) 
        {
          p_file_info = new Sg_File_Info(0, new_line, 0);
        }
       else 
        {
          p_file_info->set_line(new_line);
        }
   }
#endif

#if 0
void 
SgLocatedNode::delete_file_info() 
   {
     if (p_file_info != 0)
        {
          p_file_info->deregister_node(this);
          p_file_info = 0;
        }
   }
#endif

#if 0
bool
SgLocatedNode::_print(int depth) const
   {
     if (SgNode::_print(depth))
        {
          Sg_print_info().output_field(get_file_info(),depth+1);
          return true;
        }

     return false;
   }
#endif

// [MK] Member function to attach PreprocessingInfo object to the node
void
SgLocatedNode::addToAttachedPreprocessingInfo(
     PreprocessingInfo *prepInfoPtr,
  // PositionOfPreprocessingInfoInListType locationInList )
     PreprocessingInfo::RelativePositionType locationInList )
   {
  // DQ (11/23/2008): Is this comment still true?  Is there something to fix here?
  // There are places in ROSE where the comments is added before the statement
  // though most commonly the comment is added after the statement.  So I think that
  // this interface is required adn that it need not be fixed.

  // DQ (9/19/2003)
  // This function takes a PreprocessingInfo::RelativePositionType type parameter which
  // makes no since because it is used only to determine if the new comment/directive is
  // added to the front or back of the current list of comments/directives.  It does not 
  // change the value of the PreprocessingInfo::RelativePositionType field in the
  // PreprocessingInfo object that it takes for the other parameter (nor should it).
  // This function was poorly desinged in the first place and needs to be fixed!!!
  // printf ("In LocatedNode::addToAttachedPreprocessingInfo(PreprocessingInfo,PreprocessingInfo::RelativePositionType): FIX INTERFACE!!!! \n");

     ROSE_ASSERT(prepInfoPtr != NULL);

#if 0
     printf ("Current node is a %s: prepInfoPtr->stringPointer = %s \n",class_name().c_str(),prepInfoPtr->stringPointer);
#endif

  // Nodes that should not have comments attached (since they are not unparsed)
     ROSE_ASSERT (dynamic_cast<SgForInitStatement*>(this) == NULL);
     ROSE_ASSERT (dynamic_cast<SgTypedefSeq*>(this) == NULL);
     ROSE_ASSERT (dynamic_cast<SgCatchStatementSeq*>(this) == NULL);

  // These should not be used but are are least handled in the unparser (if not debugged)
  // ROSE_ASSERT (dynamic_cast<SgFunctionParameterList*>(this) == NULL);
     ROSE_ASSERT (dynamic_cast<SgCtorInitializerList*>(this) == NULL);

     SgFunctionParameterList* functionParameterList = isSgFunctionParameterList(this);
     if (functionParameterList != NULL)
        {
          printf ("SgFunctionParameterList are not typically associated with comments or CPP directives \n");
          ROSE_ASSERT(get_startOfConstruct() != NULL);
          ROSE_ASSERT(get_endOfConstruct() != NULL);
        }

  // Create data structure for storing the attached PreprocessingInfo objects, if necessary
     if (p_attachedPreprocessingInfoPtr == NULL)
        {
          p_attachedPreprocessingInfoPtr = new AttachedPreprocessingInfoType;
          ROSE_ASSERT(p_attachedPreprocessingInfoPtr != NULL);
        }

  // Add the current PreprocessingInfo object
     switch (locationInList)
        {
          case PreprocessingInfo::defaultValue:
          case PreprocessingInfo::undef:
               printf ("Error: defaultValue or undef value found in switch statement \n");
               ROSE_ASSERT(false);
               break;

          case PreprocessingInfo::before:
               p_attachedPreprocessingInfoPtr->insert(p_attachedPreprocessingInfoPtr->begin(),prepInfoPtr);
               break;

          case PreprocessingInfo::after:
            // (9/10/2003) DQ: Force new comments to be attached closest to the target statement
               p_attachedPreprocessingInfoPtr->push_back(prepInfoPtr);
               break;

          default:
               printf ("Error: default found in switch statement \n");
               ROSE_ASSERT(false);
        }
   }

// [MK] Member function to return attached PreprocessingInfo objects
AttachedPreprocessingInfoType*&
SgLocatedNode::getAttachedPreprocessingInfo(void)
   {
     return p_attachedPreprocessingInfoPtr;
   }

Sg_File_Info*
SgLocatedNode::generateMatchingFileInfo()
   {
  // DQ (12/30/2009): Added this function to remove previous global function in large 
  // ROSETTA generated file so that we could support smaller ROSETTA generated files.

  // DQ (11/20/2004): Modified to provide more accurate information, use the 
  // copy constructor instead of the constructor that takes a file name.
  // return new Sg_File_Info( p->get_file_info()->get_filename());

  // DQ (11/6/2006): startOfConstruct is the one Sg_File_Info that will always exist and must exist.
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     Sg_File_Info* returnFileInfo = new Sg_File_Info(*(get_startOfConstruct()));
     ROSE_ASSERT(returnFileInfo != NULL);

  // printf ("In New_File_Info: returnFileInfo = %p \n",returnFileInfo);

     return returnFileInfo;
   }

SOURCE_END



SOURCE_TOKEN_START
/*
Some assumptions:
We know that keywords in FORTRAN can be separated by whitespace
Our lexer handles end if as two identifiers with lexemes "end", "if"
A later pass can coalese these two identifers into one token 
   of type ROSE_IDENTIFIER
   of lexeme "end if"
Look at the the coalese tokens phase
*/

// DQ (4/14/2007): Modified to use new enum values
// DQ (3/24/2007): I would like to make this a const array (double check with Rama).
const SgToken::token_element SgToken::ROSE_Fortran_keyword_map[127] = 
   {
      {"abstract",             SgToken::FORTRAN_ABSTRACT}, 
      {"access",               SgToken::FORTRAN_ACCESS}, 
      {"action",               SgToken::FORTRAN_ACTION}, 
      {"abstractinterface",    SgToken::FORTRAN_INTERFACE},           /*   GFORTRAN/G95 equivalent is ST_INTERFACE       */
      {"allocate",             SgToken::FORTRAN_ALLOCATE},            /*   GFORTRAN/G95 equivalent is ST_ALLOCATE        */
      {"allocatable",          SgToken::FORTRAN_ALLOCATABLE},         /*   GFORTRAN/G95 equivalent is ST_ALLOCATABLE     */
      {"assign",               SgToken::FORTRAN_ASSIGN},              /*   GFORTRAN/G95 equivalent is ST_ASSIGN          */
      {"associate",            SgToken::FORTRAN_ASSOCIATE}, 
      {"asynchronous",         SgToken::FORTRAN_ASYNCHRONOUS},        /*   GFORTRAN/G95 equivalent is ST_ASYNCHRONOUS    */
      {"backspace",            SgToken::FORTRAN_BACKSPACE},           /*   GFORTRAN/G95 equivalent is ST_BACKSPACE       */
      {"bind",                 SgToken::FORTRAN_BIND},                /*   GFORTRAN/G95 equivalent is ST_BIND            */
      {"blank",                SgToken::FORTRAN_BLANK},         
      {"blockdata",            SgToken::FORTRAN_BLOCK_DATA},          /*   GFORTRAN/G95 equivalent is ST_BLOCK_DATA      */
      {"call",                 SgToken::FORTRAN_CALL},                /*   GFORTRAN/G95 equivalent is ST_CALL            */
      {"character",            SgToken::FORTRAN_CHARACTER}, 
      {"class",                SgToken::FORTRAN_CLASS},
      {"close",                SgToken::FORTRAN_CLOSE},               /*   GFORTRAN/G95 equivalent is ST_CLOSE           */
      {"continue",             SgToken::FORTRAN_CONTINUE},            /*   GFORTRAN/G95 equivalent is ST_CONTINUE        */
      {"cycle",                SgToken::FORTRAN_CYCLE},               /*   GFORTRAN/G95 equivalent is ST_CYCLE           */
      {"case",                 SgToken::FORTRAN_CASE},                /*   GFORTRAN/G95 equivalent is ST_CASE            */
      {"common",               SgToken::FORTRAN_COMMON},              /*   GFORTRAN/G95 equivalent is ST_COMMON          */
      {"complex",              SgToken::FORTRAN_COMPLEX},
      {"contains",             SgToken::FORTRAN_CONTAINS},            /*   GFORTRAN/G95 equivalent is ST_CONTAINS        */
      {"deallocate",           SgToken::FORTRAN_DEALLOCATE},          /*   GFORTRAN/G95 equivalent is ST_DEALLOCATE      */
      {"data",                 SgToken::FORTRAN_DATA},                /*   GFORTRAN/G95 equivalent is ST_DATA            */
      {"deferred",             SgToken::FORTRAN_DEFERRED},  
      {"delim",                SgToken::FORTRAN_DELIM},  
      {"dimension",            SgToken::FORTRAN_DIMENSION},           /*   GFORTRAN/G95 equivalent is ST_DIMENSION       */
      {"do",                   SgToken::FORTRAN_DO},
      {"dt",                   SgToken::FORTRAN_DT},
      {"doubleprecision",      SgToken::FORTRAN_DOUBLEPRECISION},
      {"encoding",             SgToken::FORTRAN_ENCODING},            /*   GFORTRAN/G95 equivalent is ST_END_FILE        */
      {"endcase",              SgToken::FORTRAN_END_CASE},            /*   GFORTRAN/G95 equivalent is ST_END_FILE        */
      {"enddo",                SgToken::FORTRAN_ENDDO},               /*   GFORTRAN/G95 equivalent is ST_END_FILE        */
      {"endfile",              SgToken::FORTRAN_END_FILE},            /*   GFORTRAN/G95 equivalent is ST_END_FILE        */
      {"endenum",              SgToken::FORTRAN_END_ENUM}, 
      {"endinterface",         SgToken::FORTRAN_END_INTERFACE}, 
      {"endtype",              SgToken::FORTRAN_END_TYPE}, 
      {"err",                  SgToken::FORTRAN_ERR}, 
      {"errmsg",               SgToken::FORTRAN_ERRMSG}, 
      {"exit",                 SgToken::FORTRAN_EXIT},                /*   GFORTRAN/G95 equivalent is ST_EXIT            */
      {"else",                 SgToken::FORTRAN_ELSE},                /*   GFORTRAN/G95 equivalent is ST_ELSE            */
      {"elsewhere",            SgToken::FORTRAN_ELSEWHERE},           /*   GFORTRAN/G95 equivalent is ST_ELSEWHERE       */
      {"elseif",               SgToken::FORTRAN_ELSEIF},              /*   GFORTRAN/G95 equivalent is ST_ELSEIF          */
      {"endif",                SgToken::FORTRAN_ENDIF},
      {"entry% ",              SgToken::FORTRAN_ENTRY},               /*   GFORTRAN/G95 equivalent is ST_ENTRY           */
      {"end",                  SgToken::FORTRAN_END},             
      {"enum",                 SgToken::FORTRAN_ENUM},                /*   GFORTRAN/G95 equivalent is ST_ENUM            */
      {"enumerator",           SgToken::FORTRAN_ENUMERATOR},          /*   GFORTRAN/G95 equivalent is ST_ENUMERATOR      */
      {"equivalence",          SgToken::FORTRAN_EQUIVALENCE},         /*   GFORTRAN/G95 equivalent is ST_EQUIVALENCE     */
      {"external",             SgToken::FORTRAN_EXTERNAL},            /*   GFORTRAN/G95 equivalent is ST_EXTERNAL        */
      {"extends",              SgToken::FORTRAN_EXTENDS}, 
      {"file",                 SgToken::FORTRAN_FILE}, 
      {"final",                SgToken::FORTRAN_FINAL},               /*   GFORTRAN/G95 equivalent is ST_FORALL          */
      {"fmt",                  SgToken::FORTRAN_FMT},                 /*   GFORTRAN/G95 equivalent is ST_FORALL          */
      {"forall",               SgToken::FORTRAN_FORALL},              /*   GFORTRAN/G95 equivalent is ST_FORALL          */
      {"form",                 SgToken::FORTRAN_FORM},  
      {"formatted",            SgToken::FORTRAN_FORMATTED},  
      {"format",               SgToken::FORTRAN_FORMAT},              /*   GFORTRAN/G95 equivalent is ST_FORMAT          */
      {"flush",                SgToken::FORTRAN_FLUSH},               /*   GFORTRAN/G95 equivalent is ST_FLUSH           */
      {"function",             SgToken::FORTRAN_FUNCTION},         
      {"generic",              SgToken::FORTRAN_GENERIC},             /*   GFORTRAN/G95 equivalent is ST_GOTO            */
      {"goto",                 SgToken::FORTRAN_GOTO},                /*   GFORTRAN/G95 equivalent is ST_GOTO            */
      {"id",                   SgToken::FORTRAN_ID},                  /*   GFORTRAN/G95 equivalent is ST_IF,             */
      {"if",                   SgToken::FORTRAN_IF},                  /*   GFORTRAN/G95 equivalent is ST_IF,             */
      {"inquire",              SgToken::FORTRAN_INQUIRE},             /*   GFORTRAN/G95 equivalent is ST_INQUIRE         */
      {"integer",              SgToken::FORTRAN_INTEGER},             /*   GFORTRAN/G95 equivalent is ST_INQUIRE         */
      {"iomsg",                SgToken::FORTRAN_IOMSG}, 
      {"iostat",               SgToken::FORTRAN_IOSTAT}, 
      {"implicit",             SgToken::FORTRAN_IMPLICIT},            /*   GFORTRAN/G95 equivalent is ST_IMPLICIT        */
      {"implicitnone",         SgToken::FORTRAN_IMPLICIT_NONE},       /*   GFORTRAN/G95 equivalent is ST_IMPLICIT_NONE   */
      {"import",               SgToken::FORTRAN_IMPORT},              /*   GFORTRAN/G95 equivalent is ST_IMPORT          */
      {"interface",            SgToken::FORTRAN_INTERFACE},           /*   GFORTRAN/G95 equivalent is ST_INTERFACE       */
      {"intent",               SgToken::FORTRAN_INTENT},              /*   GFORTRAN/G95 equivalent is ST_INTENT          */
      {"intrinsic",            SgToken::FORTRAN_INTRINSIC},           /*   GFORTRAN/G95 equivalent is ST_INTRINSIC       */
      {"len",                  SgToken::FORTRAN_LEN},         
      {"logical",              SgToken::FORTRAN_LOGICAL},          
      {"kind",                 SgToken::FORTRAN_KIND}, 
      {"moduleprocedure",      SgToken::FORTRAN_MODULE_PROC},         /*   GFORTRAN/G95 equivalent is ST_E_MODULE_PROC   */
      {"module",               SgToken::FORTRAN_MODULE},              /*   GFORTRAN/G95 equivalent is ST_MODULE          */
      {"non_intrinsic",        SgToken::FORTRAN_NON_INTRINSIC},       /*   GFORTRAN/G95 equivalent is ST_NULLIFY         */
      {"non_overridable",      SgToken::FORTRAN_NON_OVERRIDABLE},     /*   GFORTRAN/G95 equivalent is ST_NULLIFY         */
      {"null",                 SgToken::FORTRAN_NULL},
      {"nullify",              SgToken::FORTRAN_NULLIFY},             /*   GFORTRAN/G95 equivalent is ST_NULLIFY         */
      {"namelist",             SgToken::FORTRAN_NAMELIST},            /*   GFORTRAN/G95 equivalent is ST_NAMELIST        */
      {"nml",                  SgToken::FORTRAN_NML},
      {"none",                 SgToken::FORTRAN_NONE},                /*   GFORTRAN/G95 equivalent is ST_NONE            */
      {"nopass",               SgToken::FORTRAN_NOPASS},  
      {"only",                 SgToken::FORTRAN_ONLY},                /*   GFORTRAN/G95 equivalent is ST_OPEN            */
      {"open",                 SgToken::FORTRAN_OPEN},                /*   GFORTRAN/G95 equivalent is ST_OPEN            */
      {"optional",             SgToken::FORTRAN_OPTIONAL},            /*   GFORTRAN/G95 equivalent is ST_OPTIONAL        */
      {"parameter",            SgToken::FORTRAN_PARAMETER},           /*   GFORTRAN/G95 equivalent is ST_PARAMETER       */
      {"pass",                 SgToken::FORTRAN_PASS}, 
      {"pause",                SgToken::FORTRAN_PAUSE},               /*   GFORTRAN/G95 equivalent is ST_PAUSE           */
      {"pointer",              SgToken::FORTRAN_POINTER},             /*   GFORTRAN/G95 equivalent is ST_POINTER         */
      {"print",                SgToken::FORTRAN_PRINT},               /*   GFORTRAN/G95 equivalent is ST_PRINT           */
      {"private",              SgToken::FORTRAN_PRIVATE},             /*   GFORTRAN/G95 equivalent is ST_PRINT           */
      {"procedure",            SgToken::FORTRAN_PROCEDURE},           /*   GFORTRAN/G95 equivalent is ST_DATA_DECL       */
      {"program",              SgToken::FORTRAN_PROGRAM},             /*   GFORTRAN/G95 equivalent is ST_PROGRAM         */
      {"protected",            SgToken::FORTRAN_PROTECTED},           /*   GFORTRAN/G95 equivalent is ST_DATA_DECL       */
      {"read",                 SgToken::FORTRAN_READ},                /*   GFORTRAN/G95 equivalent is ST_READ            */
      {"real",                 SgToken::FORTRAN_REAL}, 
      {"return",               SgToken::FORTRAN_RETURN},              /*   GFORTRAN/G95 equivalent is ST_RETURN          */
      {"rewind",               SgToken::FORTRAN_REWIND},              /*   GFORTRAN/G95 equivalent is ST_REWIND          */
      {"round",                SgToken::FORTRAN_ROUND},  
      {"selectcase",           SgToken::FORTRAN_SELECTCASE}, 
      {"selecttype",           SgToken::FORTRAN_SELECTTYPE}, 
      {"sequence",             SgToken::FORTRAN_SEQUENCE},            /*   GFORTRAN/G95 equivalent is ST_SEQUENCE        */
      {"save",                 SgToken::FORTRAN_SAVE},                /*   GFORTRAN/G95 equivalent is ST_SAVE            */
      {"sign",                 SgToken::FORTRAN_SIGN}, 
      {"size",                 SgToken::FORTRAN_SIZE}, 
      {"source",               SgToken::FORTRAN_SOURCE},              /*   GFORTRAN/G95 equivalent is ST_SAVE            */
      {"stat",                 SgToken::FORTRAN_STAT}, 
      {"stop",                 SgToken::FORTRAN_STOP},                /*   GFORTRAN/G95 equivalent is ST_STOP            */
      {"subroutine",           SgToken::FORTRAN_SUBROUTINE},
      {"target",               SgToken::FORTRAN_TARGET},              /*   GFORTRAN/G95 equivalent is ST_TARGET          */
      {"then",                 SgToken::FORTRAN_THEN}, 
      {"type",                 SgToken::FORTRAN_DERIVED_DECL},        /*   GFORTRAN/G95 equivalent is ST_DERIVED_DECL    */
      {"typeis",               SgToken::FORTRAN_TYPEIS}, 
      {"unformatted",          SgToken::FORTRAN_UNFORMATTED}, 
      {"unit",                 SgToken::FORTRAN_UNIT}, 
      {"use",                  SgToken::FORTRAN_USE},                 /*   GFORTRAN/G95 equivalent is ST_USE             */
      {"value",                SgToken::FORTRAN_VALUE},               /*   GFORTRAN/G95 equivalent is ST_VALUE           */
      {"volatile",             SgToken::FORTRAN_VOLATILE},            /*   GFORTRAN/G95 equivalent is ST_VOLATILE        */
      {"wait",                 SgToken::FORTRAN_WAIT},                /*   GFORTRAN/G95 equivalent is ST_WAIT            */
      {"where",                SgToken::FORTRAN_WHERE},               /*   GFORTRAN/G95 equivalent is ST_WHERE,          */
      {"write",                SgToken::FORTRAN_WRITE}                /*   GFORTRAN/G95 equivalent is ST_WRITE           */
   };


SOURCE_TOKEN_END

SOURCE_LOCATED_NODE_SUPPORT_START
SOURCE_LOCATED_NODE_SUPPORT_END

SOURCE_RENAME_PAIR_START

bool
SgRenamePair::isRename() const
   {
  // This a treated as a valid renaming if the names are different.
     return (p_local_name != p_use_name);
   }

SOURCE_RENAME_PAIR_END

SOURCE_INTERFACE_BODY_START

SOURCE_INTERFACE_BODY_END

SOURCE_HEADER_FILE_BODY_START

SOURCE_HEADER_FILE_BODY_END
