MODULE GENERATED_MODULE
  USE ISO_C_BINDING
  USE OP2_C
  USE cudaConfigurationParams
  USE CUDAFOR
  TYPE  :: adt_calc_opDatDimensions
  INTEGER(kind=4) :: opDat1Dimension
  INTEGER(kind=4) :: opDat2Dimension
  INTEGER(kind=4) :: opDat3Dimension
  INTEGER(kind=4) :: opDat4Dimension
  INTEGER(kind=4) :: opDat5Dimension
  INTEGER(kind=4) :: opDat6Dimension
  END TYPE adt_calc_opDatDimensions

  TYPE  :: adt_calc_variableSizes
  INTEGER(kind=4) :: opDat1Size
  INTEGER(kind=4) :: pindMaps1Size
  INTEGER(kind=4) :: pMaps1Size
  INTEGER(kind=4) :: pMaps2Size
  INTEGER(kind=4) :: pMaps3Size
  INTEGER(kind=4) :: pMaps4Size
  INTEGER(kind=4) :: opDat5Size
  INTEGER(kind=4) :: opDat6Size
  INTEGER(kind=4) :: pblkMapSize
  INTEGER(kind=4) :: pindOffsSize
  INTEGER(kind=4) :: pindSizesSize
  INTEGER(kind=4) :: pnelemsSize
  INTEGER(kind=4) :: pnthrcolSize
  INTEGER(kind=4) :: poffsetSize
  INTEGER(kind=4) :: pthrcolSize
  END TYPE adt_calc_variableSizes

  TYPE  :: bres_calc_opDatDimensions
  INTEGER(kind=4) :: opDat1Dimension
  INTEGER(kind=4) :: opDat2Dimension
  INTEGER(kind=4) :: opDat3Dimension
  INTEGER(kind=4) :: opDat4Dimension
  INTEGER(kind=4) :: opDat5Dimension
  INTEGER(kind=4) :: opDat6Dimension
  END TYPE bres_calc_opDatDimensions

  TYPE  :: bres_calc_variableSizes
  INTEGER(kind=4) :: opDat1Size
  INTEGER(kind=4) :: opDat3Size
  INTEGER(kind=4) :: opDat4Size
  INTEGER(kind=4) :: opDat5Size
  INTEGER(kind=4) :: pindMaps1Size
  INTEGER(kind=4) :: pindMaps3Size
  INTEGER(kind=4) :: pindMaps4Size
  INTEGER(kind=4) :: pindMaps5Size
  INTEGER(kind=4) :: pMaps1Size
  INTEGER(kind=4) :: pMaps2Size
  INTEGER(kind=4) :: pMaps3Size
  INTEGER(kind=4) :: pMaps4Size
  INTEGER(kind=4) :: pMaps5Size
  INTEGER(kind=4) :: opDat6Size
  INTEGER(kind=4) :: pblkMapSize
  INTEGER(kind=4) :: pindOffsSize
  INTEGER(kind=4) :: pindSizesSize
  INTEGER(kind=4) :: pnelemsSize
  INTEGER(kind=4) :: pnthrcolSize
  INTEGER(kind=4) :: poffsetSize
  INTEGER(kind=4) :: pthrcolSize
  END TYPE bres_calc_variableSizes

  TYPE  :: res_calc_opDatDimensions
  INTEGER(kind=4) :: opDat1Dimension
  INTEGER(kind=4) :: opDat2Dimension
  INTEGER(kind=4) :: opDat3Dimension
  INTEGER(kind=4) :: opDat4Dimension
  INTEGER(kind=4) :: opDat5Dimension
  INTEGER(kind=4) :: opDat6Dimension
  INTEGER(kind=4) :: opDat7Dimension
  INTEGER(kind=4) :: opDat8Dimension
  INTEGER(kind=4) :: opDat9Dimension
  INTEGER(kind=4) :: opDat10Dimension
  END TYPE res_calc_opDatDimensions

  TYPE  :: res_calc_variableSizes
  INTEGER(kind=4) :: opDat1Size
  INTEGER(kind=4) :: opDat3Size
  INTEGER(kind=4) :: opDat5Size
  INTEGER(kind=4) :: opDat7Size
  INTEGER(kind=4) :: opDat9Size
  INTEGER(kind=4) :: pindMaps1Size
  INTEGER(kind=4) :: pindMaps3Size
  INTEGER(kind=4) :: pindMaps5Size
  INTEGER(kind=4) :: pindMaps7Size
  INTEGER(kind=4) :: pindMaps9Size
  INTEGER(kind=4) :: pMaps1Size
  INTEGER(kind=4) :: pMaps2Size
  INTEGER(kind=4) :: pMaps3Size
  INTEGER(kind=4) :: pMaps4Size
  INTEGER(kind=4) :: pMaps5Size
  INTEGER(kind=4) :: pMaps6Size
  INTEGER(kind=4) :: pMaps7Size
  INTEGER(kind=4) :: pMaps8Size
  INTEGER(kind=4) :: pMaps9Size
  INTEGER(kind=4) :: pMaps10Size
  INTEGER(kind=4) :: pblkMapSize
  INTEGER(kind=4) :: pindOffsSize
  INTEGER(kind=4) :: pindSizesSize
  INTEGER(kind=4) :: pnelemsSize
  INTEGER(kind=4) :: pnthrcolSize
  INTEGER(kind=4) :: poffsetSize
  INTEGER(kind=4) :: pthrcolSize
  END TYPE res_calc_variableSizes

  TYPE  :: save_soln_opDatDimensions
  INTEGER(kind=4) :: opDat1Dimension
  INTEGER(kind=4) :: opDat2Dimension
  END TYPE save_soln_opDatDimensions

  TYPE  :: save_soln_variableSizes
  INTEGER(kind=4) :: opDat1Size
  INTEGER(kind=4) :: opDat2Size
  END TYPE save_soln_variableSizes

  TYPE  :: update_opDatDimensions
  INTEGER(kind=4) :: opDat1Dimension
  INTEGER(kind=4) :: opDat2Dimension
  INTEGER(kind=4) :: opDat3Dimension
  INTEGER(kind=4) :: opDat4Dimension
  INTEGER(kind=4) :: opDat5Dimension
  END TYPE update_opDatDimensions

  TYPE  :: update_variableSizes
  INTEGER(kind=4) :: opDat1Size
  INTEGER(kind=4) :: opDat2Size
  INTEGER(kind=4) :: opDat3Size
  INTEGER(kind=4) :: opDat4Size
  INTEGER(kind=4) :: opDat5Size
  END TYPE update_variableSizes

  LOGICAL :: isFirstTime_adt_calc = .TRUE.
  LOGICAL :: doInitialiseConstants = .TRUE.
  TYPE ( adt_calc_variableSizes ) , DEVICE :: argsSizes_adt_calc
  TYPE ( adt_calc_opDatDimensions ) , DEVICE :: dimensions_adt_calc
  TYPE ( c_ptr )  :: planRet
  LOGICAL :: isFirstTime_bres_calc = .TRUE.
  LOGICAL :: doInitialiseConstants = .TRUE.
  TYPE ( bres_calc_variableSizes ) , DEVICE :: argsSizes_bres_calc
  TYPE ( bres_calc_opDatDimensions ) , DEVICE :: dimensions_bres_calc
  TYPE ( c_ptr )  :: planRet
  LOGICAL :: isFirstTime_res_calc = .TRUE.
  LOGICAL :: doInitialiseConstants = .TRUE.
  TYPE ( res_calc_variableSizes ) , DEVICE :: argsSizes_res_calc
  TYPE ( res_calc_opDatDimensions ) , DEVICE :: dimensions_res_calc
  TYPE ( c_ptr )  :: planRet
  LOGICAL :: isFirstTime_save_soln = .TRUE.
  LOGICAL :: doInitialiseConstants = .TRUE.
  TYPE ( save_soln_variableSizes ) , DEVICE :: argsSizes_save_soln
  TYPE ( save_soln_opDatDimensions ) , DEVICE :: dimensions_save_soln
  LOGICAL :: isFirstTime_update = .TRUE.
  LOGICAL :: doInitialiseConstants = .TRUE.
  TYPE ( update_variableSizes ) , DEVICE :: argsSizes_update
  TYPE ( update_opDatDimensions ) , DEVICE :: dimensions_update
  REAL(kind=8), DIMENSION(:), ALLOCATABLE :: reductionArrayHost
  REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: reductionArrayDevice
  CONTAINS

  attributes(device) SUBROUTINE ReductionFloat8(resultOnDevice, inputValue, warpSize, sharedMemoryStartOffset, reductionOp&
  &eration)
    REAL(kind=8), DIMENSION(:), DEVICE :: resultOnDevice
    REAL(kind=8), VALUE :: inputValue
    INTEGER(kind=4), VALUE :: warpSize
    INTEGER(kind=4), VALUE :: sharedMemoryStartOffset
    INTEGER(kind=4), VALUE :: reductionOperation
    REAL(kind=8), DIMENSION(0:*), SHARED :: autosharedFloat8
    INTEGER(kind=4) :: i1
    INTEGER(kind=4) :: threadID
    threadID = threadidx%x - 1
    i1 = ishft(blockdim%x,  -1)
    sharedMemoryStartOffset = 0
    CALL syncthreads()

    autosharedFloat8(sharedMemoryStartOffset + threadID) = inputValue

    DO WHILE (i1 > 0)
      CALL syncthreads()

      IF (threadID < i1) THEN

        SELECT CASE(reductionOperation)
          CASE (0)autosharedFloat8(sharedMemoryStartOffset + threadID) = autosharedFloat8(sharedMemoryStartOffset + threadID) + au&
          &tosharedFloat8(sharedMemoryStartOffset + threadID + i1)

          CASE (1)IF (autosharedFloat8(sharedMemoryStartOffset + threadID + i1) < autosharedFloat8(sharedMemoryStartOffset + threa&
          &dID)) THEN
            autosharedFloat8(sharedMemoryStartOffset + threadID) = autosharedFloat8(sharedMemoryStartOffset + threadID + i1)
          END IF

          CASE (2)IF (autosharedFloat8(sharedMemoryStartOffset + threadID + i1) > autosharedFloat8(sharedMemoryStartOffset + threa&
          &dID)) THEN
            autosharedFloat8(sharedMemoryStartOffset + threadID) = autosharedFloat8(sharedMemoryStartOffset + threadID + i1)
          END IF

        END SELECT

      END IF

      i1 = ishft(i1,  -1)
    END DO

    CALL syncthreads()

    IF (threadID == 0) THEN

      SELECT CASE(reductionOperation)
        CASE (0)resultOnDevice(1) = resultOnDevice(1) + autosharedFloat8(sharedMemoryStartOffset)

        CASE (1)IF (autosharedFloat8(sharedMemoryStartOffset) < resultOnDevice(1)) THEN
          resultOnDevice(1) = autosharedFloat8(sharedMemoryStartOffset)
        END IF

        CASE (2)IF (autosharedFloat8(sharedMemoryStartOffset) > resultOnDevice(1)) THEN
          resultOnDevice(1) = autosharedFloat8(sharedMemoryStartOffset)
        END IF

      END SELECT

    END IF

    CALL syncthreads()

  END SUBROUTINE 

  attributes(host) SUBROUTINE InitialiseConstants()
  END SUBROUTINE 

  attributes(device) SUBROUTINE adt_calc_device(x1, x2, x3, x4, q, adt)

    IMPLICIT NONE

    REAL(kind=8), DIMENSION(*), SHARED :: x1
    REAL(kind=8), DIMENSION(*), SHARED :: x2
    REAL(kind=8), DIMENSION(*), SHARED :: x3
    REAL(kind=8), DIMENSION(*), SHARED :: x4
    REAL(kind=8), DIMENSION(*) :: q
    REAL(kind=8), DIMENSION(*) :: adt
    REAL(kind=8) :: dx,dy,ri,u,v,c
    ri = 1.0 / q(1)
    u = ri * q(2)
    v = ri * q(3)
    c = sqrt(gam * gm1 * (ri * q(4) - 0.5 * (u * u + v * v)))
    dx = x2(1) - x1(1)
    dy = x2(2) - x1(2)
    adt(1) = abs(u * dy - v * dx) + c * sqrt(dx * dx + dy * dy)
    dx = x3(1) - x2(1)
    dy = x3(2) - x2(2)
    adt(1) = adt(1) + abs(u * dy - v * dx) + c * sqrt(dx * dx + dy * dy)
    dx = x4(1) - x3(1)
    dy = x4(2) - x3(2)
    adt(1) = adt(1) + abs(u * dy - v * dx) + c * sqrt(dx * dx + dy * dy)
    dx = x1(1) - x4(1)
    dy = x1(2) - x4(2)
    adt(1) = adt(1) + abs(u * dy - v * dx) + c * sqrt(dx * dx + dy * dy)
    adt(1) = adt(1) / cfl
  END SUBROUTINE 

  attributes(global) SUBROUTINE adt_calc_kernel(dimensions_adt_calc_device, argsSizes_adt_calc_device, opDat1, pindMaps1, &
  &pMaps1, pMaps2, pMaps3, pMaps4, opDat5, opDat6, pindSizes, pindOffs, pblkMap, poffset, pnelems, pnthrcol, pthrcol, block&
  &Offset)

    IMPLICIT NONE

    TYPE ( adt_calc_opDatDimensions ) , DEVICE :: dimensions_adt_calc_device
    TYPE ( adt_calc_variableSizes ) , DEVICE :: argsSizes_adt_calc_device
    REAL(kind=8), DIMENSION(0:argsSizes_adt_calc_device%opDat1Size - 1), DEVICE :: opDat1
    INTEGER(kind=4), DIMENSION(0:argsSizes_adt_calc_device%pindMaps1Size - 1), DEVICE :: pindMaps1
    INTEGER(kind=2), DIMENSION(0:argsSizes_adt_calc_device%pMaps1Size - 1), DEVICE :: pMaps1
    INTEGER(kind=2), DIMENSION(0:argsSizes_adt_calc_device%pMaps2Size - 1), DEVICE :: pMaps2
    INTEGER(kind=2), DIMENSION(0:argsSizes_adt_calc_device%pMaps3Size - 1), DEVICE :: pMaps3
    INTEGER(kind=2), DIMENSION(0:argsSizes_adt_calc_device%pMaps4Size - 1), DEVICE :: pMaps4
    REAL(kind=8) :: opDat5(0:argsSizes_adt_calc_device%opDat5Size - 1)
    REAL(kind=8) :: opDat6(0:argsSizes_adt_calc_device%opDat6Size - 1)
    INTEGER(kind=4), DIMENSION(0:argsSizes_adt_calc_device%pindSizesSize - 1), DEVICE :: pindSizes
    INTEGER(kind=4), DIMENSION(0:argsSizes_adt_calc_device%pindOffsSize - 1), DEVICE :: pindOffs
    INTEGER(kind=4), DIMENSION(0:argsSizes_adt_calc_device%pblkMapSize - 1), DEVICE :: pblkMap
    INTEGER(kind=4), DIMENSION(0:argsSizes_adt_calc_device%poffsetSize - 1), DEVICE :: poffset
    INTEGER(kind=4), DIMENSION(0:argsSizes_adt_calc_device%pnelemsSize - 1), DEVICE :: pnelems
    INTEGER(kind=4), DIMENSION(0:argsSizes_adt_calc_device%pnthrcolSize - 1), DEVICE :: pnthrcol
    INTEGER(kind=4), DIMENSION(0:argsSizes_adt_calc_device%pthrcolSize - 1), DEVICE :: pthrcol
    INTEGER(kind=4), VALUE :: blockOffset
    REAL(kind=8), DIMENSION(0:*), SHARED :: autosharedFloat8
    INTEGER(kind=4) :: nBytes1
    INTEGER(kind=4) :: nBytes5
    INTEGER(kind=4) :: nBytes6
    INTEGER(kind=4) :: roundUp1
    INTEGER(kind=4) :: roundUp5
    INTEGER(kind=4) :: roundUp6
    INTEGER(kind=4), SHARED :: ind_arg1
    INTEGER(kind=4), SHARED :: blockID
    INTEGER(kind=4), SHARED :: blockOffsetShared
    INTEGER(kind=4), SHARED :: ncolor
    INTEGER(kind=4), SHARED :: nelem
    INTEGER(kind=4), SHARED :: nelems2
    INTEGER(kind=4) :: col
    INTEGER(kind=4) :: col2
    INTEGER(kind=4) :: i1
    INTEGER(kind=4) :: i2
    INTEGER(kind=4) :: n
    INTEGER(kind=4) :: moduloResult
    INTEGER(kind=4) :: moduled
    INTEGER(kind=4) :: nbytes

    IF (threadidx%x - 1 == 0) THEN
      blockID = pblkMap(blockidx%x - 1 + blockOffset)
      nelem = pnelems(blockID)
      blockOffsetShared = poffset(blockID)
      nelems2 = blockdim%x * (1 + (nelem - 1) / blockdim%x)
      ncolor = pnthrcol(blockID)
      ind_arg1 = pindSizes(0 + blockID * 1)
    END IF

    CALL syncthreads()

    roundUp1 = ind_arg1 * dimensions_adt_calc_device%opDat1Dimension
    nBytes1 = 0
    i1 = threadidx%x - 1
    n = ind_arg1 * dimensions_adt_calc_device%opDat1Dimension

    DO WHILE (i1 < n)
      moduled = mod(i1,  dimensions_adt_calc_device%opDat1Dimension)
      autosharedFloat8(nBytes1 + i1) = opDat1(moduled + pindMaps1(0 + (pindOffs(0 + blockID * 1) + i1 / dimensions_adt_calc_de&
      &vice%opDat1Dimension)) * dimensions_adt_calc_device%opDat1Dimension)
      i1 = i1 + blockdim%x
    END DO

    CALL syncthreads()

    i1 = threadidx%x - 1

    DO WHILE (i1 < nelems2)
      col2 = -1

      IF (i1 < nelem) THEN
        CALL adt_calc_device(autosharedFloat8(nBytes1 + pMaps1(i1 + blockOffsetShared) * dimensions_adt_calc_device%opDat1Dimens&
        &ion:nBytes1 + pMaps1(i1 + blockOffsetShared) * dimensions_adt_calc_device%opDat1Dimension + dimensions_adt_calc_device%o&
        &pDat1Dimension),  autosharedFloat8(nBytes1 + pMaps2(i1 + blockOffsetShared) * dimensions_adt_calc_device%opDat2Dimension&
        &:nBytes1 + pMaps2(i1 + blockOffsetShared) * dimensions_adt_calc_device%opDat2Dimension + dimensions_adt_calc_device%opDa&
        &t2Dimension),  autosharedFloat8(nBytes1 + pMaps3(i1 + blockOffsetShared) * dimensions_adt_calc_device%opDat3Dimension:nB&
        &ytes1 + pMaps3(i1 + blockOffsetShared) * dimensions_adt_calc_device%opDat3Dimension + dimensions_adt_calc_device%opDat3D&
        &imension),  autosharedFloat8(nBytes1 + pMaps4(i1 + blockOffsetShared) * dimensions_adt_calc_device%opDat4Dimension:nByte&
        &s1 + pMaps4(i1 + blockOffsetShared) * dimensions_adt_calc_device%opDat4Dimension + dimensions_adt_calc_device%opDat4Dime&
        &nsion),  opDat5((i1 + blockOffsetShared) * dimensions_adt_calc_device%opDat5Dimension:(i1 + blockOffsetShared) * dimensi&
        &ons_adt_calc_device%opDat5Dimension + dimensions_adt_calc_device%opDat5Dimension),  opDat6((i1 + blockOffsetShared) * di&
        &mensions_adt_calc_device%opDat6Dimension:(i1 + blockOffsetShared) * dimensions_adt_calc_device%opDat6Dimension + dimensi&
        &ons_adt_calc_device%opDat6Dimension))

        col2 = pthrcol(i1 + blockOffsetShared)
      END IF

      DO col = 0, ncolor - 1, 1

        IF (col2 == col) THEN
        END IF

        CALL syncthreads()

      END DO

      i1 = i1 + blockdim%x
    END DO

  END SUBROUTINE 

  attributes(host) SUBROUTINE adt_calc_host(userSubroutine, set, opDat1, opIndirection1, opMap1, opAccess1, opDat2, opIndi&
  &rection2, opMap2, opAccess2, opDat3, opIndirection3, opMap3, opAccess3, opDat4, opIndirection4, opMap4, opAccess4, opDat&
  &5, opIndirection5, opMap5, opAccess5, opDat6, opIndirection6, opMap6, opAccess6)

    IMPLICIT NONE

    character(len=8), INTENT(IN) :: userSubroutine
    TYPE ( op_set ) , INTENT(IN) :: set
    TYPE ( op_dat ) , INTENT(IN) :: opDat1
    INTEGER(kind=4), INTENT(IN) :: opIndirection1
    TYPE ( op_map ) , INTENT(IN) :: opMap1
    INTEGER(kind=4), INTENT(IN) :: opAccess1
    TYPE ( op_dat ) , INTENT(IN) :: opDat2
    INTEGER(kind=4), INTENT(IN) :: opIndirection2
    TYPE ( op_map ) , INTENT(IN) :: opMap2
    INTEGER(kind=4), INTENT(IN) :: opAccess2
    TYPE ( op_dat ) , INTENT(IN) :: opDat3
    INTEGER(kind=4), INTENT(IN) :: opIndirection3
    TYPE ( op_map ) , INTENT(IN) :: opMap3
    INTEGER(kind=4), INTENT(IN) :: opAccess3
    TYPE ( op_dat ) , INTENT(IN) :: opDat4
    INTEGER(kind=4), INTENT(IN) :: opIndirection4
    TYPE ( op_map ) , INTENT(IN) :: opMap4
    INTEGER(kind=4), INTENT(IN) :: opAccess4
    TYPE ( op_dat ) , INTENT(IN) :: opDat5
    INTEGER(kind=4), INTENT(IN) :: opIndirection5
    TYPE ( op_map ) , INTENT(IN) :: opMap5
    INTEGER(kind=4), INTENT(IN) :: opAccess5
    TYPE ( op_dat ) , INTENT(IN) :: opDat6
    INTEGER(kind=4), INTENT(IN) :: opIndirection6
    TYPE ( op_map ) , INTENT(IN) :: opMap6
    INTEGER(kind=4), INTENT(IN) :: opAccess6
    INTEGER(kind=4) :: opDat1Size
    INTEGER(kind=4) :: opDat5Size
    INTEGER(kind=4) :: opDat6Size
    REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat1Device
    REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat5Device
    REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat6Device
    INTEGER(kind=4) :: nblocks
    INTEGER(kind=4) :: nthread
    INTEGER(kind=4) :: nshared
    INTEGER(kind=4) :: threadSynchRet
    TYPE ( op_plan ) , POINTER :: actualPlan
    TYPE ( c_devptr ) , POINTER, DIMENSION(:) :: pindMaps
    TYPE ( c_devptr ) , POINTER, DIMENSION(:) :: pmaps
    INTEGER(kind=4) :: pindMapsSize
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pindMaps1
    INTEGER(kind=4), DIMENSION(1:6) :: args
    INTEGER(kind=4), DIMENSION(1:6) :: idxs
    INTEGER(kind=4), DIMENSION(1:6) :: maps
    INTEGER(kind=4), DIMENSION(1:6) :: accesses
    INTEGER(kind=4), DIMENSION(1:6) :: inds
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps1
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps2
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps3
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps4
    INTEGER(kind=4) :: pMaps1Size
    INTEGER(kind=4) :: pMaps2Size
    INTEGER(kind=4) :: pMaps3Size
    INTEGER(kind=4) :: pMaps4Size
    INTEGER(kind=4) :: col
    INTEGER(kind=4) :: i1
    INTEGER(kind=4) :: argsNumber
    INTEGER(kind=4) :: indsNumber
    INTEGER(kind=4) :: blockOffset
    INTEGER(kind=4) :: pindSizesSize
    INTEGER(kind=4) :: pindOffsSize
    INTEGER(kind=4) :: pblkMapSize
    INTEGER(kind=4) :: poffsetSize
    INTEGER(kind=4) :: pnelemsSize
    INTEGER(kind=4) :: pnthrcolSize
    INTEGER(kind=4) :: pthrcolSize
    INTEGER(kind=4), POINTER, DIMENSION(:) :: ncolblk
    INTEGER(kind=4), POINTER, DIMENSION(:) :: pnindirect
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pindSizes
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pindOffs
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pblkMap
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: poffset
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pnelems
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pnthrcol
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pthrcol

    IF (isFirstTime_adt_calc .EQV. .TRUE.) THEN
      dimensions_adt_calc%opDat1Dimension = opDat1%dim
      dimensions_adt_calc%opDat2Dimension = opDat2%dim
      dimensions_adt_calc%opDat3Dimension = opDat3%dim
      dimensions_adt_calc%opDat4Dimension = opDat4%dim
      dimensions_adt_calc%opDat5Dimension = opDat5%dim
      dimensions_adt_calc%opDat6Dimension = opDat6%dim
      argsSizes_adt_calc%opDat1Size = opDat1%dim * opDat1%set%size
      argsSizes_adt_calc%opDat5Size = opDat5%dim * opDat5%set%size
      argsSizes_adt_calc%opDat6Size = opDat6%dim * opDat6%set%size
      args(1) = opDat1%index
      args(2) = opDat2%index
      args(3) = opDat3%index
      args(4) = opDat4%index
      args(5) = opDat5%index
      args(6) = opDat6%index
      idxs(1) = opIndirection1
      idxs(2) = opIndirection2
      idxs(3) = opIndirection3
      idxs(4) = opIndirection4
      idxs(5) = opIndirection5
      idxs(6) = opIndirection6

      DO i1 = 1, 6, 1

        IF (idxs(i1) /= -1) THEN
          idxs(i1) = idxs(i1) - 1
        END IF

      END DO

      maps(1) = opMap1%index
      maps(2) = opMap2%index
      maps(3) = opMap3%index
      maps(4) = opMap4%index
      maps(5) = opMap5%index
      maps(6) = opMap6%index
      accesses(1) = opAccess1
      accesses(2) = opAccess2
      accesses(3) = opAccess3
      accesses(4) = opAccess4
      accesses(5) = opAccess5
      accesses(6) = opAccess6
      inds(1) = 0
      inds(2) = 0
      inds(3) = 0
      inds(4) = 0
      inds(5) = -1
      inds(6) = -1
      argsNumber = 6
      indsNumber = 1
      planRet = cplan(userSubroutine,  set%index,  argsNumber,  args,  idxs,  maps,  accesses,  indsNumber,  inds)
    END IF

    opDat1Size = opDat1%dim * opDat1%set%size
    opDat5Size = opDat5%dim * opDat5%set%size
    opDat6Size = opDat6%dim * opDat6%set%size
    CALL c_f_pointer(opDat1%dat_d,  opDat1Device,  (/opDat1Size/))

    CALL c_f_pointer(opDat5%dat_d,  opDat5Device,  (/opDat5Size/))

    CALL c_f_pointer(opDat6%dat_d,  opDat6Device,  (/opDat6Size/))

    CALL c_f_pointer(planRet,  actualPlan)

    CALL c_f_pointer(actualPlan%nindirect,  pnindirect,  (/indsNumber/))

    CALL c_f_pointer(actualPlan%maps,  pmaps,  (/argsNumber/))

    IF (inds(1) >= 0) THEN
      pMaps1Size = set%size
      CALL c_f_pointer(pmaps(1),  pMaps1,  (/pMaps1Size/))

    END IF

    IF (inds(2) >= 0) THEN
      pMaps2Size = set%size
      CALL c_f_pointer(pmaps(2),  pMaps2,  (/pMaps2Size/))

    END IF

    IF (inds(3) >= 0) THEN
      pMaps3Size = set%size
      CALL c_f_pointer(pmaps(3),  pMaps3,  (/pMaps3Size/))

    END IF

    IF (inds(4) >= 0) THEN
      pMaps4Size = set%size
      CALL c_f_pointer(pmaps(4),  pMaps4,  (/pMaps4Size/))

    END IF

    CALL c_f_pointer(actualPlan%ind_maps,  pindMaps,  (/indsNumber/))

    CALL c_f_pointer(actualPlan%ncolblk,  ncolblk,  set%size)

    pindSizesSize = actualPlan%nblocks * indsNumber
    CALL c_f_pointer(actualPlan%ind_sizes,  pindSizes,  (/pindSizesSize/))

    pindOffsSize = pindSizesSize
    CALL c_f_pointer(actualPlan%ind_offs,  pindOffs,  (/pindOffsSize/))

    pblkMapSize = actualPlan%nblocks
    CALL c_f_pointer(actualPlan%blkmap,  pblkMap,  (/pblkMapSize/))

    poffsetSize = actualPlan%nblocks
    CALL c_f_pointer(actualPlan%offset,  poffset,  (/poffsetSize/))

    pnelemsSize = actualPlan%nblocks
    CALL c_f_pointer(actualPlan%nelems,  pnelems,  (/pnelemsSize/))

    pnthrcolSize = actualPlan%nblocks
    CALL c_f_pointer(actualPlan%nthrcol,  pnthrcol,  (/pnthrcolSize/))

    pthrcolSize = set%size
    CALL c_f_pointer(actualPlan%thrcol,  pthrcol,  (/pthrcolSize/))

    CALL c_f_pointer(pindMaps(1),  pindMaps1,  pnindirect(1))

    IF (isFirstTime_adt_calc .EQV. .TRUE.) THEN
      isFirstTime_adt_calc = .FALSE.
      argsSizes_adt_calc%pindMaps1Size = pnindirect(1)
      argsSizes_adt_calc%pMaps1Size = pMaps1Size
      argsSizes_adt_calc%pMaps2Size = pMaps2Size
      argsSizes_adt_calc%pMaps3Size = pMaps3Size
      argsSizes_adt_calc%pMaps4Size = pMaps4Size
      argsSizes_adt_calc%pblkMapSize = pblkMapSize
      argsSizes_adt_calc%pindOffsSize = pindOffsSize
      argsSizes_adt_calc%pindSizesSize = pindSizesSize
      argsSizes_adt_calc%pnelemsSize = pnelemsSize
      argsSizes_adt_calc%pnthrcolSize = pnthrcolSize
      argsSizes_adt_calc%poffsetSize = poffsetSize
      argsSizes_adt_calc%pthrcolSize = pthrcolSize
    END IF

    IF (doInitialiseConstants .EQV. .TRUE.) THEN
      doInitialiseConstants = .FALSE.
      CALL InitialiseConstants()

    END IF

    blockOffset = 0

    DO col = 0, actualPlan%ncolors - 1, 1
      nblocks = ncolblk(col + 1)
      nthread = FOP_BLOCK_SIZE
      nshared = actualPlan%nshared
      CALL adt_calc_kernel<<<nblocks, nthread, nshared>>>(dimensions_adt_calc,  argsSizes_adt_calc,  opDat1Device,  pindMaps1,&
      &  pMaps1,  pMaps2,  pMaps3,  pMaps4,  opDat5Device,  opDat6Device,  pindSizes,  pindOffs,  pblkMap,  poffset,  pnelems, &
      & pnthrcol,  pthrcol,  blockOffset)

      threadSynchRet = cudaThreadSynchronize()
      blockOffset = blockOffset + nblocks
    END DO

  END SUBROUTINE 

  attributes(device) SUBROUTINE bres_calc_device(x1, x2, q1, adt1, res1, bound)

    IMPLICIT NONE

    REAL(kind=8), DIMENSION(*), SHARED :: x1
    REAL(kind=8), DIMENSION(*), SHARED :: x2
    REAL(kind=8), DIMENSION(*), SHARED :: q1
    REAL(kind=8), DIMENSION(*), SHARED :: adt1
    REAL(kind=8), DIMENSION(*) :: res1
    INTEGER(kind=4), DIMENSION(*) :: bound
    REAL(kind=8) :: dx,dy,mu,ri,p1,vol1,p2,vol2,f
    dx = x1(1) - x2(1)
    dy = x1(2) - x2(2)
    ri = 1.0 / q1(1)
    p1 = gm1 * (q1(4) - 0.5 * ri * (q1(2) * q1(2) + q1(3) * q1(3)))

    IF (bound(1) == 1) THEN
      res1(2) = res1(2) + +(p1 * dy)
      res1(3) = res1(3) + -(p1 * dx)
      ELSE
      vol1 = ri * (q1(2) * dy - q1(3) * dx)
      ri = 1.0 / qinf(1)
      p2 = gm1 * (qinf(4) - 0.5 * ri * (qinf(2) * qinf(2) + qinf(3) * qinf(3)))
      vol2 = ri * (qinf(2) * dy - qinf(3) * dx)
      mu = adt1(1) * eps
      f = 0.5 * (vol1 * q1(1) + vol2 * qinf(1)) + mu * (q1(1) - qinf(1))
      res1(1) = res1(1) + f
      f = 0.5 * (vol1 * q1(2) + p1 * dy + vol2 * qinf(2) + p2 * dy) + mu * (q1(2) - qinf(2))
      res1(2) = res1(2) + f
      f = 0.5 * (vol1 * q1(3) - p1 * dx + vol2 * qinf(3) - p2 * dx) + mu * (q1(3) - qinf(3))
      res1(3) = res1(3) + f
      f = 0.5 * (vol1 * (q1(4) + p1) + vol2 * (qinf(4) + p2)) + mu * (q1(4) - qinf(4))
      res1(4) = res1(4) + f
    END IF

  END SUBROUTINE 

  attributes(global) SUBROUTINE bres_calc_kernel(dimensions_bres_calc_device, argsSizes_bres_calc_device, opDat1, pindMaps&
  &1, opDat3, pindMaps3, opDat4, pindMaps4, opDat5, pindMaps5, pMaps1, pMaps2, pMaps3, pMaps4, pMaps5, opDat6, pindSizes, p&
  &indOffs, pblkMap, poffset, pnelems, pnthrcol, pthrcol, blockOffset)

    IMPLICIT NONE

    TYPE ( bres_calc_opDatDimensions ) , DEVICE :: dimensions_bres_calc_device
    TYPE ( bres_calc_variableSizes ) , DEVICE :: argsSizes_bres_calc_device
    REAL(kind=8), DIMENSION(0:argsSizes_bres_calc_device%opDat1Size - 1), DEVICE :: opDat1
    INTEGER(kind=4), DIMENSION(0:argsSizes_bres_calc_device%pindMaps1Size - 1), DEVICE :: pindMaps1
    REAL(kind=8), DIMENSION(0:argsSizes_bres_calc_device%opDat3Size - 1), DEVICE :: opDat3
    INTEGER(kind=4), DIMENSION(0:argsSizes_bres_calc_device%pindMaps3Size - 1), DEVICE :: pindMaps3
    REAL(kind=8), DIMENSION(0:argsSizes_bres_calc_device%opDat4Size - 1), DEVICE :: opDat4
    INTEGER(kind=4), DIMENSION(0:argsSizes_bres_calc_device%pindMaps4Size - 1), DEVICE :: pindMaps4
    REAL(kind=8), DIMENSION(0:argsSizes_bres_calc_device%opDat5Size - 1), DEVICE :: opDat5
    INTEGER(kind=4), DIMENSION(0:argsSizes_bres_calc_device%pindMaps5Size - 1), DEVICE :: pindMaps5
    INTEGER(kind=2), DIMENSION(0:argsSizes_bres_calc_device%pMaps1Size - 1), DEVICE :: pMaps1
    INTEGER(kind=2), DIMENSION(0:argsSizes_bres_calc_device%pMaps2Size - 1), DEVICE :: pMaps2
    INTEGER(kind=2), DIMENSION(0:argsSizes_bres_calc_device%pMaps3Size - 1), DEVICE :: pMaps3
    INTEGER(kind=2), DIMENSION(0:argsSizes_bres_calc_device%pMaps4Size - 1), DEVICE :: pMaps4
    INTEGER(kind=2), DIMENSION(0:argsSizes_bres_calc_device%pMaps5Size - 1), DEVICE :: pMaps5
    INTEGER(kind=4) :: opDat6(0:argsSizes_bres_calc_device%opDat6Size - 1)
    INTEGER(kind=4), DIMENSION(0:argsSizes_bres_calc_device%pindSizesSize - 1), DEVICE :: pindSizes
    INTEGER(kind=4), DIMENSION(0:argsSizes_bres_calc_device%pindOffsSize - 1), DEVICE :: pindOffs
    INTEGER(kind=4), DIMENSION(0:argsSizes_bres_calc_device%pblkMapSize - 1), DEVICE :: pblkMap
    INTEGER(kind=4), DIMENSION(0:argsSizes_bres_calc_device%poffsetSize - 1), DEVICE :: poffset
    INTEGER(kind=4), DIMENSION(0:argsSizes_bres_calc_device%pnelemsSize - 1), DEVICE :: pnelems
    INTEGER(kind=4), DIMENSION(0:argsSizes_bres_calc_device%pnthrcolSize - 1), DEVICE :: pnthrcol
    INTEGER(kind=4), DIMENSION(0:argsSizes_bres_calc_device%pthrcolSize - 1), DEVICE :: pthrcol
    INTEGER(kind=4), VALUE :: blockOffset
    REAL(kind=8), DIMENSION(0:3) :: opDat5Local
    REAL(kind=8), DIMENSION(0:*), SHARED :: autosharedFloat8
    INTEGER(kind=4), DIMENSION(0:*), SHARED :: autosharedInteger4
    INTEGER(kind=4) :: nBytes1
    INTEGER(kind=4) :: nBytes3
    INTEGER(kind=4) :: nBytes4
    INTEGER(kind=4) :: nBytes5
    INTEGER(kind=4) :: nBytes6
    INTEGER(kind=4) :: roundUp1
    INTEGER(kind=4) :: roundUp3
    INTEGER(kind=4) :: roundUp4
    INTEGER(kind=4) :: roundUp5
    INTEGER(kind=4) :: roundUp6
    INTEGER(kind=4) :: argMap5
    INTEGER(kind=4), SHARED :: ind_arg1
    INTEGER(kind=4), SHARED :: ind_arg3
    INTEGER(kind=4), SHARED :: ind_arg4
    INTEGER(kind=4), SHARED :: ind_arg5
    INTEGER(kind=4), SHARED :: blockID
    INTEGER(kind=4), SHARED :: blockOffsetShared
    INTEGER(kind=4), SHARED :: ncolor
    INTEGER(kind=4), SHARED :: nelem
    INTEGER(kind=4), SHARED :: nelems2
    INTEGER(kind=4) :: col
    INTEGER(kind=4) :: col2
    INTEGER(kind=4) :: i1
    INTEGER(kind=4) :: i2
    INTEGER(kind=4) :: n
    INTEGER(kind=4) :: moduloResult
    INTEGER(kind=4) :: moduled
    INTEGER(kind=4) :: nbytes

    IF (threadidx%x - 1 == 0) THEN
      blockID = pblkMap(blockidx%x - 1 + blockOffset)
      nelem = pnelems(blockID)
      blockOffsetShared = poffset(blockID)
      nelems2 = blockdim%x * (1 + (nelem - 1) / blockdim%x)
      ncolor = pnthrcol(blockID)
      ind_arg1 = pindSizes(0 + blockID * 4)
      ind_arg3 = pindSizes(1 + blockID * 4)
      ind_arg4 = pindSizes(2 + blockID * 4)
      ind_arg5 = pindSizes(3 + blockID * 4)
    END IF

    CALL syncthreads()

    roundUp1 = ind_arg1 * dimensions_bres_calc_device%opDat1Dimension
    roundUp3 = ind_arg3 * dimensions_bres_calc_device%opDat3Dimension
    roundUp4 = ind_arg4 * dimensions_bres_calc_device%opDat4Dimension
    roundUp5 = ind_arg5 * dimensions_bres_calc_device%opDat5Dimension
    nBytes1 = 0
    nBytes3 = nBytes1 + roundUp1
    nBytes4 = nBytes3 + roundUp3
    nBytes5 = nBytes4 + roundUp4
    i1 = threadidx%x - 1
    n = ind_arg1 * dimensions_bres_calc_device%opDat1Dimension

    DO WHILE (i1 < n)
      moduled = mod(i1,  dimensions_bres_calc_device%opDat1Dimension)
      autosharedFloat8(nBytes1 + i1) = opDat1(moduled + pindMaps1(0 + (pindOffs(0 + blockID * 4) + i1 / dimensions_bres_calc_d&
      &evice%opDat1Dimension)) * dimensions_bres_calc_device%opDat1Dimension)
      i1 = i1 + blockdim%x
    END DO

    i1 = threadidx%x - 1
    n = ind_arg3 * dimensions_bres_calc_device%opDat3Dimension

    DO WHILE (i1 < n)
      moduled = mod(i1,  dimensions_bres_calc_device%opDat3Dimension)
      autosharedFloat8(nBytes3 + i1) = opDat3(moduled + pindMaps3(0 + (pindOffs(1 + blockID * 4) + i1 / dimensions_bres_calc_d&
      &evice%opDat3Dimension)) * dimensions_bres_calc_device%opDat3Dimension)
      i1 = i1 + blockdim%x
    END DO

    i1 = threadidx%x - 1
    n = ind_arg4 * dimensions_bres_calc_device%opDat4Dimension

    DO WHILE (i1 < n)
      moduled = mod(i1,  dimensions_bres_calc_device%opDat4Dimension)
      autosharedFloat8(nBytes4 + i1) = opDat4(moduled + pindMaps4(0 + (pindOffs(2 + blockID * 4) + i1 / dimensions_bres_calc_d&
      &evice%opDat4Dimension)) * dimensions_bres_calc_device%opDat4Dimension)
      i1 = i1 + blockdim%x
    END DO

    i1 = threadidx%x - 1
    n = ind_arg5 * dimensions_bres_calc_device%opDat5Dimension

    DO WHILE (i1 < n)
      autosharedFloat8(nBytes5 + i1) = 0
      i1 = i1 + blockdim%x
    END DO

    CALL syncthreads()

    i1 = threadidx%x - 1

    DO WHILE (i1 < nelems2)
      col2 = -1

      IF (i1 < nelem) THEN

        DO i2 = 0, dimensions_bres_calc_device%opDat5Dimension - 1, 1
          opDat5Local(i2) = 0
        END DO

        CALL bres_calc_device(autosharedFloat8(nBytes1 + pMaps1(i1 + blockOffsetShared) * dimensions_bres_calc_device%opDat1Dime&
        &nsion:nBytes1 + pMaps1(i1 + blockOffsetShared) * dimensions_bres_calc_device%opDat1Dimension + dimensions_bres_calc_devi&
        &ce%opDat1Dimension),  autosharedFloat8(nBytes1 + pMaps2(i1 + blockOffsetShared) * dimensions_bres_calc_device%opDat2Dime&
        &nsion:nBytes1 + pMaps2(i1 + blockOffsetShared) * dimensions_bres_calc_device%opDat2Dimension + dimensions_bres_calc_devi&
        &ce%opDat2Dimension),  autosharedFloat8(nBytes3 + pMaps3(i1 + blockOffsetShared) * dimensions_bres_calc_device%opDat3Dime&
        &nsion:nBytes3 + pMaps3(i1 + blockOffsetShared) * dimensions_bres_calc_device%opDat3Dimension + dimensions_bres_calc_devi&
        &ce%opDat3Dimension),  autosharedFloat8(nBytes4 + pMaps4(i1 + blockOffsetShared) * dimensions_bres_calc_device%opDat4Dime&
        &nsion:nBytes4 + pMaps4(i1 + blockOffsetShared) * dimensions_bres_calc_device%opDat4Dimension + dimensions_bres_calc_devi&
        &ce%opDat4Dimension),  opDat5Local,  opDat6((i1 + blockOffsetShared) * dimensions_bres_calc_device%opDat6Dimension:(i1 + &
        &blockOffsetShared) * dimensions_bres_calc_device%opDat6Dimension + dimensions_bres_calc_device%opDat6Dimension))

        col2 = pthrcol(i1 + blockOffsetShared)
      END IF

      argMap5 = pMaps5(i1 + blockOffsetShared)

      DO col = 0, ncolor - 1, 1

        IF (col2 == col) THEN

          DO i2 = 0, dimensions_bres_calc_device%opDat5Dimension - 1, 1
            autosharedFloat8(nBytes5 + (i2 + argMap5 * dimensions_bres_calc_device%opDat5Dimension)) = autosharedFloat8(nBytes5 + (i&
            &2 + argMap5 * dimensions_bres_calc_device%opDat5Dimension)) + opDat5Local(i2)
          END DO

        END IF

        CALL syncthreads()

      END DO

      i1 = i1 + blockdim%x
    END DO

    i1 = threadidx%x - 1

    DO WHILE (i1 < ind_arg5 * dimensions_bres_calc_device%opDat5Dimension)
      moduled = mod(i1,  dimensions_bres_calc_device%opDat5Dimension)
      opDat5(moduled + pindMaps5(0 + (pindOffs(3 + blockID * 4) + i1 / dimensions_bres_calc_device%opDat5Dimension)) * dimensi&
      &ons_bres_calc_device%opDat5Dimension) = opDat5(moduled + pindMaps5(0 + (pindOffs(3 + blockID * 4) + i1 / dimensions_bres&
      &_calc_device%opDat5Dimension)) * dimensions_bres_calc_device%opDat5Dimension) + autosharedFloat8(nBytes5 + i1)
      i1 = i1 + blockdim%x
    END DO

  END SUBROUTINE 

  attributes(host) SUBROUTINE bres_calc_host(userSubroutine, set, opDat1, opIndirection1, opMap1, opAccess1, opDat2, opInd&
  &irection2, opMap2, opAccess2, opDat3, opIndirection3, opMap3, opAccess3, opDat4, opIndirection4, opMap4, opAccess4, opDa&
  &t5, opIndirection5, opMap5, opAccess5, opDat6, opIndirection6, opMap6, opAccess6)

    IMPLICIT NONE

    character(len=9), INTENT(IN) :: userSubroutine
    TYPE ( op_set ) , INTENT(IN) :: set
    TYPE ( op_dat ) , INTENT(IN) :: opDat1
    INTEGER(kind=4), INTENT(IN) :: opIndirection1
    TYPE ( op_map ) , INTENT(IN) :: opMap1
    INTEGER(kind=4), INTENT(IN) :: opAccess1
    TYPE ( op_dat ) , INTENT(IN) :: opDat2
    INTEGER(kind=4), INTENT(IN) :: opIndirection2
    TYPE ( op_map ) , INTENT(IN) :: opMap2
    INTEGER(kind=4), INTENT(IN) :: opAccess2
    TYPE ( op_dat ) , INTENT(IN) :: opDat3
    INTEGER(kind=4), INTENT(IN) :: opIndirection3
    TYPE ( op_map ) , INTENT(IN) :: opMap3
    INTEGER(kind=4), INTENT(IN) :: opAccess3
    TYPE ( op_dat ) , INTENT(IN) :: opDat4
    INTEGER(kind=4), INTENT(IN) :: opIndirection4
    TYPE ( op_map ) , INTENT(IN) :: opMap4
    INTEGER(kind=4), INTENT(IN) :: opAccess4
    TYPE ( op_dat ) , INTENT(IN) :: opDat5
    INTEGER(kind=4), INTENT(IN) :: opIndirection5
    TYPE ( op_map ) , INTENT(IN) :: opMap5
    INTEGER(kind=4), INTENT(IN) :: opAccess5
    TYPE ( op_dat ) , INTENT(IN) :: opDat6
    INTEGER(kind=4), INTENT(IN) :: opIndirection6
    TYPE ( op_map ) , INTENT(IN) :: opMap6
    INTEGER(kind=4), INTENT(IN) :: opAccess6
    INTEGER(kind=4) :: opDat1Size
    INTEGER(kind=4) :: opDat3Size
    INTEGER(kind=4) :: opDat4Size
    INTEGER(kind=4) :: opDat5Size
    INTEGER(kind=4) :: opDat6Size
    REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat1Device
    REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat3Device
    REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat4Device
    REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat5Device
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat6Device
    INTEGER(kind=4) :: nblocks
    INTEGER(kind=4) :: nthread
    INTEGER(kind=4) :: nshared
    INTEGER(kind=4) :: threadSynchRet
    TYPE ( op_plan ) , POINTER :: actualPlan
    TYPE ( c_devptr ) , POINTER, DIMENSION(:) :: pindMaps
    TYPE ( c_devptr ) , POINTER, DIMENSION(:) :: pmaps
    INTEGER(kind=4) :: pindMapsSize
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pindMaps1
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pindMaps3
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pindMaps4
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pindMaps5
    INTEGER(kind=4), DIMENSION(1:6) :: args
    INTEGER(kind=4), DIMENSION(1:6) :: idxs
    INTEGER(kind=4), DIMENSION(1:6) :: maps
    INTEGER(kind=4), DIMENSION(1:6) :: accesses
    INTEGER(kind=4), DIMENSION(1:6) :: inds
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps1
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps2
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps3
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps4
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps5
    INTEGER(kind=4) :: pMaps1Size
    INTEGER(kind=4) :: pMaps2Size
    INTEGER(kind=4) :: pMaps3Size
    INTEGER(kind=4) :: pMaps4Size
    INTEGER(kind=4) :: pMaps5Size
    INTEGER(kind=4) :: col
    INTEGER(kind=4) :: i1
    INTEGER(kind=4) :: argsNumber
    INTEGER(kind=4) :: indsNumber
    INTEGER(kind=4) :: blockOffset
    INTEGER(kind=4) :: pindSizesSize
    INTEGER(kind=4) :: pindOffsSize
    INTEGER(kind=4) :: pblkMapSize
    INTEGER(kind=4) :: poffsetSize
    INTEGER(kind=4) :: pnelemsSize
    INTEGER(kind=4) :: pnthrcolSize
    INTEGER(kind=4) :: pthrcolSize
    INTEGER(kind=4), POINTER, DIMENSION(:) :: ncolblk
    INTEGER(kind=4), POINTER, DIMENSION(:) :: pnindirect
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pindSizes
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pindOffs
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pblkMap
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: poffset
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pnelems
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pnthrcol
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pthrcol

    IF (isFirstTime_bres_calc .EQV. .TRUE.) THEN
      dimensions_bres_calc%opDat1Dimension = opDat1%dim
      dimensions_bres_calc%opDat2Dimension = opDat2%dim
      dimensions_bres_calc%opDat3Dimension = opDat3%dim
      dimensions_bres_calc%opDat4Dimension = opDat4%dim
      dimensions_bres_calc%opDat5Dimension = opDat5%dim
      dimensions_bres_calc%opDat6Dimension = opDat6%dim
      argsSizes_bres_calc%opDat1Size = opDat1%dim * opDat1%set%size
      argsSizes_bres_calc%opDat3Size = opDat3%dim * opDat3%set%size
      argsSizes_bres_calc%opDat4Size = opDat4%dim * opDat4%set%size
      argsSizes_bres_calc%opDat5Size = opDat5%dim * opDat5%set%size
      argsSizes_bres_calc%opDat6Size = opDat6%dim * opDat6%set%size
      args(1) = opDat1%index
      args(2) = opDat2%index
      args(3) = opDat3%index
      args(4) = opDat4%index
      args(5) = opDat5%index
      args(6) = opDat6%index
      idxs(1) = opIndirection1
      idxs(2) = opIndirection2
      idxs(3) = opIndirection3
      idxs(4) = opIndirection4
      idxs(5) = opIndirection5
      idxs(6) = opIndirection6

      DO i1 = 1, 6, 1

        IF (idxs(i1) /= -1) THEN
          idxs(i1) = idxs(i1) - 1
        END IF

      END DO

      maps(1) = opMap1%index
      maps(2) = opMap2%index
      maps(3) = opMap3%index
      maps(4) = opMap4%index
      maps(5) = opMap5%index
      maps(6) = opMap6%index
      accesses(1) = opAccess1
      accesses(2) = opAccess2
      accesses(3) = opAccess3
      accesses(4) = opAccess4
      accesses(5) = opAccess5
      accesses(6) = opAccess6
      inds(1) = 0
      inds(2) = 0
      inds(3) = 1
      inds(4) = 2
      inds(5) = 3
      inds(6) = -1
      argsNumber = 6
      indsNumber = 4
      planRet = cplan(userSubroutine,  set%index,  argsNumber,  args,  idxs,  maps,  accesses,  indsNumber,  inds)
    END IF

    opDat1Size = opDat1%dim * opDat1%set%size
    opDat3Size = opDat3%dim * opDat3%set%size
    opDat4Size = opDat4%dim * opDat4%set%size
    opDat5Size = opDat5%dim * opDat5%set%size
    opDat6Size = opDat6%dim * opDat6%set%size
    CALL c_f_pointer(opDat1%dat_d,  opDat1Device,  (/opDat1Size/))

    CALL c_f_pointer(opDat3%dat_d,  opDat3Device,  (/opDat3Size/))

    CALL c_f_pointer(opDat4%dat_d,  opDat4Device,  (/opDat4Size/))

    CALL c_f_pointer(opDat5%dat_d,  opDat5Device,  (/opDat5Size/))

    CALL c_f_pointer(opDat6%dat_d,  opDat6Device,  (/opDat6Size/))

    CALL c_f_pointer(planRet,  actualPlan)

    CALL c_f_pointer(actualPlan%nindirect,  pnindirect,  (/indsNumber/))

    CALL c_f_pointer(actualPlan%maps,  pmaps,  (/argsNumber/))

    IF (inds(1) >= 0) THEN
      pMaps1Size = set%size
      CALL c_f_pointer(pmaps(1),  pMaps1,  (/pMaps1Size/))

    END IF

    IF (inds(2) >= 0) THEN
      pMaps2Size = set%size
      CALL c_f_pointer(pmaps(2),  pMaps2,  (/pMaps2Size/))

    END IF

    IF (inds(3) >= 0) THEN
      pMaps3Size = set%size
      CALL c_f_pointer(pmaps(3),  pMaps3,  (/pMaps3Size/))

    END IF

    IF (inds(4) >= 0) THEN
      pMaps4Size = set%size
      CALL c_f_pointer(pmaps(4),  pMaps4,  (/pMaps4Size/))

    END IF

    IF (inds(5) >= 0) THEN
      pMaps5Size = set%size
      CALL c_f_pointer(pmaps(5),  pMaps5,  (/pMaps5Size/))

    END IF

    CALL c_f_pointer(actualPlan%ind_maps,  pindMaps,  (/indsNumber/))

    CALL c_f_pointer(actualPlan%ncolblk,  ncolblk,  set%size)

    pindSizesSize = actualPlan%nblocks * indsNumber
    CALL c_f_pointer(actualPlan%ind_sizes,  pindSizes,  (/pindSizesSize/))

    pindOffsSize = pindSizesSize
    CALL c_f_pointer(actualPlan%ind_offs,  pindOffs,  (/pindOffsSize/))

    pblkMapSize = actualPlan%nblocks
    CALL c_f_pointer(actualPlan%blkmap,  pblkMap,  (/pblkMapSize/))

    poffsetSize = actualPlan%nblocks
    CALL c_f_pointer(actualPlan%offset,  poffset,  (/poffsetSize/))

    pnelemsSize = actualPlan%nblocks
    CALL c_f_pointer(actualPlan%nelems,  pnelems,  (/pnelemsSize/))

    pnthrcolSize = actualPlan%nblocks
    CALL c_f_pointer(actualPlan%nthrcol,  pnthrcol,  (/pnthrcolSize/))

    pthrcolSize = set%size
    CALL c_f_pointer(actualPlan%thrcol,  pthrcol,  (/pthrcolSize/))

    CALL c_f_pointer(pindMaps(1),  pindMaps1,  pnindirect(1))

    CALL c_f_pointer(pindMaps(2),  pindMaps3,  pnindirect(2))

    CALL c_f_pointer(pindMaps(3),  pindMaps4,  pnindirect(3))

    CALL c_f_pointer(pindMaps(4),  pindMaps5,  pnindirect(4))

    IF (isFirstTime_bres_calc .EQV. .TRUE.) THEN
      isFirstTime_bres_calc = .FALSE.
      argsSizes_bres_calc%pindMaps1Size = pnindirect(1)
      argsSizes_bres_calc%pindMaps3Size = pnindirect(2)
      argsSizes_bres_calc%pindMaps4Size = pnindirect(3)
      argsSizes_bres_calc%pindMaps5Size = pnindirect(4)
      argsSizes_bres_calc%pMaps1Size = pMaps1Size
      argsSizes_bres_calc%pMaps2Size = pMaps2Size
      argsSizes_bres_calc%pMaps3Size = pMaps3Size
      argsSizes_bres_calc%pMaps4Size = pMaps4Size
      argsSizes_bres_calc%pMaps5Size = pMaps5Size
      argsSizes_bres_calc%pblkMapSize = pblkMapSize
      argsSizes_bres_calc%pindOffsSize = pindOffsSize
      argsSizes_bres_calc%pindSizesSize = pindSizesSize
      argsSizes_bres_calc%pnelemsSize = pnelemsSize
      argsSizes_bres_calc%pnthrcolSize = pnthrcolSize
      argsSizes_bres_calc%poffsetSize = poffsetSize
      argsSizes_bres_calc%pthrcolSize = pthrcolSize
    END IF

    IF (doInitialiseConstants .EQV. .TRUE.) THEN
      doInitialiseConstants = .FALSE.
      CALL InitialiseConstants()

    END IF

    blockOffset = 0

    DO col = 0, actualPlan%ncolors - 1, 1
      nblocks = ncolblk(col + 1)
      nthread = FOP_BLOCK_SIZE
      nshared = actualPlan%nshared
      CALL bres_calc_kernel<<<nblocks, nthread, nshared>>>(dimensions_bres_calc,  argsSizes_bres_calc,  opDat1Device,  pindMap&
      &s1,  opDat3Device,  pindMaps3,  opDat4Device,  pindMaps4,  opDat5Device,  pindMaps5,  pMaps1,  pMaps2,  pMaps3,  pMaps4,&
      &  pMaps5,  opDat6Device,  pindSizes,  pindOffs,  pblkMap,  poffset,  pnelems,  pnthrcol,  pthrcol,  blockOffset)

      threadSynchRet = cudaThreadSynchronize()
      blockOffset = blockOffset + nblocks
    END DO

  END SUBROUTINE 

  attributes(device) SUBROUTINE res_calc_device(x1, x2, fakeInt1, fakeInt2, q1, q2, adt1, adt2, res1, res2)

    IMPLICIT NONE

    REAL(kind=8), DIMENSION(*), SHARED :: x1
    REAL(kind=8), DIMENSION(*), SHARED :: x2
    INTEGER(kind=4), DIMENSION(3), SHARED :: fakeInt1
    INTEGER(kind=4), DIMENSION(3), SHARED :: fakeInt2
    REAL(kind=8), DIMENSION(*), SHARED :: q1
    REAL(kind=8), DIMENSION(*), SHARED :: q2
    REAL(kind=8), DIMENSION(*), SHARED :: adt1
    REAL(kind=8), DIMENSION(*), SHARED :: adt2
    REAL(kind=8), DIMENSION(*) :: res1
    REAL(kind=8), DIMENSION(*) :: res2
    REAL(kind=8) :: dx,dy,mu,ri,p1,vol1,p2,vol2,f
    dx = x1(1) - x2(1)
    dy = x1(2) - x2(2)
    ri = 1.0 / q1(1)
    p1 = gm1 * (q1(4) - 0.5 * ri * (q1(2) * q1(2) + q1(3) * q1(3)))
    vol1 = ri * (q1(2) * dy - q1(3) * dx)
    ri = 1.0 / q2(1)
    p2 = gm1 * (q2(4) - 0.5 * ri * (q2(2) * q2(2) + q2(3) * q2(3)))
    vol2 = ri * (q2(2) * dy - q2(3) * dx)
    mu = 0.5 * (adt1(1) + adt2(1)) * eps
    f = 0.5 * (vol1 * q1(1) + vol2 * q2(1)) + mu * (q1(1) - q2(1))
    res1(1) = res1(1) + f
    res2(1) = res2(1) - f
    f = 0.5 * (vol1 * q1(2) + p1 * dy + vol2 * q2(2) + p2 * dy) + mu * (q1(2) - q2(2))
    res1(2) = res1(2) + f
    res2(2) = res2(2) - f
    f = 0.5 * (vol1 * q1(3) - p1 * dx + vol2 * q2(3) - p2 * dx) + mu * (q1(3) - q2(3))
    res1(3) = res1(3) + f
    res2(3) = res2(3) - f
    f = 0.5 * (vol1 * (q1(4) + p1) + vol2 * (q2(4) + p2)) + mu * (q1(4) - q2(4))
    res1(4) = res1(4) + f
    res2(4) = res2(4) - f
  END SUBROUTINE 

  attributes(global) SUBROUTINE res_calc_kernel(dimensions_res_calc_device, argsSizes_res_calc_device, opDat1, pindMaps1, &
  &opDat3, pindMaps3, opDat5, pindMaps5, opDat7, pindMaps7, opDat9, pindMaps9, pMaps1, pMaps2, pMaps3, pMaps4, pMaps5, pMap&
  &s6, pMaps7, pMaps8, pMaps9, pMaps10, pindSizes, pindOffs, pblkMap, poffset, pnelems, pnthrcol, pthrcol, blockOffset)

    IMPLICIT NONE

    TYPE ( res_calc_opDatDimensions ) , DEVICE :: dimensions_res_calc_device
    TYPE ( res_calc_variableSizes ) , DEVICE :: argsSizes_res_calc_device
    REAL(kind=8), DIMENSION(0:argsSizes_res_calc_device%opDat1Size - 1), DEVICE :: opDat1
    INTEGER(kind=4), DIMENSION(0:argsSizes_res_calc_device%pindMaps1Size - 1), DEVICE :: pindMaps1
    INTEGER(kind=4), DIMENSION(0:argsSizes_res_calc_device%opDat3Size - 1), DEVICE :: opDat3
    INTEGER(kind=4), DIMENSION(0:argsSizes_res_calc_device%pindMaps3Size - 1), DEVICE :: pindMaps3
    REAL(kind=8), DIMENSION(0:argsSizes_res_calc_device%opDat5Size - 1), DEVICE :: opDat5
    INTEGER(kind=4), DIMENSION(0:argsSizes_res_calc_device%pindMaps5Size - 1), DEVICE :: pindMaps5
    REAL(kind=8), DIMENSION(0:argsSizes_res_calc_device%opDat7Size - 1), DEVICE :: opDat7
    INTEGER(kind=4), DIMENSION(0:argsSizes_res_calc_device%pindMaps7Size - 1), DEVICE :: pindMaps7
    REAL(kind=8), DIMENSION(0:argsSizes_res_calc_device%opDat9Size - 1), DEVICE :: opDat9
    INTEGER(kind=4), DIMENSION(0:argsSizes_res_calc_device%pindMaps9Size - 1), DEVICE :: pindMaps9
    INTEGER(kind=2), DIMENSION(0:argsSizes_res_calc_device%pMaps1Size - 1), DEVICE :: pMaps1
    INTEGER(kind=2), DIMENSION(0:argsSizes_res_calc_device%pMaps2Size - 1), DEVICE :: pMaps2
    INTEGER(kind=2), DIMENSION(0:argsSizes_res_calc_device%pMaps3Size - 1), DEVICE :: pMaps3
    INTEGER(kind=2), DIMENSION(0:argsSizes_res_calc_device%pMaps4Size - 1), DEVICE :: pMaps4
    INTEGER(kind=2), DIMENSION(0:argsSizes_res_calc_device%pMaps5Size - 1), DEVICE :: pMaps5
    INTEGER(kind=2), DIMENSION(0:argsSizes_res_calc_device%pMaps6Size - 1), DEVICE :: pMaps6
    INTEGER(kind=2), DIMENSION(0:argsSizes_res_calc_device%pMaps7Size - 1), DEVICE :: pMaps7
    INTEGER(kind=2), DIMENSION(0:argsSizes_res_calc_device%pMaps8Size - 1), DEVICE :: pMaps8
    INTEGER(kind=2), DIMENSION(0:argsSizes_res_calc_device%pMaps9Size - 1), DEVICE :: pMaps9
    INTEGER(kind=2), DIMENSION(0:argsSizes_res_calc_device%pMaps10Size - 1), DEVICE :: pMaps10
    INTEGER(kind=4), DIMENSION(0:argsSizes_res_calc_device%pindSizesSize - 1), DEVICE :: pindSizes
    INTEGER(kind=4), DIMENSION(0:argsSizes_res_calc_device%pindOffsSize - 1), DEVICE :: pindOffs
    INTEGER(kind=4), DIMENSION(0:argsSizes_res_calc_device%pblkMapSize - 1), DEVICE :: pblkMap
    INTEGER(kind=4), DIMENSION(0:argsSizes_res_calc_device%poffsetSize - 1), DEVICE :: poffset
    INTEGER(kind=4), DIMENSION(0:argsSizes_res_calc_device%pnelemsSize - 1), DEVICE :: pnelems
    INTEGER(kind=4), DIMENSION(0:argsSizes_res_calc_device%pnthrcolSize - 1), DEVICE :: pnthrcol
    INTEGER(kind=4), DIMENSION(0:argsSizes_res_calc_device%pthrcolSize - 1), DEVICE :: pthrcol
    INTEGER(kind=4), VALUE :: blockOffset
    REAL(kind=8), DIMENSION(0:3) :: opDat9Local
    REAL(kind=8), DIMENSION(0:3) :: opDat10Local
    REAL(kind=8), DIMENSION(0:*), SHARED :: autosharedFloat8
    INTEGER(kind=4), DIMENSION(0:*), SHARED :: autosharedInteger4
    INTEGER(kind=4) :: nBytes1
    INTEGER(kind=4) :: nBytes3
    INTEGER(kind=4) :: nBytes5
    INTEGER(kind=4) :: nBytes7
    INTEGER(kind=4) :: nBytes9
    INTEGER(kind=4) :: roundUp1
    INTEGER(kind=4) :: roundUp3
    INTEGER(kind=4) :: roundUp5
    INTEGER(kind=4) :: roundUp7
    INTEGER(kind=4) :: roundUp9
    INTEGER(kind=4) :: argMap9
    INTEGER(kind=4) :: argMap10
    INTEGER(kind=4), SHARED :: ind_arg1
    INTEGER(kind=4), SHARED :: ind_arg3
    INTEGER(kind=4), SHARED :: ind_arg5
    INTEGER(kind=4), SHARED :: ind_arg7
    INTEGER(kind=4), SHARED :: ind_arg9
    INTEGER(kind=4), SHARED :: blockID
    INTEGER(kind=4), SHARED :: blockOffsetShared
    INTEGER(kind=4), SHARED :: ncolor
    INTEGER(kind=4), SHARED :: nelem
    INTEGER(kind=4), SHARED :: nelems2
    INTEGER(kind=4) :: col
    INTEGER(kind=4) :: col2
    INTEGER(kind=4) :: i1
    INTEGER(kind=4) :: i2
    INTEGER(kind=4) :: n
    INTEGER(kind=4) :: moduloResult
    INTEGER(kind=4) :: moduled
    INTEGER(kind=4) :: nbytes

    IF (threadidx%x - 1 == 0) THEN
      blockID = pblkMap(blockidx%x - 1 + blockOffset)
      nelem = pnelems(blockID)
      blockOffsetShared = poffset(blockID)
      nelems2 = blockdim%x * (1 + (nelem - 1) / blockdim%x)
      ncolor = pnthrcol(blockID)
      ind_arg1 = pindSizes(0 + blockID * 5)
      ind_arg3 = pindSizes(1 + blockID * 5)
      ind_arg5 = pindSizes(2 + blockID * 5)
      ind_arg7 = pindSizes(3 + blockID * 5)
      ind_arg9 = pindSizes(4 + blockID * 5)
    END IF

    CALL syncthreads()

    roundUp1 = ind_arg1 * dimensions_res_calc_device%opDat1Dimension
    roundUp3 = ind_arg3 * dimensions_res_calc_device%opDat3Dimension
    roundUp5 = ind_arg5 * dimensions_res_calc_device%opDat5Dimension
    roundUp7 = ind_arg7 * dimensions_res_calc_device%opDat7Dimension
    roundUp9 = ind_arg9 * dimensions_res_calc_device%opDat9Dimension
    nBytes1 = 0
    nBytes3 = nBytes1 + roundUp1
    nBytes5 = nBytes3 + roundUp3
    nBytes7 = nBytes5 + roundUp5
    nBytes9 = nBytes7 + roundUp7
    i1 = threadidx%x - 1
    n = ind_arg1 * dimensions_res_calc_device%opDat1Dimension

    DO WHILE (i1 < n)
      moduled = mod(i1,  dimensions_res_calc_device%opDat1Dimension)
      autosharedFloat8(nBytes1 + i1) = opDat1(moduled + pindMaps1(0 + (pindOffs(0 + blockID * 5) + i1 / dimensions_res_calc_de&
      &vice%opDat1Dimension)) * dimensions_res_calc_device%opDat1Dimension)
      i1 = i1 + blockdim%x
    END DO

    i1 = threadidx%x - 1
    n = ind_arg3 * dimensions_res_calc_device%opDat3Dimension

    DO WHILE (i1 < n)
      moduled = mod(i1,  dimensions_res_calc_device%opDat3Dimension)
      autosharedInteger4(nBytes3 + i1) = opDat3(moduled + pindMaps3(0 + (pindOffs(1 + blockID * 5) + i1 / dimensions_res_calc_&
      &device%opDat3Dimension)) * dimensions_res_calc_device%opDat3Dimension)
      i1 = i1 + blockdim%x
    END DO

    i1 = threadidx%x - 1
    n = ind_arg5 * dimensions_res_calc_device%opDat5Dimension

    DO WHILE (i1 < n)
      moduled = mod(i1,  dimensions_res_calc_device%opDat5Dimension)
      autosharedFloat8(nBytes5 + i1) = opDat5(moduled + pindMaps5(0 + (pindOffs(2 + blockID * 5) + i1 / dimensions_res_calc_de&
      &vice%opDat5Dimension)) * dimensions_res_calc_device%opDat5Dimension)
      i1 = i1 + blockdim%x
    END DO

    i1 = threadidx%x - 1
    n = ind_arg7 * dimensions_res_calc_device%opDat7Dimension

    DO WHILE (i1 < n)
      moduled = mod(i1,  dimensions_res_calc_device%opDat7Dimension)
      autosharedFloat8(nBytes7 + i1) = opDat7(moduled + pindMaps7(0 + (pindOffs(3 + blockID * 5) + i1 / dimensions_res_calc_de&
      &vice%opDat7Dimension)) * dimensions_res_calc_device%opDat7Dimension)
      i1 = i1 + blockdim%x
    END DO

    i1 = threadidx%x - 1
    n = ind_arg9 * dimensions_res_calc_device%opDat9Dimension

    DO WHILE (i1 < n)
      autosharedFloat8(nBytes9 + i1) = 0
      i1 = i1 + blockdim%x
    END DO

    CALL syncthreads()

    i1 = threadidx%x - 1

    DO WHILE (i1 < nelems2)
      col2 = -1

      IF (i1 < nelem) THEN

        DO i2 = 0, dimensions_res_calc_device%opDat9Dimension - 1, 1
          opDat9Local(i2) = 0
        END DO

        DO i2 = 0, dimensions_res_calc_device%opDat10Dimension - 1, 1
          opDat10Local(i2) = 0
        END DO

        CALL res_calc_device(autosharedFloat8(nBytes1 + pMaps1(i1 + blockOffsetShared) * dimensions_res_calc_device%opDat1Dimens&
        &ion:nBytes1 + pMaps1(i1 + blockOffsetShared) * dimensions_res_calc_device%opDat1Dimension + dimensions_res_calc_device%o&
        &pDat1Dimension),  autosharedFloat8(nBytes1 + pMaps2(i1 + blockOffsetShared) * dimensions_res_calc_device%opDat2Dimension&
        &:nBytes1 + pMaps2(i1 + blockOffsetShared) * dimensions_res_calc_device%opDat2Dimension + dimensions_res_calc_device%opDa&
        &t2Dimension),  autosharedInteger4(nBytes3 + pMaps3(i1 + blockOffsetShared) * dimensions_res_calc_device%opDat3Dimension:&
        &nBytes3 + pMaps3(i1 + blockOffsetShared) * dimensions_res_calc_device%opDat3Dimension + dimensions_res_calc_device%opDat&
        &3Dimension),  autosharedInteger4(nBytes3 + pMaps4(i1 + blockOffsetShared) * dimensions_res_calc_device%opDat4Dimension:n&
        &Bytes3 + pMaps4(i1 + blockOffsetShared) * dimensions_res_calc_device%opDat4Dimension + dimensions_res_calc_device%opDat4&
        &Dimension),  autosharedFloat8(nBytes5 + pMaps5(i1 + blockOffsetShared) * dimensions_res_calc_device%opDat5Dimension:nByt&
        &es5 + pMaps5(i1 + blockOffsetShared) * dimensions_res_calc_device%opDat5Dimension + dimensions_res_calc_device%opDat5Dim&
        &ension),  autosharedFloat8(nBytes5 + pMaps6(i1 + blockOffsetShared) * dimensions_res_calc_device%opDat6Dimension:nBytes5&
        & + pMaps6(i1 + blockOffsetShared) * dimensions_res_calc_device%opDat6Dimension + dimensions_res_calc_device%opDat6Dimens&
        &ion),  autosharedFloat8(nBytes7 + pMaps7(i1 + blockOffsetShared) * dimensions_res_calc_device%opDat7Dimension:nBytes7 + &
        &pMaps7(i1 + blockOffsetShared) * dimensions_res_calc_device%opDat7Dimension + dimensions_res_calc_device%opDat7Dimension&
        &),  autosharedFloat8(nBytes7 + pMaps8(i1 + blockOffsetShared) * dimensions_res_calc_device%opDat8Dimension:nBytes7 + pMa&
        &ps8(i1 + blockOffsetShared) * dimensions_res_calc_device%opDat8Dimension + dimensions_res_calc_device%opDat8Dimension), &
        & opDat9Local,  opDat10Local)

        col2 = pthrcol(i1 + blockOffsetShared)
      END IF

      argMap9 = pMaps9(i1 + blockOffsetShared)
      argMap10 = pMaps10(i1 + blockOffsetShared)

      DO col = 0, ncolor - 1, 1

        IF (col2 == col) THEN

          DO i2 = 0, dimensions_res_calc_device%opDat9Dimension - 1, 1
            autosharedFloat8(nBytes9 + (i2 + argMap9 * dimensions_res_calc_device%opDat9Dimension)) = autosharedFloat8(nBytes9 + (i2&
            & + argMap9 * dimensions_res_calc_device%opDat9Dimension)) + opDat9Local(i2)
          END DO

          DO i2 = 0, dimensions_res_calc_device%opDat10Dimension - 1, 1
            autosharedFloat8(nBytes9 + (i2 + argMap10 * dimensions_res_calc_device%opDat10Dimension)) = autosharedFloat8(nBytes9 + (&
            &i2 + argMap10 * dimensions_res_calc_device%opDat10Dimension)) + opDat10Local(i2)
          END DO

        END IF

        CALL syncthreads()

      END DO

      i1 = i1 + blockdim%x
    END DO

    i1 = threadidx%x - 1

    DO WHILE (i1 < ind_arg9 * dimensions_res_calc_device%opDat9Dimension)
      moduled = mod(i1,  dimensions_res_calc_device%opDat9Dimension)
      opDat9(moduled + pindMaps9(0 + (pindOffs(4 + blockID * 5) + i1 / dimensions_res_calc_device%opDat9Dimension)) * dimensio&
      &ns_res_calc_device%opDat9Dimension) = opDat9(moduled + pindMaps9(0 + (pindOffs(4 + blockID * 5) + i1 / dimensions_res_ca&
      &lc_device%opDat9Dimension)) * dimensions_res_calc_device%opDat9Dimension) + autosharedFloat8(nBytes9 + i1)
      i1 = i1 + blockdim%x
    END DO

  END SUBROUTINE 

  attributes(host) SUBROUTINE res_calc_host(userSubroutine, set, opDat1, opIndirection1, opMap1, opAccess1, opDat2, opIndi&
  &rection2, opMap2, opAccess2, opDat3, opIndirection3, opMap3, opAccess3, opDat4, opIndirection4, opMap4, opAccess4, opDat&
  &5, opIndirection5, opMap5, opAccess5, opDat6, opIndirection6, opMap6, opAccess6, opDat7, opIndirection7, opMap7, opAcces&
  &s7, opDat8, opIndirection8, opMap8, opAccess8, opDat9, opIndirection9, opMap9, opAccess9, opDat10, opIndirection10, opMa&
  &p10, opAccess10)

    IMPLICIT NONE

    character(len=8), INTENT(IN) :: userSubroutine
    TYPE ( op_set ) , INTENT(IN) :: set
    TYPE ( op_dat ) , INTENT(IN) :: opDat1
    INTEGER(kind=4), INTENT(IN) :: opIndirection1
    TYPE ( op_map ) , INTENT(IN) :: opMap1
    INTEGER(kind=4), INTENT(IN) :: opAccess1
    TYPE ( op_dat ) , INTENT(IN) :: opDat2
    INTEGER(kind=4), INTENT(IN) :: opIndirection2
    TYPE ( op_map ) , INTENT(IN) :: opMap2
    INTEGER(kind=4), INTENT(IN) :: opAccess2
    TYPE ( op_dat ) , INTENT(IN) :: opDat3
    INTEGER(kind=4), INTENT(IN) :: opIndirection3
    TYPE ( op_map ) , INTENT(IN) :: opMap3
    INTEGER(kind=4), INTENT(IN) :: opAccess3
    TYPE ( op_dat ) , INTENT(IN) :: opDat4
    INTEGER(kind=4), INTENT(IN) :: opIndirection4
    TYPE ( op_map ) , INTENT(IN) :: opMap4
    INTEGER(kind=4), INTENT(IN) :: opAccess4
    TYPE ( op_dat ) , INTENT(IN) :: opDat5
    INTEGER(kind=4), INTENT(IN) :: opIndirection5
    TYPE ( op_map ) , INTENT(IN) :: opMap5
    INTEGER(kind=4), INTENT(IN) :: opAccess5
    TYPE ( op_dat ) , INTENT(IN) :: opDat6
    INTEGER(kind=4), INTENT(IN) :: opIndirection6
    TYPE ( op_map ) , INTENT(IN) :: opMap6
    INTEGER(kind=4), INTENT(IN) :: opAccess6
    TYPE ( op_dat ) , INTENT(IN) :: opDat7
    INTEGER(kind=4), INTENT(IN) :: opIndirection7
    TYPE ( op_map ) , INTENT(IN) :: opMap7
    INTEGER(kind=4), INTENT(IN) :: opAccess7
    TYPE ( op_dat ) , INTENT(IN) :: opDat8
    INTEGER(kind=4), INTENT(IN) :: opIndirection8
    TYPE ( op_map ) , INTENT(IN) :: opMap8
    INTEGER(kind=4), INTENT(IN) :: opAccess8
    TYPE ( op_dat ) , INTENT(IN) :: opDat9
    INTEGER(kind=4), INTENT(IN) :: opIndirection9
    TYPE ( op_map ) , INTENT(IN) :: opMap9
    INTEGER(kind=4), INTENT(IN) :: opAccess9
    TYPE ( op_dat ) , INTENT(IN) :: opDat10
    INTEGER(kind=4), INTENT(IN) :: opIndirection10
    TYPE ( op_map ) , INTENT(IN) :: opMap10
    INTEGER(kind=4), INTENT(IN) :: opAccess10
    INTEGER(kind=4) :: opDat1Size
    INTEGER(kind=4) :: opDat3Size
    INTEGER(kind=4) :: opDat5Size
    INTEGER(kind=4) :: opDat7Size
    INTEGER(kind=4) :: opDat9Size
    REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat1Device
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat3Device
    REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat5Device
    REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat7Device
    REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat9Device
    INTEGER(kind=4) :: nblocks
    INTEGER(kind=4) :: nthread
    INTEGER(kind=4) :: nshared
    INTEGER(kind=4) :: threadSynchRet
    TYPE ( op_plan ) , POINTER :: actualPlan
    TYPE ( c_devptr ) , POINTER, DIMENSION(:) :: pindMaps
    TYPE ( c_devptr ) , POINTER, DIMENSION(:) :: pmaps
    INTEGER(kind=4) :: pindMapsSize
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pindMaps1
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pindMaps3
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pindMaps5
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pindMaps7
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pindMaps9
    INTEGER(kind=4), DIMENSION(1:10) :: args
    INTEGER(kind=4), DIMENSION(1:10) :: idxs
    INTEGER(kind=4), DIMENSION(1:10) :: maps
    INTEGER(kind=4), DIMENSION(1:10) :: accesses
    INTEGER(kind=4), DIMENSION(1:10) :: inds
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps1
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps2
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps3
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps4
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps5
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps6
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps7
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps8
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps9
    INTEGER(kind=2), DIMENSION(:), DEVICE, ALLOCATABLE :: pMaps10
    INTEGER(kind=4) :: pMaps1Size
    INTEGER(kind=4) :: pMaps2Size
    INTEGER(kind=4) :: pMaps3Size
    INTEGER(kind=4) :: pMaps4Size
    INTEGER(kind=4) :: pMaps5Size
    INTEGER(kind=4) :: pMaps6Size
    INTEGER(kind=4) :: pMaps7Size
    INTEGER(kind=4) :: pMaps8Size
    INTEGER(kind=4) :: pMaps9Size
    INTEGER(kind=4) :: pMaps10Size
    INTEGER(kind=4) :: col
    INTEGER(kind=4) :: i1
    INTEGER(kind=4) :: argsNumber
    INTEGER(kind=4) :: indsNumber
    INTEGER(kind=4) :: blockOffset
    INTEGER(kind=4) :: pindSizesSize
    INTEGER(kind=4) :: pindOffsSize
    INTEGER(kind=4) :: pblkMapSize
    INTEGER(kind=4) :: poffsetSize
    INTEGER(kind=4) :: pnelemsSize
    INTEGER(kind=4) :: pnthrcolSize
    INTEGER(kind=4) :: pthrcolSize
    INTEGER(kind=4), POINTER, DIMENSION(:) :: ncolblk
    INTEGER(kind=4), POINTER, DIMENSION(:) :: pnindirect
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pindSizes
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pindOffs
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pblkMap
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: poffset
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pnelems
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pnthrcol
    INTEGER(kind=4), DIMENSION(:), DEVICE, ALLOCATABLE :: pthrcol

    IF (isFirstTime_res_calc .EQV. .TRUE.) THEN
      dimensions_res_calc%opDat1Dimension = opDat1%dim
      dimensions_res_calc%opDat2Dimension = opDat2%dim
      dimensions_res_calc%opDat3Dimension = opDat3%dim
      dimensions_res_calc%opDat4Dimension = opDat4%dim
      dimensions_res_calc%opDat5Dimension = opDat5%dim
      dimensions_res_calc%opDat6Dimension = opDat6%dim
      dimensions_res_calc%opDat7Dimension = opDat7%dim
      dimensions_res_calc%opDat8Dimension = opDat8%dim
      dimensions_res_calc%opDat9Dimension = opDat9%dim
      dimensions_res_calc%opDat10Dimension = opDat10%dim
      argsSizes_res_calc%opDat1Size = opDat1%dim * opDat1%set%size
      argsSizes_res_calc%opDat3Size = opDat3%dim * opDat3%set%size
      argsSizes_res_calc%opDat5Size = opDat5%dim * opDat5%set%size
      argsSizes_res_calc%opDat7Size = opDat7%dim * opDat7%set%size
      argsSizes_res_calc%opDat9Size = opDat9%dim * opDat9%set%size
      args(1) = opDat1%index
      args(2) = opDat2%index
      args(3) = opDat3%index
      args(4) = opDat4%index
      args(5) = opDat5%index
      args(6) = opDat6%index
      args(7) = opDat7%index
      args(8) = opDat8%index
      args(9) = opDat9%index
      args(10) = opDat10%index
      idxs(1) = opIndirection1
      idxs(2) = opIndirection2
      idxs(3) = opIndirection3
      idxs(4) = opIndirection4
      idxs(5) = opIndirection5
      idxs(6) = opIndirection6
      idxs(7) = opIndirection7
      idxs(8) = opIndirection8
      idxs(9) = opIndirection9
      idxs(10) = opIndirection10

      DO i1 = 1, 10, 1

        IF (idxs(i1) /= -1) THEN
          idxs(i1) = idxs(i1) - 1
        END IF

      END DO

      maps(1) = opMap1%index
      maps(2) = opMap2%index
      maps(3) = opMap3%index
      maps(4) = opMap4%index
      maps(5) = opMap5%index
      maps(6) = opMap6%index
      maps(7) = opMap7%index
      maps(8) = opMap8%index
      maps(9) = opMap9%index
      maps(10) = opMap10%index
      accesses(1) = opAccess1
      accesses(2) = opAccess2
      accesses(3) = opAccess3
      accesses(4) = opAccess4
      accesses(5) = opAccess5
      accesses(6) = opAccess6
      accesses(7) = opAccess7
      accesses(8) = opAccess8
      accesses(9) = opAccess9
      accesses(10) = opAccess10
      inds(1) = 0
      inds(2) = 0
      inds(3) = 1
      inds(4) = 1
      inds(5) = 2
      inds(6) = 2
      inds(7) = 3
      inds(8) = 3
      inds(9) = 4
      inds(10) = 4
      argsNumber = 10
      indsNumber = 5
      planRet = cplan(userSubroutine,  set%index,  argsNumber,  args,  idxs,  maps,  accesses,  indsNumber,  inds)
    END IF

    opDat1Size = opDat1%dim * opDat1%set%size
    opDat3Size = opDat3%dim * opDat3%set%size
    opDat5Size = opDat5%dim * opDat5%set%size
    opDat7Size = opDat7%dim * opDat7%set%size
    opDat9Size = opDat9%dim * opDat9%set%size
    CALL c_f_pointer(opDat1%dat_d,  opDat1Device,  (/opDat1Size/))

    CALL c_f_pointer(opDat3%dat_d,  opDat3Device,  (/opDat3Size/))

    CALL c_f_pointer(opDat5%dat_d,  opDat5Device,  (/opDat5Size/))

    CALL c_f_pointer(opDat7%dat_d,  opDat7Device,  (/opDat7Size/))

    CALL c_f_pointer(opDat9%dat_d,  opDat9Device,  (/opDat9Size/))

    CALL c_f_pointer(planRet,  actualPlan)

    CALL c_f_pointer(actualPlan%nindirect,  pnindirect,  (/indsNumber/))

    CALL c_f_pointer(actualPlan%maps,  pmaps,  (/argsNumber/))

    IF (inds(1) >= 0) THEN
      pMaps1Size = set%size
      CALL c_f_pointer(pmaps(1),  pMaps1,  (/pMaps1Size/))

    END IF

    IF (inds(2) >= 0) THEN
      pMaps2Size = set%size
      CALL c_f_pointer(pmaps(2),  pMaps2,  (/pMaps2Size/))

    END IF

    IF (inds(3) >= 0) THEN
      pMaps3Size = set%size
      CALL c_f_pointer(pmaps(3),  pMaps3,  (/pMaps3Size/))

    END IF

    IF (inds(4) >= 0) THEN
      pMaps4Size = set%size
      CALL c_f_pointer(pmaps(4),  pMaps4,  (/pMaps4Size/))

    END IF

    IF (inds(5) >= 0) THEN
      pMaps5Size = set%size
      CALL c_f_pointer(pmaps(5),  pMaps5,  (/pMaps5Size/))

    END IF

    IF (inds(6) >= 0) THEN
      pMaps6Size = set%size
      CALL c_f_pointer(pmaps(6),  pMaps6,  (/pMaps6Size/))

    END IF

    IF (inds(7) >= 0) THEN
      pMaps7Size = set%size
      CALL c_f_pointer(pmaps(7),  pMaps7,  (/pMaps7Size/))

    END IF

    IF (inds(8) >= 0) THEN
      pMaps8Size = set%size
      CALL c_f_pointer(pmaps(8),  pMaps8,  (/pMaps8Size/))

    END IF

    IF (inds(9) >= 0) THEN
      pMaps9Size = set%size
      CALL c_f_pointer(pmaps(9),  pMaps9,  (/pMaps9Size/))

    END IF

    IF (inds(10) >= 0) THEN
      pMaps10Size = set%size
      CALL c_f_pointer(pmaps(10),  pMaps10,  (/pMaps10Size/))

    END IF

    CALL c_f_pointer(actualPlan%ind_maps,  pindMaps,  (/indsNumber/))

    CALL c_f_pointer(actualPlan%ncolblk,  ncolblk,  set%size)

    pindSizesSize = actualPlan%nblocks * indsNumber
    CALL c_f_pointer(actualPlan%ind_sizes,  pindSizes,  (/pindSizesSize/))

    pindOffsSize = pindSizesSize
    CALL c_f_pointer(actualPlan%ind_offs,  pindOffs,  (/pindOffsSize/))

    pblkMapSize = actualPlan%nblocks
    CALL c_f_pointer(actualPlan%blkmap,  pblkMap,  (/pblkMapSize/))

    poffsetSize = actualPlan%nblocks
    CALL c_f_pointer(actualPlan%offset,  poffset,  (/poffsetSize/))

    pnelemsSize = actualPlan%nblocks
    CALL c_f_pointer(actualPlan%nelems,  pnelems,  (/pnelemsSize/))

    pnthrcolSize = actualPlan%nblocks
    CALL c_f_pointer(actualPlan%nthrcol,  pnthrcol,  (/pnthrcolSize/))

    pthrcolSize = set%size
    CALL c_f_pointer(actualPlan%thrcol,  pthrcol,  (/pthrcolSize/))

    CALL c_f_pointer(pindMaps(1),  pindMaps1,  pnindirect(1))

    CALL c_f_pointer(pindMaps(2),  pindMaps3,  pnindirect(2))

    CALL c_f_pointer(pindMaps(3),  pindMaps5,  pnindirect(3))

    CALL c_f_pointer(pindMaps(4),  pindMaps7,  pnindirect(4))

    CALL c_f_pointer(pindMaps(5),  pindMaps9,  pnindirect(5))

    IF (isFirstTime_res_calc .EQV. .TRUE.) THEN
      isFirstTime_res_calc = .FALSE.
      argsSizes_res_calc%pindMaps1Size = pnindirect(1)
      argsSizes_res_calc%pindMaps3Size = pnindirect(2)
      argsSizes_res_calc%pindMaps5Size = pnindirect(3)
      argsSizes_res_calc%pindMaps7Size = pnindirect(4)
      argsSizes_res_calc%pindMaps9Size = pnindirect(5)
      argsSizes_res_calc%pMaps1Size = pMaps1Size
      argsSizes_res_calc%pMaps2Size = pMaps2Size
      argsSizes_res_calc%pMaps3Size = pMaps3Size
      argsSizes_res_calc%pMaps4Size = pMaps4Size
      argsSizes_res_calc%pMaps5Size = pMaps5Size
      argsSizes_res_calc%pMaps6Size = pMaps6Size
      argsSizes_res_calc%pMaps7Size = pMaps7Size
      argsSizes_res_calc%pMaps8Size = pMaps8Size
      argsSizes_res_calc%pMaps9Size = pMaps9Size
      argsSizes_res_calc%pMaps10Size = pMaps10Size
      argsSizes_res_calc%pblkMapSize = pblkMapSize
      argsSizes_res_calc%pindOffsSize = pindOffsSize
      argsSizes_res_calc%pindSizesSize = pindSizesSize
      argsSizes_res_calc%pnelemsSize = pnelemsSize
      argsSizes_res_calc%pnthrcolSize = pnthrcolSize
      argsSizes_res_calc%poffsetSize = poffsetSize
      argsSizes_res_calc%pthrcolSize = pthrcolSize
    END IF

    IF (doInitialiseConstants .EQV. .TRUE.) THEN
      doInitialiseConstants = .FALSE.
      CALL InitialiseConstants()

    END IF

    blockOffset = 0

    DO col = 0, actualPlan%ncolors - 1, 1
      nblocks = ncolblk(col + 1)
      nthread = FOP_BLOCK_SIZE
      nshared = actualPlan%nshared
      CALL res_calc_kernel<<<nblocks, nthread, nshared>>>(dimensions_res_calc,  argsSizes_res_calc,  opDat1Device,  pindMaps1,&
      &  opDat3Device,  pindMaps3,  opDat5Device,  pindMaps5,  opDat7Device,  pindMaps7,  opDat9Device,  pindMaps9,  pMaps1,  p&
      &Maps2,  pMaps3,  pMaps4,  pMaps5,  pMaps6,  pMaps7,  pMaps8,  pMaps9,  pMaps10,  pindSizes,  pindOffs,  pblkMap,  poffse&
      &t,  pnelems,  pnthrcol,  pthrcol,  blockOffset)

      threadSynchRet = cudaThreadSynchronize()
      blockOffset = blockOffset + nblocks
    END DO

  END SUBROUTINE 

  attributes(device) SUBROUTINE save_soln_device(q, qold)

    IMPLICIT NONE

    REAL(kind=8), DIMENSION(*) :: q
    REAL(kind=8), DIMENSION(*) :: qold
    INTEGER(kind=4) :: i

    DO i = 1, 4
      qold(i) = q(i)
    END DO

  END SUBROUTINE 

  attributes(global) SUBROUTINE save_soln_kernel(dimensions_save_soln_device, argsSizes_save_soln_device, opDat1, opDat2, &
  &warpScratchpadSize, setSize, warpSize)

    IMPLICIT NONE

    TYPE ( save_soln_opDatDimensions ) , DEVICE :: dimensions_save_soln_device
    TYPE ( save_soln_variableSizes ) , DEVICE :: argsSizes_save_soln_device
    REAL(kind=8), DIMENSION(0:argsSizes_save_soln_device%opDat1Size - 1), DEVICE :: opDat1
    REAL(kind=8), DIMENSION(0:argsSizes_save_soln_device%opDat2Size - 1), DEVICE :: opDat2
    INTEGER(kind=4), VALUE :: warpScratchpadSize
    INTEGER(kind=4), VALUE :: setSize
    INTEGER(kind=4), VALUE :: warpSize
    INTEGER(kind=4) :: n
    INTEGER(kind=4) :: m
    INTEGER(kind=4) :: tid
    INTEGER(kind=4) :: offset
    INTEGER(kind=4) :: nelems
    INTEGER(kind=4) :: autosharedDisplacement
    REAL(kind=8), DIMENSION(0:3) :: opDat1Local
    REAL(kind=8), DIMENSION(0:3) :: opDat2Local
    REAL(kind=8), DIMENSION(0:*), SHARED :: autosharedFloat8
    tid = mod(threadidx%x - 1,  warpSize)
    autosharedDisplacement = warpScratchpadSize * ((threadidx%x - 1) / warpSize) / 8

    DO n = threadidx%x - 1 + (blockidx%x - 1) * blockdim%x, setSize - 1, blockdim%x * griddim%x
      offset = n - tid
      nelems = min(warpSize,  setSize - offset)

      DO m = 0, dimensions_save_soln_device%opDat1Dimension, 1
        autosharedFloat8(autosharedDisplacement + (tid + m * nelems)) = opDat1(tid + (m * nelems + offset * dimensions_save_soln&
        &_device%opDat1Dimension))
      END DO

      DO m = 0, dimensions_save_soln_device%opDat1Dimension, 1
        opDat1Local(m) = autosharedFloat8(autosharedDisplacement + (m + tid * dimensions_save_soln_device%opDat1Dimension))
      END DO

      CALL save_soln_device(opDat1Local,  opDat2Local)

      DO m = 0, dimensions_save_soln_device%opDat2Dimension - 1, 1
        autosharedFloat8(autosharedDisplacement + (m + tid * dimensions_save_soln_device%opDat2Dimension)) = opDat2Local(m)
      END DO

      DO m = 0, dimensions_save_soln_device%opDat2Dimension - 1, 1
        opDat2(tid + (m * nelems + offset * dimensions_save_soln_device%opDat2Dimension)) = autosharedFloat8(autosharedDisplacem&
        &ent + (tid + m * nelems))
      END DO

    END DO

  END SUBROUTINE 

  attributes(host) SUBROUTINE save_soln_host(userSubroutine, set, opDat1, opIndirection1, opMap1, opAccess1, opDat2, opInd&
  &irection2, opMap2, opAccess2)

    IMPLICIT NONE

    character(len=9), INTENT(IN) :: userSubroutine
    TYPE ( op_set ) , INTENT(IN) :: set
    TYPE ( op_dat ) , INTENT(IN) :: opDat1
    INTEGER(kind=4), INTENT(IN) :: opIndirection1
    TYPE ( op_map ) , INTENT(IN) :: opMap1
    INTEGER(kind=4), INTENT(IN) :: opAccess1
    TYPE ( op_dat ) , INTENT(IN) :: opDat2
    INTEGER(kind=4), INTENT(IN) :: opIndirection2
    TYPE ( op_map ) , INTENT(IN) :: opMap2
    INTEGER(kind=4), INTENT(IN) :: opAccess2
    INTEGER(kind=4) :: opDat1Size
    INTEGER(kind=4) :: opDat2Size
    REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat1Device
    REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat2Device
    INTEGER(kind=4) :: nblocks
    INTEGER(kind=4) :: nthread
    INTEGER(kind=4) :: nshared
    INTEGER(kind=4) :: threadSynchRet
    INTEGER(kind=4) :: offset = 0
    INTEGER(kind=4) :: warpSize = 0

    IF (isFirstTime_save_soln .EQV. .TRUE.) THEN
      dimensions_save_soln%opDat1Dimension = opDat1%dim
      dimensions_save_soln%opDat2Dimension = opDat2%dim
      argsSizes_save_soln%opDat1Size = opDat1%dim * opDat1%set%size
      argsSizes_save_soln%opDat2Size = opDat2%dim * opDat2%set%size
      isFirstTime_save_soln = .FALSE.
    END IF

    nblocks = 200
    nthread = 128
    warpSize = OP_WARP_SIZE
    nshared = 0
    nshared = max(nshared,  4 * 8)
    nshared = max(nshared,  4 * 8)
    offset = nshared * OP_WARP_SIZE
    nshared = nshared * nthread
    opDat1Size = opDat1%dim * opDat1%set%size
    opDat2Size = opDat2%dim * opDat2%set%size
    CALL c_f_pointer(opDat1%dat_d,  opDat1Device,  (/opDat1Size/))

    CALL c_f_pointer(opDat2%dat_d,  opDat2Device,  (/opDat2Size/))

    argsSizes_save_soln%opDat1Size = opDat1Size
    argsSizes_save_soln%opDat2Size = opDat2Size

    IF (doInitialiseConstants .EQV. .TRUE.) THEN
      doInitialiseConstants = .FALSE.
      CALL InitialiseConstants()

    END IF

    CALL save_soln_kernel<<<nblocks, nthread, nshared>>>(dimensions_save_soln,  argsSizes_save_soln,  opDat1Device,  opDat2D&
    &evice,  offset,  set%size,  warpSize)

    threadSynchRet = cudaThreadSynchronize()
  END SUBROUTINE 

  attributes(device) SUBROUTINE update_device(qold, q, res, adt, rms)

    IMPLICIT NONE

    REAL(kind=8), DIMENSION(*) :: qold
    REAL(kind=8), DIMENSION(*) :: q
    REAL(kind=8), DIMENSION(*) :: res
    REAL(kind=8), DIMENSION(*) :: adt
    REAL(kind=8), DIMENSION(*) :: rms
    REAL(kind=8) :: del,adti
    INTEGER(kind=4) :: i
    adti = 1.0 / adt(1)

    DO i = 1, 4
      del = adti * res(i)
      q(i) = qold(i) - del
      res(i) = 0.0
      rms(1) = rms(1) + del * del
    END DO

  END SUBROUTINE 

  attributes(global) SUBROUTINE update_kernel(dimensions_update_device, argsSizes_update_device, opDat1, opDat2, opDat3, o&
  &pDat4, opDat5, warpScratchpadSize, setSize, warpSize)

    IMPLICIT NONE

    TYPE ( update_opDatDimensions ) , DEVICE :: dimensions_update_device
    TYPE ( update_variableSizes ) , DEVICE :: argsSizes_update_device
    REAL(kind=8), DIMENSION(0:argsSizes_update_device%opDat1Size - 1), DEVICE :: opDat1
    REAL(kind=8), DIMENSION(0:argsSizes_update_device%opDat2Size - 1), DEVICE :: opDat2
    REAL(kind=8), DIMENSION(0:argsSizes_update_device%opDat3Size - 1), DEVICE :: opDat3
    REAL(kind=8), DIMENSION(0:argsSizes_update_device%opDat4Size - 1), DEVICE :: opDat4
    REAL(kind=8), DIMENSION(0:argsSizes_update_device%opDat5Size - 1), DEVICE :: opDat5
    INTEGER(kind=4), VALUE :: warpScratchpadSize
    INTEGER(kind=4), VALUE :: setSize
    INTEGER(kind=4), VALUE :: warpSize
    INTEGER(kind=4) :: n
    INTEGER(kind=4) :: m
    INTEGER(kind=4) :: tid
    INTEGER(kind=4) :: offset
    INTEGER(kind=4) :: nelems
    INTEGER(kind=4) :: autosharedDisplacement
    REAL(kind=8), DIMENSION(0:3) :: opDat1Local
    REAL(kind=8), DIMENSION(0:3) :: opDat2Local
    REAL(kind=8), DIMENSION(0:3) :: opDat3Local
    REAL(kind=8), DIMENSION(0:0) :: opDat5Local
    REAL(kind=8), DIMENSION(0:*), SHARED :: autosharedFloat8
    INTEGER(kind=4), VALUE :: offsetReduction
    tid = mod(threadidx%x - 1,  warpSize)
    autosharedDisplacement = warpScratchpadSize * ((threadidx%x - 1) / warpSize) / 8

    DO n = 0, 0, 1
      opDat5Local(n) = 0
    END DO

    DO n = threadidx%x - 1 + (blockidx%x - 1) * blockdim%x, setSize - 1, blockdim%x * griddim%x
      offset = n - tid
      nelems = min(warpSize,  setSize - offset)

      DO m = 0, dimensions_update_device%opDat1Dimension, 1
        autosharedFloat8(autosharedDisplacement + (tid + m * nelems)) = opDat1(tid + (m * nelems + offset * dimensions_update_de&
        &vice%opDat1Dimension))
      END DO

      DO m = 0, dimensions_update_device%opDat1Dimension, 1
        opDat1Local(m) = autosharedFloat8(autosharedDisplacement + (m + tid * dimensions_update_device%opDat1Dimension))
      END DO

      DO m = 0, dimensions_update_device%opDat3Dimension, 1
        autosharedFloat8(autosharedDisplacement + (tid + m * nelems)) = opDat3(tid + (m * nelems + offset * dimensions_update_de&
        &vice%opDat3Dimension))
      END DO

      DO m = 0, dimensions_update_device%opDat3Dimension, 1
        opDat3Local(m) = autosharedFloat8(autosharedDisplacement + (m + tid * dimensions_update_device%opDat3Dimension))
      END DO

      CALL update_device(opDat1Local,  opDat2Local,  opDat3Local,  opDat4(n:n + 0),  opDat5Local)

      DO m = 0, dimensions_update_device%opDat2Dimension - 1, 1
        autosharedFloat8(autosharedDisplacement + (m + tid * dimensions_update_device%opDat2Dimension)) = opDat2Local(m)
      END DO

      DO m = 0, dimensions_update_device%opDat2Dimension - 1, 1
        opDat2(tid + (m * nelems + offset * dimensions_update_device%opDat2Dimension)) = autosharedFloat8(autosharedDisplacement&
        & + (tid + m * nelems))
      END DO

      DO m = 0, dimensions_update_device%opDat3Dimension - 1, 1
        autosharedFloat8(autosharedDisplacement + (m + tid * dimensions_update_device%opDat3Dimension)) = opDat3Local(m)
      END DO

      DO m = 0, dimensions_update_device%opDat3Dimension - 1, 1
        opDat3(tid + (m * nelems + offset * dimensions_update_device%opDat3Dimension)) = autosharedFloat8(autosharedDisplacement&
        & + (tid + m * nelems))
      END DO

    END DO

    DO n = 0, 0, 1
      CALL ReductionFloat8(opDat5(n + (blockidx%x - 1) * 1:n + (blockidx%x - 1) * 1 + 0),  opDat5Local(n),  warpSize,  offsetR&
      &eduction,  0)

    END DO

  END SUBROUTINE 

  attributes(host) SUBROUTINE update_host(userSubroutine, set, opDat1, opIndirection1, opMap1, opAccess1, opDat2, opIndire&
  &ction2, opMap2, opAccess2, opDat3, opIndirection3, opMap3, opAccess3, opDat4, opIndirection4, opMap4, opAccess4, opDat5,&
  & opIndirection5, opMap5, opAccess5)

    IMPLICIT NONE

    character(len=6), INTENT(IN) :: userSubroutine
    TYPE ( op_set ) , INTENT(IN) :: set
    TYPE ( op_dat ) , INTENT(IN) :: opDat1
    INTEGER(kind=4), INTENT(IN) :: opIndirection1
    TYPE ( op_map ) , INTENT(IN) :: opMap1
    INTEGER(kind=4), INTENT(IN) :: opAccess1
    TYPE ( op_dat ) , INTENT(IN) :: opDat2
    INTEGER(kind=4), INTENT(IN) :: opIndirection2
    TYPE ( op_map ) , INTENT(IN) :: opMap2
    INTEGER(kind=4), INTENT(IN) :: opAccess2
    TYPE ( op_dat ) , INTENT(IN) :: opDat3
    INTEGER(kind=4), INTENT(IN) :: opIndirection3
    TYPE ( op_map ) , INTENT(IN) :: opMap3
    INTEGER(kind=4), INTENT(IN) :: opAccess3
    TYPE ( op_dat ) , INTENT(IN) :: opDat4
    INTEGER(kind=4), INTENT(IN) :: opIndirection4
    TYPE ( op_map ) , INTENT(IN) :: opMap4
    INTEGER(kind=4), INTENT(IN) :: opAccess4
    TYPE ( op_dat ) , INTENT(IN) :: opDat5
    INTEGER(kind=4), INTENT(IN) :: opIndirection5
    TYPE ( op_map ) , INTENT(IN) :: opMap5
    INTEGER(kind=4), INTENT(IN) :: opAccess5
    INTEGER(kind=4) :: opDat1Size
    INTEGER(kind=4) :: opDat2Size
    INTEGER(kind=4) :: opDat3Size
    INTEGER(kind=4) :: opDat4Size
    INTEGER(kind=4) :: opDat5Size
    REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat1Device
    REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat2Device
    REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat3Device
    REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat4Device
    REAL(kind=8), DIMENSION(:), DEVICE, ALLOCATABLE :: opDat5Device
    REAL(kind=8), POINTER, DIMENSION(:) :: opDat5Host
    INTEGER(kind=4) :: nblocks
    INTEGER(kind=4) :: nthread
    INTEGER(kind=4) :: nshared
    INTEGER(kind=4) :: threadSynchRet
    INTEGER(kind=4) :: offset = 0
    INTEGER(kind=4) :: warpSize = 0
    INTEGER(kind=4) :: i1
    INTEGER(kind=4) :: i2
    INTEGER(kind=4) :: sharedMemoryStartOffset
    INTEGER(kind=4) :: maxSharedMemoryBytes
    INTEGER(kind=4) :: threadItems
    INTEGER(kind=4) :: maxThreadBlocks

    IF (isFirstTime_update .EQV. .TRUE.) THEN
      dimensions_update%opDat1Dimension = opDat1%dim
      dimensions_update%opDat2Dimension = opDat2%dim
      dimensions_update%opDat3Dimension = opDat3%dim
      dimensions_update%opDat4Dimension = opDat4%dim
      dimensions_update%opDat5Dimension = opDat5%dim
      argsSizes_update%opDat1Size = opDat1%dim * opDat1%set%size
      argsSizes_update%opDat2Size = opDat2%dim * opDat2%set%size
      argsSizes_update%opDat3Size = opDat3%dim * opDat3%set%size
      argsSizes_update%opDat4Size = opDat4%dim * opDat4%set%size
      allocate( reductionArrayHost(threadItems) )
      allocate( reductionArrayDevice(threadItems) )
      isFirstTime_update = .FALSE.
    END IF

    nblocks = 200
    nthread = 128
    warpSize = OP_WARP_SIZE
    nshared = 0
    nshared = max(nshared,  4 * 8)
    nshared = max(nshared,  4 * 8)
    nshared = max(nshared,  4 * 8)
    offset = nshared * OP_WARP_SIZE
    nshared = nshared * nthread
    opDat1Size = opDat1%dim * opDat1%set%size
    opDat2Size = opDat2%dim * opDat2%set%size
    opDat3Size = opDat3%dim * opDat3%set%size
    opDat4Size = opDat4%dim * opDat4%set%size
    CALL c_f_pointer(opDat1%dat_d,  opDat1Device,  (/opDat1Size/))

    CALL c_f_pointer(opDat2%dat_d,  opDat2Device,  (/opDat2Size/))

    CALL c_f_pointer(opDat3%dat_d,  opDat3Device,  (/opDat3Size/))

    CALL c_f_pointer(opDat4%dat_d,  opDat4Device,  (/opDat4Size/))

    CALL c_f_pointer(opDat5%dat_d,  opDat5Device,  (/opDat5Size/))

    CALL c_f_pointer(opDat5%dat,  opDat5Host,  (/opDat5Size/))

    opDat5Device = opDat5Host
    maxThreadBlocks = nblocks
    threadItems = maxThreadBlocks * -1

    DO i1 = 0, threadItems, 1
      reductionArrayHost(i1) = 0.00000
    END DO

    reductionArrayDevice = reductionArrayHost
    sharedMemoryStartOffset = nshared
    maxSharedMemoryBytes = nthread * -1
    nshared = nshared + maxSharedMemoryBytes
    argsSizes_update%opDat1Size = opDat1Size
    argsSizes_update%opDat2Size = opDat2Size
    argsSizes_update%opDat3Size = opDat3Size
    argsSizes_update%opDat4Size = opDat4Size
    argsSizes_update%opDat5Size = threadItems

    IF (doInitialiseConstants .EQV. .TRUE.) THEN
      doInitialiseConstants = .FALSE.
      CALL InitialiseConstants()

    END IF

    CALL update_kernel<<<nblocks, nthread, nshared>>>(dimensions_update,  argsSizes_update,  opDat1Device,  opDat2Device,  o&
    &pDat3Device,  opDat4Device,  reductionArrayDevice,  offset,  set%size,  warpSize,  sharedMemoryStartOffset)

    threadSynchRet = cudaThreadSynchronize()
    reductionArrayHost = reductionArrayDevice

    DO i1 = 0, threadItems, 1

      DO i2 = 0, 0, 1
        opDat5Device(i2 + 1) = opDat5Device(i2 + 1) + reductionArrayHost(i2 + i1 * 1)
      END DO

    END DO

  END SUBROUTINE 

END MODULE GENERATED_MODULE

